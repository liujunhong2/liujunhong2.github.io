<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Anoconda</title>
    <url>/Anoconda-setup.html</url>
    <content><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载一个合适版本的安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<p>执行安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2024.06-1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>

<p>按 Enter 键查看许可协议，按q结束快速结束内容，最后输入 yes同意协议，然后按 Enter 接受默认安装位置<code>/home/&lt;USER&gt;/anaconda3</code> 。</p>
<p>最后会问你要不要每次启动都默认激活conda环境</p>
<blockquote>
<p>Do you wish to update your shell profile to automatically initialize conda?<br>This will activate conda on startup and change the command prompt when activated.<br>If you’d prefer that conda’s base environment not be activated on startup,<br>   run the following command when conda is activated:</p>
<p>conda config –set auto_activate_base false</p>
<p>You can undo this by running <code>conda init --reverse $SHELL</code>? [yes|no]<br>[no] &gt;&gt;&gt;</p>
</blockquote>
<p>我的选择是默认的no(Enter)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --set auto_activate_base false</span><br></pre></td></tr></table></figure>

<p>随之而来的是自己完成初始化</p>
<blockquote>
<p>You have chosen to not have conda modify your shell scripts at all.<br>To activate conda’s base environment in your current shell session:</p>
<p><strong>eval “$(&#x2F;home&#x2F;<username>&#x2F;anaconda3&#x2F;bin&#x2F;conda shell.YOUR_SHELL_NAME hook)”</username></strong></p>
<p>To install conda’s shell functions for easier access, first activate, then:</p>
<p><strong>conda init</strong></p>
<p>Thank you for installing Anaconda3!</p>
</blockquote>
<p>例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">eval &quot;$(/home/user1/anaconda3/bin/conda shell.zsh hook)</span><br></pre></td></tr></table></figure>

<p>最后init</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda init &lt;zsh&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">zsh是我自己的shell,默认的是bash</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure>

<blockquote>
<p>conda 24.5.0</p>
</blockquote>
<p>完成！</p>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.condarc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>写入如下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line"></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></blockquote>
<p>保存后退出并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda clean -i</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>检查虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure>

<p>创建虚拟环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有环境包时</span></span><br><span class="line">conda env create -f env_name.yml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">普通</span></span><br><span class="line">conda create -n env_name python=3.6</span><br></pre></td></tr></table></figure>

<p>激活</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消激活当前环境可</span></span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure>

<p>删除虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda remove -n env_name --all</span><br></pre></td></tr></table></figure>



<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install anaconda-clean</span><br><span class="line">anaconda-clean</span><br><span class="line">rm -rf anaconda3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最后删掉 .bashrc 中的 conda</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2></blockquote>
<p><a href="https://www.cnblogs.com/moonout/p/18334292">博客园</a>.</p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Bodyguard</title>
    <url>/Bodyguard.html</url>
    <content><![CDATA[<!--more-->
<p>本文的主角大卫-邦德，一名军人、一名警察、一位丈夫、一位父亲，在剧中一开始就展示了异于常人的洞察力与共情力，以及应对突发情况的专业素养，我深深地被这一位柔情硬汉打动。然而，这样一位可以说是通情达理的人，居然和妻子处于分居状态，这也让我对邦德的身世经历充满了好奇，他看起来孤独，忧郁，甚至还有抑郁症，其实这并不与其外在的沉着形象冲突，他的外在其实也是真实的他自己，因为有时候我们宁愿真实地面对他人，也不愿坦白对待自己。大卫邦德的故事也是一名贴身保镖的故事，因为他的英勇举动震惊全英，各界都高度关注这样一位能够说服自杀炸弹携带者以保护全列车人的警察，尤其是政府高层，因此，他被授予了一项特殊的任务，成为内务大臣的贴身保镖，而真正的大卫邦德，开始逐渐浮现。</p>
<p>最讨厌内务大臣的人反而成为了内务大臣身边最亲近的人。大卫邦德与内务大臣有瓜葛吗，当然，谁都不会无缘无故讨厌一个素不相识的人，前面提到大卫邦德是一名军人，没错，他曾是一名军人，被派往阿富汗参加非正义的战争，也因此大卫邦德失去了很多位亲密的兄弟，自己也差点殒命，最重要的是大卫邦德患上了<a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%82%B7%E5%BE%8C%E5%A3%93%E5%8A%9B%E7%97%87">创伤后应激障碍</a>，而这些军人有一个共同的敌人，那就是那些视他们生命如自己权力牺牲品的、不愿意亲自留一滴血的冷血的势力的政客。而与内务大臣相遇的前期，她不出意外的体现了出了所有令大卫邦德和他战友所讨厌的特征，并且当大卫邦德亲自问她所作言论是否属实时，内务大臣却说为了大局她必须有所抉择，这彻底激怒了大卫邦德。大卫邦德有无数次想亲自了解这位不知悔改的政客，但是却又出于职业道德无数次拯救内务大臣，甚至在一场暗杀中，大卫也“杀死”了身为战友的杀手，而那名自杀的战友，在某种意义上，将未完成的使命又加重在大卫邦德身上。</p>
<p>也许是一次次的生死与共，又或者是孤独灵魂的相遇，内务大臣和大卫邦德在劫后余生时，用身体抚慰惊魂。起初我只是认为内务大臣为了让大卫邦德全心全意的保护自己于是上演了美人计，同时也认为大卫邦德为了更靠近内务大臣配合了这场演出，但内务大臣对大卫邦德的孩子们的帮助，以及大卫邦德虽帮助自己的直属上司切确内务大臣的情报却装作一无所获，还有内务大臣在演讲时被炸弹袭击殒命后大卫邦德的愤怒，都向我传达出一个讯号，那就是，他们在某种意义上被连接在了一起，是那种亦敌亦友的耐人寻味，因为大卫邦德还爱着自己的分居妻子，且我也很难接受这种极端情形下的爱情，因此我认为这不算得上是爱情，而是更倾向于前文所说的相互抚慰，因为他们一个处于PTSD的笼罩，一个站在政界的风口浪尖，两人因为不同的原因，随时都有可能失去生命。</p>
<p>在内务大臣死后，整个剧集只剩下快节奏的追凶，打斗与推理反转，这也是看的最爽的一部分，然我近乎忘记了外界时间的流逝，但能回忆起来的所剩无几。</p>
<p>在忘掉之前，我必须首先提及我影响最深刻的几个角色，又或者说，剧集中对每个人物几乎都有两面塑造，这也是我们最能引起共鸣的地方，每个人是善也是恶，有冲动也有冷静，我看到了每个角色的独有魅力，警察、伴侣、同事、朋友、上级、上级之上级。而大卫邦德之所患了PTSD还能继续当警察甚至是贴身保镖，是因为他对别人隐瞒了病情，只有最亲近的人，也就是战友和妻子知道，而当最后大卫邦德放下了乔装的坚强，向心理医生袒露自己的脆弱后，我们依旧能够被重归于好的大卫邦德和其妻子薇琪的幸福一家所温暖。是啊，原来接受治疗，打开心扉就能回归正常生活，就剩感受最平凡的快乐，但是，有些时候，难的不是治疗，而是接受治疗，难的不是现状，而是接受现状，我想，不向朋友掩盖，不对家人伪装，真实的表达自己，表达诉求，不要害怕窘迫，懂你的人不会让你难堪，所谓懂你的人无需多言，不懂的人何必多言，接受你真实向世界表达后的所有结果。</p>
]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>something</tag>
      </tags>
  </entry>
  <entry>
    <title>DES和IDEA的CPP实现</title>
    <url>/DES%E5%92%8CIDEA%E7%9A%84CPP%E5%AE%9E%E7%8E%B0.html</url>
    <content><![CDATA[<!--more-->

<p>在std版本中，当输入的文本以<code>@</code>开头且后面跟的是绝对地址时，可以读取文档。</p>
<h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>数据加密标准（Data Encryption Standard，DES）能够依赖64位密钥加密64位明文，将64位密文反向使用64位密钥生成的子密钥可以按照完全相同的步骤把密文解密为明文，加密步骤如下：</p>
<ol>
<li>输入准备</li>
</ol>
<ul>
<li>明文：64 位分组（若不足64位则进行填充）。 (<a href="https://www.cnblogs.com/idreamo/p/9333753.html?utm_source=chatgpt.com">cnblogs.com</a>)</li>
<li>密钥：64 位（其中有效56 位，8 位用于奇偶校验）用于生成子密钥。 (<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<ol start="2">
<li>初始置换（Initial Permutation，IP）</li>
</ol>
<ul>
<li>将64 位明文按照固定表进行重排，得到一个置换后的64 位数据。 (<a href="https://blog.csdn.net/Demonslzh/article/details/129129493?utm_source=chatgpt.com">CSDN博客</a>)</li>
<li>将置换结果分成左右两个32 位部分：L₀ 和 R₀。 (<a href="https://houbb.github.io/2020/06/17/althgorim-cryptograph-05-des?utm_source=chatgpt.com">Echo Blog</a>)</li>
</ul>
<ol start="3">
<li>子密钥生成（密钥调度）</li>
</ol>
<ul>
<li>对主密钥执行「选择置换 PC-1」从64 位中选出56 位。 (<a href="https://www.ruanx.net/des/?utm_source=chatgpt.com">Pion1eer</a>)</li>
<li>将56 位分为两个28 位半密钥，分别左旋移位（每轮移位量由轮次决定）。 (<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96?utm_source=chatgpt.com">维基百科</a>)</li>
<li>再通过「选择置换 PC-2」从移位后的56 位中选出48 位，作为第1轮子密钥 K₁。重复共生成16 个子密钥 K₁…K₁₆。 (<a href="https://www.ruanx.net/des/?utm_source=chatgpt.com">Pion1eer</a>)</li>
</ul>
<ol start="4">
<li>16 轮 Feistel 结构迭代</li>
</ol>
<p>对于 i &#x3D; 1 到 16 轮，进行以下操作：</p>
<ul>
<li>$L_{i}$&#x3D; $R_{i - 1}$</li>
<li>$R_{i}$ &#x3D; $L_{i - 1} \bigoplus f(R_{i - 1}, K_{i}) $ (<a href="https://houbb.github.io/2020/06/17/althgorim-cryptograph-05-des?utm_source=chatgpt.com">Echo Blog1</a>)<br>   其中 f 函数包含：<ol>
<li>扩展置换 E：将32 位 $R_{i - 1}$ 扩展至48 位。 (<a href="https://www.cnblogs.com/idreamo/p/9333753.html?utm_source=chatgpt.com">cnblogs.com</a>)</li>
<li>与子密钥 Kᵢ 做 XOR。 (<a href="https://zhuanlan.zhihu.com/p/650839499?utm_source=chatgpt.com">知乎专栏</a>)</li>
<li>分为8块，每块6 位，输入各自 S‐盒，输出4 位。总输出32 位。 (<a href="https://www.ruanx.net/des/?utm_source=chatgpt.com">Pion1eer</a>)</li>
<li>最后通过固定 P 置换将32 位再重排。 (<a href="https://houbb.github.io/2020/06/17/althgorim-cryptograph-05-des?utm_source=chatgpt.com">Echo Blog</a>)</li>
</ol>
</li>
</ul>
<ol start="5">
<li>轮结束后的交换与末置换</li>
</ol>
<ul>
<li>完成第16轮后，将 L₁₆ 和 R₁₆ 交换，得到新 L₁₇ &#x3D; R₁₆， R₁₇ &#x3D; L₁₆。 (<a href="https://houbb.github.io/2020/06/17/althgorim-cryptograph-05-des?utm_source=chatgpt.com">Echo Blog</a>)</li>
<li>将 L₁₇ ∥ R₁₇ （合并成64 位）输入「最终置换 FP （IP⁻¹）」进行重排，输出密文。 (<a href="https://www.cnblogs.com/luogi/p/15508933.html?utm_source=chatgpt.com">cnblogs.com</a>)</li>
</ul>
<ol start="6">
<li>解密流程</li>
</ol>
<ul>
<li>解密时流程与加密相同，但子密钥的使用顺序为 K₁₆ → K₁₅ → … → K₁；其余步骤一致。 (<a href="https://www.cnblogs.com/idreamo/p/9333753.html?utm_source=chatgpt.com">cnblogs.com</a>)</li>
</ul>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>只接受16进制的16位密钥输出和16进制的16位明文输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">Key0</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; LS = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">			EX_K1 = &#123;<span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,</span><br><span class="line">			   <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>,</span><br><span class="line">			  <span class="number">10</span>,  <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">19</span>, <span class="number">11</span>,  <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>,</span><br><span class="line">			  <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>,</span><br><span class="line">			   <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">			  <span class="number">14</span>,  <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">21</span>, <span class="number">13</span>,  <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>&#125;,</span><br><span class="line">		    EX_K2 = &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>,</span><br><span class="line">			   <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>,  <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>,</span><br><span class="line">			  <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>,  <span class="number">4</span>, <span class="number">26</span>,  <span class="number">8</span>,</span><br><span class="line">			  <span class="number">16</span>,  <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>,  <span class="number">2</span>,</span><br><span class="line">			  <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>,</span><br><span class="line">			  <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>,</span><br><span class="line">			  <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>,</span><br><span class="line">			  <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;,</span><br><span class="line">			IP = &#123; <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>,</span><br><span class="line">			 <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>,</span><br><span class="line">			 <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">			 <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>,</span><br><span class="line">			 <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>,  <span class="number">1</span>,</span><br><span class="line">			 <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">			 <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>,</span><br><span class="line">			 <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span> &#125;,</span><br><span class="line">			IPR = &#123;<span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>,</span><br><span class="line">			  <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>,</span><br><span class="line">			  <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">			  <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>,</span><br><span class="line">			  <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>,</span><br><span class="line">			  <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">			  <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>,</span><br><span class="line">			  <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>,  <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;,</span><br><span class="line">			E = &#123;<span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">				<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,</span><br><span class="line">				<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">			    <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>,</span><br><span class="line">			    <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">			    <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">			    <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">			    <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		    P = &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>,</span><br><span class="line">			    <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>,</span><br><span class="line">				<span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>,</span><br><span class="line">				<span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">				<span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>,</span><br><span class="line">			    <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>,</span><br><span class="line">			    <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>,</span><br><span class="line">			    <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>&#125;;</span><br><span class="line"><span class="type">int</span> SBOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">	&#123;&#123;<span class="number">14</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">0</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">0</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">15</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">13</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">15</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">5</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">0</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">15</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">9</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">10</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">13</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">12</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">7</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">15</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">13</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">14</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">14</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">14</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">11</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">11</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">10</span>,<span class="number">15</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">9</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">6</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">13</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">2</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">6</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">6</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>&#125;&#125;,</span><br><span class="line">	&#123;&#123;<span class="number">13</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">14</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">1</span>,<span class="number">15</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">2</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">7</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;,</span><br><span class="line">	 &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">11</span>&#125;&#125;</span><br><span class="line">&#125;;		 </span><br><span class="line"><span class="function">string <span class="title">EX</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt; &amp; ex)</span> </span>&#123;</span><br><span class="line">	string s2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : ex) s2 += s[x - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">movel</span><span class="params">(string s, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.<span class="built_in">substr</span>(LS[i]) + s.<span class="built_in">substr</span>(<span class="number">0</span>, LS[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_key</span><span class="params">(string key)</span> </span>&#123;</span><br><span class="line">	string key2 = <span class="built_in">EX</span>(key, EX_K1);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">		string l = key2.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">28</span>), r = key2.<span class="built_in">substr</span>(<span class="number">28</span>);</span><br><span class="line">		l = <span class="built_in">movel</span>(l, i);</span><br><span class="line">		r = <span class="built_in">movel</span>(r, i);</span><br><span class="line">		key2 = l + r;</span><br><span class="line">		Key0[i] = <span class="built_in">EX</span>(key2, EX_K2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">XOR</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s1.<span class="built_in">size</span>(); i ++) s += <span class="string">&#x27;0&#x27;</span> + (s1[i] != s2[i]);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">S</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	string s2;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">48</span>; i += <span class="number">6</span>) &#123;</span><br><span class="line">		<span class="type">int</span> x = ((s[i] - <span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">1</span>) + (s[i + <span class="number">5</span>] - <span class="string">&#x27;0&#x27;</span>), y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">4</span>, base = <span class="number">1</span>; j &gt; i; j --, base *= <span class="number">2</span>) y += (s[j] - <span class="string">&#x27;0&#x27;</span>) * base;</span><br><span class="line">		<span class="type">int</span> z = SBOX[i / <span class="number">6</span>][x][y];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">3</span>; j &gt;= <span class="number">0</span>; j --) s2 += <span class="string">&#x27;0&#x27;</span> + ((z &gt;&gt; j) &amp; <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">F</span><span class="params">(string s, string key)</span> </span>&#123;</span><br><span class="line">	s = <span class="built_in">EX</span>(s, E);</span><br><span class="line">	s = <span class="built_in">XOR</span>(s, key);</span><br><span class="line">	s = <span class="built_in">S</span>(s);</span><br><span class="line">	s = <span class="built_in">EX</span>(s, P);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">DES</span><span class="params">(string con, <span class="type">bool</span> f)</span> </span>&#123;</span><br><span class="line">	con = <span class="built_in">EX</span>(con, IP);</span><br><span class="line">	string l0 = con.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">32</span>), r0 = con.<span class="built_in">substr</span>(<span class="number">32</span>), mid;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">		mid = r0;</span><br><span class="line">		<span class="keyword">if</span>(f) r0 = <span class="built_in">XOR</span>(l0, <span class="built_in">F</span>(r0, Key0[i]));</span><br><span class="line">		<span class="keyword">else</span> r0 = <span class="built_in">XOR</span>(l0, <span class="built_in">F</span>(r0, Key0[<span class="number">15</span> - i]));</span><br><span class="line">		l0 = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	con = <span class="built_in">EX</span>(r0 + l0, IPR);</span><br><span class="line">	<span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">H2B</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	string s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	vector&lt;string&gt; base = &#123;<span class="string">&quot;0000&quot;</span>,<span class="string">&quot;0001&quot;</span>,<span class="string">&quot;0010&quot;</span>,<span class="string">&quot;0011&quot;</span>,<span class="string">&quot;0100&quot;</span>,<span class="string">&quot;0101&quot;</span>,<span class="string">&quot;0110&quot;</span>,<span class="string">&quot;0111&quot;</span>,<span class="string">&quot;1000&quot;</span>,<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;1010&quot;</span>,<span class="string">&quot;1011&quot;</span>,<span class="string">&quot;1100&quot;</span>,<span class="string">&quot;1101&quot;</span>,<span class="string">&quot;1110&quot;</span>,<span class="string">&quot;1111&quot;</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;F&#x27;</span>) s2 += base[s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>];</span><br><span class="line">		<span class="keyword">else</span> s2 += base[s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">B2H</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">	string s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (s.<span class="built_in">size</span>() % <span class="number">4</span> != <span class="number">0</span>) s = <span class="string">&quot;0&quot;</span> + s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)s.<span class="built_in">size</span>(); i += <span class="number">4</span>) &#123;</span><br><span class="line">		temp = (s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">8</span> + (s[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">4</span> + (s[i + <span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">2</span> + (s[i + <span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (temp &lt; <span class="number">10</span>) s2 += <span class="string">&#x27;0&#x27;</span> + temp;</span><br><span class="line">		<span class="keyword">else</span> s2 += <span class="string">&#x27;A&#x27;</span> + (temp - <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	string key, con;</span><br><span class="line">	cin &gt;&gt; key &gt;&gt; con;</span><br><span class="line">	string key1 = <span class="built_in">H2B</span>(key), con1 = <span class="built_in">H2B</span>(con);</span><br><span class="line">	<span class="built_in">make_key</span>(key1);</span><br><span class="line">	string mi = <span class="built_in">DES</span>(con1, <span class="number">1</span>);</span><br><span class="line">	string con2 = <span class="built_in">DES</span>(mi, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; key &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;content: &quot;</span> &lt;&lt; con &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;content_key: &quot;</span> &lt;&lt; <span class="built_in">B2H</span>(mi) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;content: &quot;</span> &lt;&lt; <span class="built_in">B2H</span>(con2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std"><a href="#std" class="headerlink" title="std"></a>std</h3><p>示例输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enc</span></span><br><span class="line"><span class="comment">jielycat</span></span><br><span class="line"><span class="comment">Hello! DES!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> u8  = <span class="type">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 常量与置换表 ----</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LS[<span class="number">16</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;; <span class="comment">// 每轮左移位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥置换 PC-1（64-&gt;56，去奇偶校验位）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PC1[<span class="number">56</span>] = &#123;</span><br><span class="line">    <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>,</span><br><span class="line">    <span class="number">14</span>, <span class="number">6</span>, <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 压缩置换 PC-2（56-&gt;48）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> PC2[<span class="number">48</span>] = &#123;</span><br><span class="line">    <span class="number">14</span>, <span class="number">17</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">26</span>, <span class="number">8</span>,</span><br><span class="line">    <span class="number">16</span>, <span class="number">7</span>, <span class="number">27</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">2</span>, <span class="number">41</span>, <span class="number">52</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">45</span>, <span class="number">33</span>, <span class="number">48</span>, <span class="number">44</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">56</span>, <span class="number">34</span>, <span class="number">53</span>, <span class="number">46</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">36</span>, <span class="number">29</span>, <span class="number">32</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始/逆初始置换</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> IP[<span class="number">64</span>] = &#123;</span><br><span class="line">    <span class="number">58</span>, <span class="number">50</span>, <span class="number">42</span>, <span class="number">34</span>, <span class="number">26</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">60</span>, <span class="number">52</span>, <span class="number">44</span>, <span class="number">36</span>, <span class="number">28</span>, <span class="number">20</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">62</span>, <span class="number">54</span>, <span class="number">46</span>, <span class="number">38</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">6</span>,</span><br><span class="line">    <span class="number">64</span>, <span class="number">56</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">32</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">57</span>, <span class="number">49</span>, <span class="number">41</span>, <span class="number">33</span>, <span class="number">25</span>, <span class="number">17</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">59</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">35</span>, <span class="number">27</span>, <span class="number">19</span>, <span class="number">11</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">61</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">37</span>, <span class="number">29</span>, <span class="number">21</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">63</span>, <span class="number">55</span>, <span class="number">47</span>, <span class="number">39</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> FP[<span class="number">64</span>] = &#123;</span><br><span class="line">    <span class="number">40</span>, <span class="number">8</span>, <span class="number">48</span>, <span class="number">16</span>, <span class="number">56</span>, <span class="number">24</span>, <span class="number">64</span>, <span class="number">32</span>, <span class="number">39</span>, <span class="number">7</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">23</span>, <span class="number">63</span>, <span class="number">31</span>, <span class="number">38</span>, <span class="number">6</span>, <span class="number">46</span>, <span class="number">14</span>, <span class="number">54</span>, <span class="number">22</span>, <span class="number">62</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">37</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">53</span>, <span class="number">21</span>, <span class="number">61</span>, <span class="number">29</span>, <span class="number">36</span>, <span class="number">4</span>, <span class="number">44</span>, <span class="number">12</span>, <span class="number">52</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">43</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">19</span>, <span class="number">59</span>, <span class="number">27</span>,</span><br><span class="line">    <span class="number">34</span>, <span class="number">2</span>, <span class="number">42</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">58</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">1</span>, <span class="number">41</span>, <span class="number">9</span>, <span class="number">49</span>, <span class="number">17</span>, <span class="number">57</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E 扩展（32-&gt;48）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> E_tab[<span class="number">48</span>] = &#123;</span><br><span class="line">    <span class="number">32</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,</span><br><span class="line">    <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>,</span><br><span class="line">    <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 置换（F 函数输出置换）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> P_tab[<span class="number">32</span>] = &#123;</span><br><span class="line">    <span class="number">16</span>, <span class="number">7</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">31</span>, <span class="number">10</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">32</span>, <span class="number">27</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">19</span>, <span class="number">13</span>, <span class="number">30</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 个 S 盒</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SBOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</span><br><span class="line">    &#123;&#123;<span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>&#125;,</span><br><span class="line">     &#123;<span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>&#125;,</span><br><span class="line">     &#123;<span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>&#125;,</span><br><span class="line">     &#123;<span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>&#125;,</span><br><span class="line">     &#123;<span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>&#125;,</span><br><span class="line">     &#123;<span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>&#125;,</span><br><span class="line">     &#123;<span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>&#125;,</span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>&#125;,</span><br><span class="line">     &#123;<span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>&#125;,</span><br><span class="line">     &#123;<span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>&#125;,</span><br><span class="line">     &#123;<span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>&#125;,</span><br><span class="line">     &#123;<span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>&#125;,</span><br><span class="line">     &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>&#125;,</span><br><span class="line">     &#123;<span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>&#125;,</span><br><span class="line">     &#123;<span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>&#125;,</span><br><span class="line">     &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>&#125;,</span><br><span class="line">     &#123;<span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>&#125;,</span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>&#125;,</span><br><span class="line">     &#123;<span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>&#125;&#125;,</span><br><span class="line">    &#123;&#123;<span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>&#125;,</span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>&#125;,</span><br><span class="line">     &#123;<span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>&#125;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 通用置换：按表抽取位 ----</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title">permute</span><span class="params">(u64 input, <span class="type">const</span> <span class="type">int</span> (&amp;tbl)[N])</span> </span>&#123;</span><br><span class="line">    u64 out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> src = tbl[i] - <span class="number">1</span>;                     <span class="comment">// 表索引从 1 开始</span></span><br><span class="line">        u64 bit = (input &gt;&gt; (<span class="number">64</span> - <span class="number">1</span> - src)) &amp; <span class="number">1u</span>; <span class="comment">// 统一按 64 位视角取位</span></span><br><span class="line">        out = (out &lt;&lt; <span class="number">1</span>) | bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定输入宽度的置换（E/PC2/P 使用）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title">permute_n</span><span class="params">(u64 input, <span class="type">const</span> <span class="type">int</span> *tbl, <span class="type">int</span> n, <span class="type">int</span> in_width)</span> </span>&#123;</span><br><span class="line">    u64 out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> src = tbl[i] - <span class="number">1</span>;</span><br><span class="line">        u64 bit = (input &gt;&gt; (in_width - <span class="number">1</span> - src)) &amp; <span class="number">1u</span>;</span><br><span class="line">        out = (out &lt;&lt; <span class="number">1</span>) | bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 28 位循环左移（仅低 28 位有效）</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u32 <span class="title">rol28</span><span class="params">(u32 v, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    v &amp;= <span class="number">0x0FFFFFFF</span>u;</span><br><span class="line">    <span class="keyword">return</span> ((v &lt;&lt; r) | (v &gt;&gt; (<span class="number">28</span> - r))) &amp; <span class="number">0x0FFFFFFF</span>u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8 字节大端装载/存储</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title">load64_be</span><span class="params">(<span class="type">const</span> u8 *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((u64)b[<span class="number">0</span>] &lt;&lt; <span class="number">56</span>) | ((u64)b[<span class="number">1</span>] &lt;&lt; <span class="number">48</span>) | ((u64)b[<span class="number">2</span>] &lt;&lt; <span class="number">40</span>) | ((u64)b[<span class="number">3</span>] &lt;&lt; <span class="number">32</span>) |</span><br><span class="line">           ((u64)b[<span class="number">4</span>] &lt;&lt; <span class="number">24</span>) | ((u64)b[<span class="number">5</span>] &lt;&lt; <span class="number">16</span>) | ((u64)b[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | ((u64)b[<span class="number">7</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">store64_be</span><span class="params">(u64 v, u8 *b)</span> </span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = (u8)(v &gt;&gt; <span class="number">56</span>);</span><br><span class="line">    b[<span class="number">1</span>] = (u8)(v &gt;&gt; <span class="number">48</span>);</span><br><span class="line">    b[<span class="number">2</span>] = (u8)(v &gt;&gt; <span class="number">40</span>);</span><br><span class="line">    b[<span class="number">3</span>] = (u8)(v &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    b[<span class="number">4</span>] = (u8)(v &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    b[<span class="number">5</span>] = (u8)(v &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    b[<span class="number">6</span>] = (u8)(v &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    b[<span class="number">7</span>] = (u8)(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 密钥安排：生成 16 轮 48 位子密钥 ----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">des_key_schedule</span><span class="params">(<span class="type">const</span> u8 key8[<span class="number">8</span>], u64 subkey[<span class="number">16</span>])</span> </span>&#123;</span><br><span class="line">    u64 key64 = <span class="built_in">load64_be</span>(key8);              <span class="comment">// 原始 64 位密钥</span></span><br><span class="line">    u64 k56 = <span class="built_in">permute</span>&lt;<span class="number">56</span>&gt;(key64, PC1);        <span class="comment">// PC-1 去校验位</span></span><br><span class="line">    u32 C = (u32)((k56 &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0x0FFFFFFF</span>u); <span class="comment">// 左 28 位</span></span><br><span class="line">    u32 D = (u32)(k56 &amp; <span class="number">0x0FFFFFFF</span>u);         <span class="comment">// 右 28 位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">16</span>; ++r) &#123;</span><br><span class="line">        C = <span class="built_in">rol28</span>(C, LS[r]); <span class="comment">// 左移</span></span><br><span class="line">        D = <span class="built_in">rol28</span>(D, LS[r]);</span><br><span class="line">        u64 CD = (((u64)C) &lt;&lt; <span class="number">28</span>) | (u64)D;   <span class="comment">// 合并 56 位</span></span><br><span class="line">        u64 k48 = <span class="built_in">permute_n</span>(CD, PC2, <span class="number">48</span>, <span class="number">56</span>); <span class="comment">// 压缩到 48 位</span></span><br><span class="line">        subkey[r] = k48;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 轮函数 F(R, K) ----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u32 <span class="title">des_f</span><span class="params">(u32 R, u64 k48)</span> </span>&#123;</span><br><span class="line">    u64 ER = <span class="built_in">permute_n</span>((u64)R, E_tab, <span class="number">48</span>, <span class="number">32</span>); <span class="comment">// 扩展 32-&gt;48</span></span><br><span class="line">    u64 x  = ER ^ k48;                         <span class="comment">// 与子密钥异或</span></span><br><span class="line">    u32 out32 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123; <span class="comment">// 8 个 S 盒</span></span><br><span class="line">        <span class="type">int</span> shift = <span class="number">42</span> - <span class="number">6</span> * i;</span><br><span class="line">        u8 six = (u8)((x &gt;&gt; shift) &amp; <span class="number">0x3F</span>u);</span><br><span class="line">        <span class="type">int</span> row = ((six &amp; <span class="number">0x20</span>) &gt;&gt; <span class="number">4</span>) | (six &amp; <span class="number">0x01</span>);</span><br><span class="line">        <span class="type">int</span> col = (six &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x0F</span>;</span><br><span class="line">        u8 s = (u8)SBOX[i][row][col];</span><br><span class="line">        out32 = (out32 &lt;&lt; <span class="number">4</span>) | s;</span><br><span class="line">    &#125;</span><br><span class="line">    u64 Pout = <span class="built_in">permute_n</span>((u64)out32, P_tab, <span class="number">32</span>, <span class="number">32</span>); <span class="comment">// P 置换</span></span><br><span class="line">    <span class="keyword">return</span> (u32)Pout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 单块加密（ECB 基元）----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">des_encrypt_block</span><span class="params">(<span class="type">const</span> u8 in[<span class="number">8</span>], u8 out[<span class="number">8</span>], <span class="type">const</span> u64 subkey[<span class="number">16</span>])</span> </span>&#123;</span><br><span class="line">    u64 B   = <span class="built_in">load64_be</span>(in);</span><br><span class="line">    u64 IPB = <span class="built_in">permute</span>&lt;<span class="number">64</span>&gt;(B, IP);           <span class="comment">// 初始置换</span></span><br><span class="line">    u32 L   = (u32)(IPB &gt;&gt; <span class="number">32</span>), R = (u32)IPB; <span class="comment">// 拆成 L/R</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; <span class="number">16</span>; ++r) &#123; <span class="comment">// 16 轮 Feistel</span></span><br><span class="line">        u32 f    = <span class="built_in">des_f</span>(R, subkey[r]);</span><br><span class="line">        u32 newL = R;</span><br><span class="line">        u32 newR = L ^ f;</span><br><span class="line">        L = newL;</span><br><span class="line">        R = newR;</span><br><span class="line">    &#125;</span><br><span class="line">    u64 preout = (((u64)R) &lt;&lt; <span class="number">32</span>) | L; <span class="comment">// 交换 L/R</span></span><br><span class="line">    u64 C      = <span class="built_in">permute</span>&lt;<span class="number">64</span>&gt;(preout, FP);   <span class="comment">// 逆初始置换</span></span><br><span class="line">    <span class="built_in">store64_be</span>(C, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 单块解密（子密钥逆序）----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">des_decrypt_block</span><span class="params">(<span class="type">const</span> u8 in[<span class="number">8</span>], u8 out[<span class="number">8</span>], <span class="type">const</span> u64 subkey[<span class="number">16</span>])</span> </span>&#123;</span><br><span class="line">    u64 rev[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">        rev[i] = subkey[<span class="number">15</span> - i]; <span class="comment">// 反向子密钥</span></span><br><span class="line">    <span class="built_in">des_encrypt_block</span>(in, out, rev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- PKCS#7 填充/去填充 ----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> vector&lt;u8&gt; <span class="title">pkcs7_pad_vec</span><span class="params">(<span class="type">const</span> vector&lt;u8&gt; &amp;data, <span class="type">size_t</span> block = <span class="number">8</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> n   = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> pad = block - (n % block);</span><br><span class="line">    <span class="keyword">if</span> (pad == <span class="number">0</span>) pad = block;</span><br><span class="line">    vector&lt;u8&gt; out;</span><br><span class="line">    out.<span class="built_in">reserve</span>(n + pad);</span><br><span class="line">    out.<span class="built_in">insert</span>(out.<span class="built_in">end</span>(), data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>());</span><br><span class="line">    out.<span class="built_in">insert</span>(out.<span class="built_in">end</span>(), pad, (u8)pad);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pkcs7_unpad_inplace</span><span class="params">(vector&lt;u8&gt; &amp;buf, <span class="type">size_t</span> block = <span class="number">8</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf.<span class="built_in">empty</span>() || (buf.<span class="built_in">size</span>() % block) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    u8 p = buf.<span class="built_in">back</span>();</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span> || p &gt; block || p &gt; buf.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">        <span class="keyword">if</span> (buf[buf.<span class="built_in">size</span>() - <span class="number">1</span> - i] != p)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    buf.<span class="built_in">resize</span>(buf.<span class="built_in">size</span>() - p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- ECB 模式（演示用，不安全）----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> vector&lt;u8&gt; <span class="title">des_ecb_encrypt_vec</span><span class="params">(<span class="type">const</span> vector&lt;u8&gt; &amp;plain, <span class="type">const</span> u8 key8[<span class="number">8</span>])</span> </span>&#123;</span><br><span class="line">    u64 subkey[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">des_key_schedule</span>(key8, subkey);</span><br><span class="line">    vector&lt;u8&gt; in  = <span class="built_in">pkcs7_pad_vec</span>(plain, <span class="number">8</span>);</span><br><span class="line">    <span class="function">vector&lt;u8&gt; <span class="title">out</span><span class="params">(in.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; in.<span class="built_in">size</span>(); i += <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">des_encrypt_block</span>(&amp;in[i], &amp;out[i], subkey);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">des_ecb_decrypt_vec</span><span class="params">(<span class="type">const</span> vector&lt;u8&gt; &amp;cipher, <span class="type">const</span> u8 key8[<span class="number">8</span>], vector&lt;u8&gt; &amp;plain_out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cipher.<span class="built_in">size</span>() % <span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    u64 subkey[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">des_key_schedule</span>(key8, subkey);</span><br><span class="line">    plain_out.<span class="built_in">assign</span>(cipher.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; cipher.<span class="built_in">size</span>(); i += <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">des_decrypt_block</span>(&amp;cipher[i], &amp;plain_out[i], subkey);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pkcs7_unpad_inplace</span>(plain_out, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- hex 编解码（调试可用）----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> string <span class="title">to_hex</span><span class="params">(<span class="type">const</span> vector&lt;u8&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *H = <span class="string">&quot;0123456789abcdef&quot;</span>;</span><br><span class="line">    string s;</span><br><span class="line">    s.<span class="built_in">resize</span>(v.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        u8 b = v[i];</span><br><span class="line">        s[<span class="number">2</span> * i]     = H[b &gt;&gt; <span class="number">4</span>];</span><br><span class="line">        s[<span class="number">2</span> * i + <span class="number">1</span>] = H[b &amp; <span class="number">0xF</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> vector&lt;u8&gt; <span class="title">from_hex</span><span class="params">(<span class="type">const</span> string &amp;h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hexv = [](<span class="type">char</span> c) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;u8&gt; v;</span><br><span class="line">    <span class="keyword">if</span> (h.<span class="built_in">size</span>() % <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    v.<span class="built_in">resize</span>(h.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> hi = <span class="built_in">hexv</span>(h[<span class="number">2</span> * i]), lo = <span class="built_in">hexv</span>(h[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (hi &lt; <span class="number">0</span> || lo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            v.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        v[i] = (u8)((hi &lt;&lt; <span class="number">4</span>) | lo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 输入读取：支持 @path 文件或直接 stdin ----</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_space_le</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c) &lt;= <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;u8&gt; <span class="title">get_plain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">all</span><span class="params">((istreambuf_iterator&lt;<span class="type">char</span>&gt;(cin)), istreambuf_iterator&lt;<span class="type">char</span>&gt;())</span></span>;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; all.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">is_space_le</span>(all[i]))</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; all.<span class="built_in">size</span>() &amp;&amp; all[i] == <span class="string">&#x27;@&#x27;</span>) &#123; <span class="comment">// @ 路径读取文件</span></span><br><span class="line">        <span class="type">size_t</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; all.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">is_space_le</span>(all[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="type">size_t</span> k = all.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j &amp;&amp; <span class="built_in">is_space_le</span>(all[k - <span class="number">1</span>]))</span><br><span class="line">            --k;</span><br><span class="line">        string path = all.<span class="built_in">substr</span>(j, k - j);</span><br><span class="line">        FILE *fp = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        <span class="type">long</span> n = <span class="built_in">ftell</span>(fp);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="function">vector&lt;u8&gt; <span class="title">buf</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">size_t</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fread</span>(buf.<span class="built_in">data</span>(), <span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(n), fp);</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;u8&gt;(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>()); <span class="comment">// 直接返回全部字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一行：模式</span></span><br><span class="line">    string mode;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getline</span>(cin, mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二行：密钥(8 chars)</span></span><br><span class="line">    string key_in;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">getline</span>(cin, key_in))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (key_in.<span class="built_in">size</span>() &lt; <span class="number">8</span>)</span><br><span class="line">        key_in.<span class="built_in">append</span>(<span class="number">8</span> - key_in.<span class="built_in">size</span>(), <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (key_in.<span class="built_in">size</span>() &gt; <span class="number">8</span>)</span><br><span class="line">        key_in.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br><span class="line">    u8 key8[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        key8[i] = (u8)key_in[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="string">&quot;enc&quot;</span> || mode == <span class="string">&quot;ENC&quot;</span> || mode == <span class="string">&quot;Enc&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 加密模式：读取后续所有数据为明文</span></span><br><span class="line">        vector&lt;u8&gt; plain  = <span class="built_in">get_plain</span>();</span><br><span class="line">        vector&lt;u8&gt; cipher = <span class="built_in">des_ecb_encrypt_vec</span>(plain, key8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出：十六进制密文 + 还原明文（和你原来类似的演示）</span></span><br><span class="line">        vector&lt;u8&gt; plain2;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="built_in">des_ecb_decrypt_vec</span>(cipher, key8, plain2);</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;unpad failed\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">to_hex</span>(cipher) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)plain2.<span class="built_in">data</span>(), (streamsize)plain2.<span class="built_in">size</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">&quot;dec&quot;</span> || mode == <span class="string">&quot;DEC&quot;</span> || mode == <span class="string">&quot;Dec&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 解密模式：第三行读取十六进制密文</span></span><br><span class="line">        string cipher_hex;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">getline</span>(cin, cipher_hex)) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;no ciphertext\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;u8&gt; cipher = <span class="built_in">from_hex</span>(cipher_hex);</span><br><span class="line">        <span class="keyword">if</span> (cipher_hex.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; cipher.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;invalid hex ciphertext\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;u8&gt; plain;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="built_in">des_ecb_decrypt_vec</span>(cipher, key8, plain);</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;decrypt or unpad failed\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只输出明文</span></span><br><span class="line">        cout.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)plain.<span class="built_in">data</span>(), (streamsize)plain.<span class="built_in">size</span>());</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;unknown mode, use enc/dec\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DEA"><a href="#DEA" class="headerlink" title="DEA"></a>DEA</h2><p>下面是 IDEA（International Data Encryption Algorithm）算法流程的</p>
<p>基本参数</p>
<ul>
<li>分组长度：64 位。 (<a href="https://www.geeksforgeeks.org/simplified-international-data-encryption-algorithm-idea/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</li>
<li>密钥长度：128 位。 (<a href="https://www.geeksforgeeks.org/simplified-international-data-encryption-algorithm-idea/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</li>
<li>轮数结构：8 个全轮 + 半轮（输出变换）。 (<a href="https://de.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<p>关键操作（在每轮中使用的运算）</p>
<p>在 IDEA 中，每轮对数据块使用以下三种不同代数群的运算，以增强安全性：</p>
<ol>
<li><strong>异或 (XOR)</strong> 运算。 (<a href="https://pt.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
<li><strong>模 2¹⁶ 加法</strong>（即以 2¹⁶ 为模的加法运算）。 (<a href="https://de.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
<li><strong>模 (2¹⁶ + 1) 乘法</strong>（并且将值 0x0000 视作 2¹⁶ ）。 (<a href="https://pt.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
</ol>
<p>子密钥生成 (Key Schedule)</p>
<ul>
<li>从 128 位主密钥中，提取出若干 16 位子密钥。 (<a href="https://de.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
<li>每轮使用 6 个 16 位子密钥；输出半轮使用 4 个 16 位子密钥。 总计 52 个子密钥。 (<a href="https://www.rroij.com/open-access/international-data-encryption-algorithm-idea-a-typical-illustration.php?aid=37580&utm_source=chatgpt.com">国际期刊研究与评论</a>)</li>
<li>每次提取子密钥后，对主密钥执行左旋 25 位，然后继续提取。 (<a href="https://it.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<p>加密流程（每个分组处理流程）</p>
<ol>
<li>将 64 位明文分为四个 16 位子块：X₁, X₂, X₃, X₄。</li>
<li>对于 i &#x3D; 1 到 8 轮（每轮过程如下）：<ul>
<li>使用本轮的 6 个子密钥分别对 X₁–X₄ 进行模 2¹⁶ 加／模 (2¹⁶+1) 乘／XOR 等操作（具体组合见原文）。</li>
<li>然后对中间结果做混合（例如两个子块之间做 XOR），再继续对其中两个子块做模 2¹⁶ 加／模 (2¹⁶+1) 乘。</li>
<li>轮结束后，将四个子块位置进行某种置换（交换 X₂与 X₃）或重组，为下一轮输入。</li>
</ul>
</li>
<li>经过 8 次上述全轮后，再执行一个“半轮”输出变换（使用 4 个子密钥，对四个16 位子块作最后的模运算和异或）。</li>
<li>最终将四个 16 位子块合并为 64 位密文。</li>
</ol>
<p>解密流程</p>
<ul>
<li>解密流程与加密流程结构相同，但子密钥使用顺序为反向（而且在乘法／加法运算中使用相应的逆元素或逆运算）。 (<a href="https://www.rroij.com/open-access/international-data-encryption-algorithm-idea-a-typical-illustration.php?aid=37580&utm_source=chatgpt.com">国际期刊研究与评论</a>)</li>
</ul>
<p>特点 &amp; 安全性</p>
<ul>
<li>IDEA 通过“混合”三类不同代数运算（加、乘、XOR）增强了抗差分／线性分析的能力。 (<a href="https://pt.wikipedia.org/wiki/International_Data_Encryption_Algorithm?utm_source=chatgpt.com">维基百科</a>)</li>
<li>虽然 密钥空间达到 2¹²⁸ ，但随着时间推进，它在效率和标准化方面逐渐被新算法（如 AES）取代。 (<a href="https://nordvpn.com/blog/idea-encryption/?utm_source=chatgpt.com">NordVPN</a>)</li>
</ul>
<h3 id="std-1"><a href="#std-1" class="headerlink" title="std"></a>std</h3><p>示例输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jielycatjielycat</span></span><br><span class="line"><span class="comment">Hello! IDEA!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">using</span> u8 = <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">using</span> u16 = <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> ll ADD_MOD = <span class="number">65536LL</span>;</span><br><span class="line"><span class="keyword">constexpr</span> ll MUL_MOD = <span class="number">65537LL</span>;</span><br><span class="line"></span><br><span class="line">u16 key[<span class="number">60</span>];</span><br><span class="line">u16 key2[<span class="number">60</span>];</span><br><span class="line">string my_key_bin_str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u16 <span class="title">add</span><span class="params">(u16 a, u16 b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u16 <span class="title">mul</span><span class="params">(u16 a, u16 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u64 a1 = (a == <span class="number">0</span>) ? ADD_MOD : a;</span><br><span class="line">    u64 b1 = (b == <span class="number">0</span>) ? ADD_MOD : b;</span><br><span class="line">    u64 res = (a1 * b1) % MUL_MOD;</span><br><span class="line">    <span class="keyword">return</span> (res == ADD_MOD) ? <span class="number">0</span> : <span class="built_in">static_cast</span>&lt;u16&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> u16 <span class="title">yihuo</span><span class="params">(u16 a, u16 b)</span> </span>&#123; <span class="keyword">return</span> a ^ b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u16 <span class="title">bin_str_to_u16</span><span class="params">(string_view s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u16 res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">        res = (res &lt;&lt; <span class="number">1</span>) | (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 128比特循环左移25位</span></span><br><span class="line"><span class="function">string <span class="title">roll_left</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="number">128</span>, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">        s[i] = t[(i + <span class="number">25</span>) % <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成52个子密钥</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(string t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k_idx = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">16</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">32</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">48</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">64</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">80</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">96</span>, <span class="number">16</span>));</span><br><span class="line">        key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">112</span>, <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">0</span>, <span class="number">16</span>));</span><br><span class="line">    key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">16</span>, <span class="number">16</span>));</span><br><span class="line">    key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">32</span>, <span class="number">16</span>));</span><br><span class="line">    key[k_idx++] = <span class="built_in">bin_str_to_u16</span>(<span class="built_in">string_view</span>(t.<span class="built_in">c_str</span>() + <span class="number">48</span>, <span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;d, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        d = a;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exgcd</span>(b, a % b, d, y, x);</span><br><span class="line">        y -= x * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u16 <span class="title">inv</span><span class="params">(u16 a_u16, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll a = (a_u16 == <span class="number">0</span>) ? ADD_MOD : a_u16;</span><br><span class="line">    ll d, x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, d, x, y);</span><br><span class="line">    ll res = (d == <span class="number">1</span>) ? (x % p + p) % p : <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (res == ADD_MOD) ? <span class="number">0</span> : <span class="built_in">static_cast</span>&lt;u16&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">u16 <span class="title">add_ni</span><span class="params">(u16 a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll b = -<span class="built_in">static_cast</span>&lt;ll&gt;(a);</span><br><span class="line">    b = (b % p + p) % p;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;u16&gt;(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成解密子密钥</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dkey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="number">6</span> * (<span class="number">10</span> - i - <span class="number">1</span>) + j;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span> || j == <span class="number">4</span>)</span><br><span class="line">                key2[(i - <span class="number">1</span>) * <span class="number">6</span> + j] = <span class="built_in">inv</span>(key[t], MUL_MOD);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">9</span>)</span><br><span class="line">                    key2[(i - <span class="number">1</span>) * <span class="number">6</span> + j] = <span class="built_in">add_ni</span>(key[t], ADD_MOD);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">2</span>)</span><br><span class="line">                        key2[(i - <span class="number">1</span>) * <span class="number">6</span> + j] = <span class="built_in">add_ni</span>(key[t + <span class="number">1</span>], ADD_MOD);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        key2[(i - <span class="number">1</span>) * <span class="number">6</span> + j] = <span class="built_in">add_ni</span>(key[t - <span class="number">1</span>], ADD_MOD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        key2[(i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">5</span>] = key[(<span class="number">9</span> - i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">5</span>];</span><br><span class="line">        key2[(i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">6</span>] = key[(<span class="number">9</span> - i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">6</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDEA_encrypt_block</span><span class="params">(u16 x[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k_idx = (i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">        u16 z1 = key[k_idx++], z2 = key[k_idx++], z3 = key[k_idx++],</span><br><span class="line">            z4 = key[k_idx++], z5 = key[k_idx++], z6 = key[k_idx++];</span><br><span class="line"></span><br><span class="line">        u16 t1 = <span class="built_in">mul</span>(x[<span class="number">0</span>], z1);</span><br><span class="line">        u16 t2 = <span class="built_in">add</span>(x[<span class="number">1</span>], z2);</span><br><span class="line">        u16 t3 = <span class="built_in">add</span>(x[<span class="number">2</span>], z3);</span><br><span class="line">        u16 t4 = <span class="built_in">mul</span>(x[<span class="number">3</span>], z4);</span><br><span class="line">        u16 t5 = <span class="built_in">yihuo</span>(t1, t3);</span><br><span class="line">        u16 t6 = <span class="built_in">yihuo</span>(t2, t4);</span><br><span class="line">        u16 t7 = <span class="built_in">mul</span>(t5, z5);</span><br><span class="line">        u16 t8 = <span class="built_in">add</span>(t6, t7);</span><br><span class="line">        u16 t9 = <span class="built_in">mul</span>(t8, z6);</span><br><span class="line">        u16 t10 = <span class="built_in">add</span>(t7, t9);</span><br><span class="line"></span><br><span class="line">        u16 w1 = <span class="built_in">yihuo</span>(t1, t9);</span><br><span class="line">        u16 w2 = <span class="built_in">yihuo</span>(t3, t9);</span><br><span class="line">        u16 w3 = <span class="built_in">yihuo</span>(t2, t10);</span><br><span class="line">        u16 w4 = <span class="built_in">yihuo</span>(t4, t10);</span><br><span class="line"></span><br><span class="line">        x[<span class="number">0</span>] = w1;</span><br><span class="line">        x[<span class="number">1</span>] = w2;</span><br><span class="line">        x[<span class="number">2</span>] = w3;</span><br><span class="line">        x[<span class="number">3</span>] = w4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u16 y1 = <span class="built_in">mul</span>(x[<span class="number">0</span>], key[<span class="number">49</span>]);</span><br><span class="line">    u16 y2 = <span class="built_in">add</span>(x[<span class="number">2</span>], key[<span class="number">50</span>]);</span><br><span class="line">    u16 y3 = <span class="built_in">add</span>(x[<span class="number">1</span>], key[<span class="number">51</span>]);</span><br><span class="line">    u16 y4 = <span class="built_in">mul</span>(x[<span class="number">3</span>], key[<span class="number">52</span>]);</span><br><span class="line">    x[<span class="number">0</span>] = y1;</span><br><span class="line">    x[<span class="number">1</span>] = y2;</span><br><span class="line">    x[<span class="number">2</span>] = y3;</span><br><span class="line">    x[<span class="number">3</span>] = y4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IDEA_decrypt_block</span><span class="params">(u16 x[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k_idx = (i - <span class="number">1</span>) * <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">        u16 z1 = key2[k_idx++], z2 = key2[k_idx++], z3 = key2[k_idx++],</span><br><span class="line">            z4 = key2[k_idx++], z5 = key2[k_idx++], z6 = key2[k_idx++];</span><br><span class="line"></span><br><span class="line">        u16 t1 = <span class="built_in">mul</span>(x[<span class="number">0</span>], z1);</span><br><span class="line">        u16 t2 = <span class="built_in">add</span>(x[<span class="number">1</span>], z2);</span><br><span class="line">        u16 t3 = <span class="built_in">add</span>(x[<span class="number">2</span>], z3);</span><br><span class="line">        u16 t4 = <span class="built_in">mul</span>(x[<span class="number">3</span>], z4);</span><br><span class="line">        u16 t5 = <span class="built_in">yihuo</span>(t1, t3);</span><br><span class="line">        u16 t6 = <span class="built_in">yihuo</span>(t2, t4);</span><br><span class="line">        u16 t7 = <span class="built_in">mul</span>(t5, z5);</span><br><span class="line">        u16 t8 = <span class="built_in">add</span>(t6, t7);</span><br><span class="line">        u16 t9 = <span class="built_in">mul</span>(t8, z6);</span><br><span class="line">        u16 t10 = <span class="built_in">add</span>(t7, t9);</span><br><span class="line"></span><br><span class="line">        u16 w1 = <span class="built_in">yihuo</span>(t1, t9);</span><br><span class="line">        u16 w2 = <span class="built_in">yihuo</span>(t3, t9);</span><br><span class="line">        u16 w3 = <span class="built_in">yihuo</span>(t2, t10);</span><br><span class="line">        u16 w4 = <span class="built_in">yihuo</span>(t4, t10);</span><br><span class="line"></span><br><span class="line">        x[<span class="number">0</span>] = w1;</span><br><span class="line">        x[<span class="number">1</span>] = w2;</span><br><span class="line">        x[<span class="number">2</span>] = w3;</span><br><span class="line">        x[<span class="number">3</span>] = w4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    u16 y1 = <span class="built_in">mul</span>(x[<span class="number">0</span>], key2[<span class="number">49</span>]);</span><br><span class="line">    u16 y2 = <span class="built_in">add</span>(x[<span class="number">2</span>], key2[<span class="number">50</span>]);</span><br><span class="line">    u16 y3 = <span class="built_in">add</span>(x[<span class="number">1</span>], key2[<span class="number">51</span>]);</span><br><span class="line">    u16 y4 = <span class="built_in">mul</span>(x[<span class="number">3</span>], key2[<span class="number">52</span>]);</span><br><span class="line">    x[<span class="number">0</span>] = y1;</span><br><span class="line">    x[<span class="number">1</span>] = y2;</span><br><span class="line">    x[<span class="number">2</span>] = y3;</span><br><span class="line">    x[<span class="number">3</span>] = y4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节转二进制字符串</span></span><br><span class="line"><span class="function">string <span class="title">B2b</span><span class="params">(vector&lt;<span class="type">char</span>&gt; &amp;block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string out;</span><br><span class="line">    out.<span class="built_in">reserve</span>(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u8 u = <span class="built_in">static_cast</span>&lt;u8&gt;(block[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">7</span>; b &gt;= <span class="number">0</span>; --b)</span><br><span class="line">            out.<span class="built_in">push_back</span>(((u &gt;&gt; b) &amp; <span class="number">1</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取16字节密钥</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">get_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string key;</span><br><span class="line">    <span class="built_in">getline</span>(cin, key);</span><br><span class="line">    <span class="keyword">while</span> (key.<span class="built_in">size</span>() &lt; <span class="number">16</span>)</span><br><span class="line">        key += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (key.<span class="built_in">size</span>() &gt; <span class="number">16</span>)</span><br><span class="line">        key.<span class="built_in">resize</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_space_le</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;(c) &lt;= <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取明文</span></span><br><span class="line"><span class="function">vector&lt;u8&gt; <span class="title">get_plain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">all</span><span class="params">((istreambuf_iterator&lt;<span class="type">char</span>&gt;(cin)), (istreambuf_iterator&lt;<span class="type">char</span>&gt;()))</span></span>;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; all.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">is_space_le</span>(all[i]))</span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; all.<span class="built_in">size</span>() &amp;&amp; all[i] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; all.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">is_space_le</span>(all[j]))</span><br><span class="line">            ++j;</span><br><span class="line">        <span class="type">size_t</span> k = all.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (k &gt; j &amp;&amp; <span class="built_in">is_space_le</span>(all[k - <span class="number">1</span>]))</span><br><span class="line">            --k;</span><br><span class="line">        string path = all.<span class="built_in">substr</span>(j, k - j);</span><br><span class="line">        FILE *fp = <span class="built_in">fopen</span>(path.<span class="built_in">c_str</span>(), <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">        <span class="type">long</span> n = <span class="built_in">ftell</span>(fp);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">        <span class="function">vector&lt;u8&gt; <span class="title">buf</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">size_t</span>&gt;(n))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fread</span>(buf.<span class="built_in">data</span>(), <span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(n), fp);</span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">vector</span>&lt;u8&gt;(all.<span class="built_in">begin</span>(), all.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; key0 = <span class="built_in">get_key</span>();</span><br><span class="line">    my_key_bin_str = <span class="built_in">B2b</span>(key0);</span><br><span class="line">    <span class="built_in">extend</span>(my_key_bin_str);</span><br><span class="line">    <span class="built_in">dkey</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;u8&gt; plain = <span class="built_in">get_plain</span>();</span><br><span class="line">    <span class="type">size_t</span> original_len = plain.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">size_t</span> padding = (<span class="number">8</span> - (original_len % <span class="number">8</span>)) % <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; padding; ++i)</span><br><span class="line">        plain.<span class="built_in">push_back</span>(padding);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> num_blocks = plain.<span class="built_in">size</span>() / <span class="number">8</span>;</span><br><span class="line">    <span class="function">vector&lt;u8&gt; <span class="title">encrypted_bytes</span><span class="params">(plain.size())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;u8&gt; <span class="title">decrypted_bytes</span><span class="params">(plain.size())</span></span>;</span><br><span class="line">    u16 x[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_blocks; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u8 *p_in = plain.<span class="built_in">data</span>() + i * <span class="number">8</span>;</span><br><span class="line">        x[<span class="number">0</span>] = (p_in[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">1</span>];</span><br><span class="line">        x[<span class="number">1</span>] = (p_in[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">3</span>];</span><br><span class="line">        x[<span class="number">2</span>] = (p_in[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">5</span>];</span><br><span class="line">        x[<span class="number">3</span>] = (p_in[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">7</span>];</span><br><span class="line">        <span class="built_in">IDEA_encrypt_block</span>(x);</span><br><span class="line">        u8 *p_out = encrypted_bytes.<span class="built_in">data</span>() + i * <span class="number">8</span>;</span><br><span class="line">        p_out[<span class="number">0</span>] = (x[<span class="number">0</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">1</span>] = (x[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">2</span>] = (x[<span class="number">1</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">3</span>] = (x[<span class="number">1</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">4</span>] = (x[<span class="number">2</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">5</span>] = (x[<span class="number">2</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">6</span>] = (x[<span class="number">3</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">7</span>] = (x[<span class="number">3</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_blocks; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u8 *p_in = encrypted_bytes.<span class="built_in">data</span>() + i * <span class="number">8</span>;</span><br><span class="line">        x[<span class="number">0</span>] = (p_in[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">1</span>];</span><br><span class="line">        x[<span class="number">1</span>] = (p_in[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">3</span>];</span><br><span class="line">        x[<span class="number">2</span>] = (p_in[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">5</span>];</span><br><span class="line">        x[<span class="number">3</span>] = (p_in[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | p_in[<span class="number">7</span>];</span><br><span class="line">        <span class="built_in">IDEA_decrypt_block</span>(x);</span><br><span class="line">        u8 *p_out = decrypted_bytes.<span class="built_in">data</span>() + i * <span class="number">8</span>;</span><br><span class="line">        p_out[<span class="number">0</span>] = (x[<span class="number">0</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">1</span>] = (x[<span class="number">0</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">2</span>] = (x[<span class="number">1</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">3</span>] = (x[<span class="number">1</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">4</span>] = (x[<span class="number">2</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">5</span>] = (x[<span class="number">2</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">        p_out[<span class="number">6</span>] = (x[<span class="number">3</span>] &gt;&gt; <span class="number">8</span>);</span><br><span class="line">        p_out[<span class="number">7</span>] = (x[<span class="number">3</span>] &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;明文：&quot; &lt;&lt; string(plain.begin(), plain.begin() + original_len) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;密文 (hex)：&quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; hex &lt;&lt; setfill(&#x27;0&#x27;);</span></span><br><span class="line">    <span class="comment">// for (size_t i = 0; i &lt; encrypted_bytes.size(); ++i)</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; setw(2) &lt;&lt; static_cast&lt;int&gt;(encrypted_bytes[i]);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; dec &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// string mingwen1(decrypted_bytes.begin(), decrypted_bytes.begin() + original_len);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;解密后的明文：&quot; &lt;&lt; mingwen1 &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/qq_40279192/article/details/107292156?ops_request_misc=%257B%2522request%255Fid%2522%253A%252249495e8167f16de5ceab5baf35f292c3%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=49495e8167f16de5ceab5baf35f292c3&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-107292156-null-null.nonecase&utm_term=DES&spm=1018.2226.3001.4450">DES_CSDN</a>.</p>
<p><a href="https://blog.csdn.net/qq_40279192/article/details/107420773?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226497a398d2e1887824cd06b0f7fd5bf2%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=6497a398d2e1887824cd06b0f7fd5bf2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-107420773-null-null.nonecase&utm_term=IDEA&spm=1018.2226.3001.4450">IDEA_CSDN</a>.</p>
<p><a href="https://github.com/xiaojinwayawa/IDEA#">IDEA_GitHub</a>.</p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Git_for_Android-Studio</title>
    <url>/Git-for-Android-Studio.html</url>
    <content><![CDATA[<!--more-->
<h1 id="熟悉Git"><a href="#熟悉Git" class="headerlink" title="熟悉Git"></a>熟悉Git</h1><p><code>Git</code>是当今最广泛应用且功能强大、灵活的分布式版本控制系统。它的最大优势在于每位开发者本地均拥有完整的版本历史，即使在脱机状态下也能完成大部分操作，这使得多人协作和代码合并变得更加高效和便捷。相比之下，集中式版本控制系统依赖中央服务器，容易受到单点故障的影响。虽然在管理大型二进制文件或某些特殊场景下可能需要辅以其他工具，但 Git 的这些显著优势正是我们学习和使用它的重要原因。</p>
<!--more-->

<h1 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h1><p>先下载Git，之后的命令可以在任何bash中运行</p>
<p><code>Github</code>基于web的版本控制界面，也就是可以在上面部署项目，是使用<code>git</code>的一大利器，我们要把<code>Android Studio</code>上的项目进行<code>git</code>管理，首先需要创建一个<code>Github</code>账号（能进行版本控制的不止有<code>Github</code>, 还有<code>Gitee</code>等等）。</p>
<p>进行git账号的配置，以告诉<code>git</code>是谁在对<code>git</code>进行操作以及以后<code>git</code>的操作对象。</p>
<p>以下两条指令的参数填之前在<code>Github</code>注册的账号信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// --global 参数表示该配置为全局配置，适用于该用户的所有 Git 仓库</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>以下两条指令用于查询当前<code>git</code>绑定的账号信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p>确认无误之后就进行绑定的最后一步，创建<code>SSH</code>连接，方便本地<code>git</code>能直接对接到<code>Github</code>以进行操作</p>
<p>在本地生成密钥和公钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure>

<p>获取生成的公钥（<code>id_rsa.pub</code>）后在<code>Github</code>上创建<code>SSHKey</code>（不太熟悉的可以在网上搜<code>Github SSH配置</code>, 也可以直接看我找好的教程 <a href="https://blog.csdn.net/weixin_42310154/article/details/118340458">配置SSH教程</a>， 会了一次之后就熟悉了）</p>
<p>验证是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>



<p>准备工作全部完整，接下来几条简单就令就能轻松完成项目和仓库的绑定</p>
<p>从现在开始的指令在Android Studio中的终端运行<img src="/Git-for-Android-Studio/git1.png" alt="git1"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>在<code>Github</code>中创建一个仓库（<code>repository</code>），命名随意，复制其SSH（注意与之前的SSH做区分）</p>
<p>添加远程库（也就是将这个新创建的仓库作为<code>git</code>版本管理的存储库）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;刚才让复制的SSH&gt;</span><br></pre></td></tr></table></figure>

<p>推送前先将更改（部署<code>git</code>前的所有代码）添加到暂存区并且提交更改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#x27;init git for Android Studio&#x27;</span><br></pre></td></tr></table></figure>

<p>然后进行第一次推送</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>之后每次进行修改后运行<code>git push</code>即可完成推送</p>
<p>现在可去刚刚创建的仓库里看看是否有一堆文件上传了，这些文件就是一个版本，之后的每次push都会产生一个新版本，版本可以进行各种操作，如分支管理、版本回退、合并等。</p>
<h1 id="管理Git"><a href="#管理Git" class="headerlink" title="管理Git"></a>管理Git</h1><p>之后正常的版本管理就非常轻松了，<code>git</code>是用来方便管理的，没有那么复杂，是一个非常好用的工具，因此需要掌握一些常见的指令和原理。</p>
<p>可参见大佬的博客<a href="https://liaoxuefeng.com/books/git/introduction/index.html">廖雪峰</a>和我做的一些速记<a href="https://baoziwan.icu/learngit.html">小站</a></p>
<p>最后，给该项目创建一个<code>README</code>文件，用于介绍这个项目或者说仓库</p>
<p>可直接在<code>Github</code>的仓库下点击<code>Add a README</code>快速创建，也可在本地创建一个<code>README.md</code>文件后进行编辑再<code>git push</code>上<code>Github</code></p>
<p><img src="/Git-for-Android-Studio/gi2.png" alt="gi2"></p>
<p>结果示例</p>
<p><img src="/Git-for-Android-Studio/git3.png" alt="git3"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liaoxuefeng.com/books/git/introduction/index.html">廖雪峰</a><br><a href="https://blog.csdn.net/weixin_42310154/article/details/118340458">配置SSH教程</a><br><a href="https://baoziwan.icu/learngit.html">自家小站</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel</title>
    <url>/Kernel.html</url>
    <content><![CDATA[<h1 id="更换Kernel"><a href="#更换Kernel" class="headerlink" title="更换Kernel"></a>更换Kernel</h1><p>当boot空间不足时，我们不得不删除多余的备用linux核。</p>
<h2 id="删除多余kernel"><a href="#删除多余kernel" class="headerlink" title="删除多余kernel"></a>删除多余kernel</h2><p>确认当前内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6.12.57+deb13-amd64</span><br></pre></td></tr></table></figure></blockquote>
<p>列出所有已安装的内核包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg --list | grep linux-image</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我的结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ii  linux-image-6.12.48+deb13-amd64                     6.12.48-1                            amd64        Linux 6.12 <span class="keyword">for</span> 64-bit PCs (signed)</span><br><span class="line">ii  linux-image-6.12.57+deb13-amd64                     6.12.57-1                            amd64        Linux 6.12 <span class="keyword">for</span> 64-bit PCs (signed)</span><br><span class="line">ii  linux-image-amd64                                   6.12.57-1                            amd64        Linux <span class="keyword">for</span> 64-bit PCs (meta-package)</span><br></pre></td></tr></table></figure></blockquote>
<p>这个时候我就要删除6.12.48</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt remove linux-image-6.12.48+deb13-amd64 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>补更，当我运行<code>sudo apt remove linux-image-6.12.48+deb13-amd64</code>时发生<strong>报错</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">将要安装的依赖：                               </span><br><span class="line">  linux-image-6.12.48+deb13-amd64-unsigned</span><br><span class="line"></span><br><span class="line">建议安装：</span><br><span class="line">  firmware-linux-free  linux-doc-6.12  debian-kernel-handbook</span><br><span class="line"></span><br><span class="line">【将要卸载】：</span><br><span class="line">  linux-image-6.12.48+deb13-amd64</span><br><span class="line"></span><br><span class="line">摘要：</span><br><span class="line">  升级：0，安装：1，卸载：1，不升级：158</span><br><span class="line">  下载大小：107 MB</span><br><span class="line">  所需的空间：2,048 B / 61.7 GB 可用</span><br><span class="line">  └─ 在 /boot 中：157 MB / 139 MB 可用</span><br><span class="line"></span><br><span class="line">警告： 在 /boot 中，所需的空间超出了可用空间：157 MB &gt; 139 MB，安装可能失败</span><br><span class="line">仍然继续吗？ [y/N] N</span><br><span class="line">中止。</span><br></pre></td></tr></table></figure>

<p>这时我换一个包管理器dpkg，输入指令<code>sudo dpkg -r linux-image-6.12.48+deb13-amd64 </code>，依旧<strong>报错</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg: 依赖问题阻止了卸载 linux-image-6.12.48+deb13-amd64 的操作：</span><br><span class="line"> linux-headers-6.12.48+deb13-amd64 依赖于 linux-image-6.12.48+deb13-amd64 (= 6.12.48-1) | linux-image-6.12.48+deb13-amd64-unsigned (= 6.12.48-1)；然而：</span><br><span class="line">  即将删除 linux-image-6.12.48+deb13-amd64。</span><br><span class="line">  未安装软件包 linux-image-6.12.48+deb13-amd64-unsigned。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 linux-image-6.12.48+deb13-amd64 (--remove)时出错：</span><br><span class="line"> 依赖问题 - 不会执行卸载</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> linux-image-6.12.48+deb13-amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这表明需要先<strong>删除headers</strong>，6.12.48 的 headers 还在，它“抱着” image 不肯放手</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg -r linux-headers-6.12.48+deb13-amd64</span><br><span class="line">sudo dpkg -r linux-image-6.12.48+deb13-amd64</span><br></pre></td></tr></table></figure></blockquote>
<p>清理残留</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt autoremove --purge</span><br></pre></td></tr></table></figure>

<p>检查&#x2F;boot空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h /boot</span><br></pre></td></tr></table></figure>

<h2 id="换核"><a href="#换核" class="headerlink" title="换核"></a>换核</h2><p>直接update+upgrade两件套</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>

<p>下好了新的内核后，记得更新gtub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub2</span><br></pre></td></tr></table></figure>

<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>关于内核删除的顺序，或许应该先删除headers，但是为什么之前我直接删除image时能够正常运行？</p>
<p> 查阅资料后得到一个不确定的答案：只有当 <code>linux-headers-旧版本</code> 不再依赖 <code>linux-image-旧版本</code> 时，才能直接删除 image； 否则，必须先删 headers。</p>
<p>而之前能够直接删除image可能有两种情形：</p>
<ol>
<li>时根本没装对应版本的 <strong>headers</strong></li>
<li>之前更换内核后通过autoremove已经删除了废弃headers</li>
</ol>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux分布式集群</title>
    <url>/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4.html</url>
    <content><![CDATA[<!--more-->

<h1 id="Linux分布式集群搭建"><a href="#Linux分布式集群搭建" class="headerlink" title="Linux分布式集群搭建"></a>Linux分布式集群搭建</h1><p>目前已经完成linxu层面的集群基础（网络&#x2F;主机名&#x2F;SSH&#x2F;时钟&#x2F;统一用户&#x2F;JDK），为后续的Hadoop部署奠定基础。</p>
<p>目前节点：</p>
<ul>
<li><code>debian-master</code>：192.168.122.166 (debian13)</li>
<li><code>debian-slave1</code>：192.168.122.112 (debian13)</li>
</ul>
<p>虚拟化与网络：KVM&#x2F;QEMU，<code>default:NAT(virbr0)</code>,网段<code>192.168.122.0/24</code></p>
<p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/KVM.png"></p>
<h2 id="固定主机名与主机名解析"><a href="#固定主机名与主机名解析" class="headerlink" title="固定主机名与主机名解析"></a>固定主机名与主机名解析</h2><p><code>hostnamectl set-hostname debian-master / debian-slave1</code></p>
<p>两机<code>/etc/hosts</code>相互加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.122.166  debian-master</span><br><span class="line">192.168.122.112  debian-slave1</span><br></pre></td></tr></table></figure>

<p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/slave1.png"></p>
<p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/master.png"></p>
<p>验证<code>ping debian-master / debian-slave1</code>均成功</p>
<h2 id="SSH互信"><a href="#SSH互信" class="headerlink" title="SSH互信"></a>SSH互信</h2><p>在 master 上为登录 slave1 的账户 <strong>jiangshun</strong> 分发密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line">ssh-copy-id jiangshun@debian-slave1</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong>：<code>ssh jiangshun@debian-slave1</code> 成功登录</p>
<blockquote>
<p>当copy失败或ssh登陆失败时，可以试一下调整操作权限</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># master:</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line">chmod 644 ~/.ssh/known_hosts</span><br><span class="line"></span><br><span class="line"># slave:</span><br><span class="line">mkdir -p ~/.ssh</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line">touch ~/.ssh/authorized_keys</span><br><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br><span class="line">chown -R &lt;username&gt;:&lt;username&gt; ~/.ssh</span><br></pre></td></tr></table></figure>


<p>在AI建议下，我统一了集群用户与目录，即两机创建相同运行账户（hadoop）</p>
<p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/hadoop.png"></p>
<h3 id="统一集群后的SSH互信"><a href="#统一集群后的SSH互信" class="headerlink" title="统一集群后的SSH互信"></a>统一集群后的SSH互信</h3><p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/hadoop_ssh.png"></p>
<h2 id="时间同步（chrony）"><a href="#时间同步（chrony）" class="headerlink" title="时间同步（chrony）"></a>时间同步（chrony）</h2><p>Master <code>/etc/chrony/chrony.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow 192.168.122.0/24</span><br><span class="line">local stratum 10</span><br></pre></td></tr></table></figure>

<p>Slave1 <code>/etc/chrony/chrony.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server debian-master iburst</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong>：<code>chronyc sources</code> 可见 <code>debian-master</code> 为时间源，输出显示同步成功</p>
<p><img src="/Linux%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4/time.png"></p>
<h2 id="JDK安装与环境变量"><a href="#JDK安装与环境变量" class="headerlink" title="JDK安装与环境变量"></a>JDK安装与环境变量</h2><p>安装：<code>sudo apt install openjdk-21-jdk</code></p>
<p>两机 <code>hadoop</code> 用户 <code>~/.bashrc</code> 添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-21-openjdk-amd64</span><br><span class="line">export HADOOP_HOME=/opt/hadoop</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export PATH=$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong>：<code>java -version</code>、<code>echo $JAVA_HOME</code> 正常</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何将用户加入sudoers："><a href="#如何将用户加入sudoers：" class="headerlink" title="如何将用户加入sudoers："></a>如何将用户加入sudoers：</h3><blockquote>
<p>先<code>su -</code>进root，再<code>visudo</code>进去，添加<code>Username  ALL=(ALL:ALL) ALL</code></p>
</blockquote>
<h3 id="如何固定IP"><a href="#如何固定IP" class="headerlink" title="如何固定IP"></a>如何固定IP</h3><p>固定IP参考<a href="https://www.cnblogs.com/Ai-Hen-Jiao-zhi/p/11339867.html">博客园</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/Ai-Hen-Jiao-zhi/p/11339867.html">debian固定IP</a></p>
<p><a href="https://www.runoob.com/linux/linux-vim.html">vim进阶指令</a></p>
<p><a href="https://www.debian.org/CD/netinst/">ISO源</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Live盘制作</title>
    <url>/Live%E7%9B%98%E5%88%B6%E4%BD%9C.html</url>
    <content><![CDATA[<h1 id="Live盘制作"><a href="#Live盘制作" class="headerlink" title="Live盘制作"></a>Live盘制作</h1><p>一个带有操作系统的U盘就叫做live盘，此盘可用于修复主机，重装系统等。</p>
<p>其在Linux环境下的制作也是非常简单的，只用两个步骤：</p>
<ul>
<li><p><em>挑选合适的ISO镜像</em></p>
</li>
<li><p><em>将其烧录至U盘</em></p>
</li>
</ul>
<h2 id="ISO镜像"><a href="#ISO镜像" class="headerlink" title="ISO镜像"></a>ISO镜像</h2><p>这里我下载的是<a href="https://www.debian.org/CD/live/">debian-live-13.2.0-amd64-kde.iso</a>，可选择自己喜欢的系统和版本。</p>
<p><a href="%E4%B8%8B%E8%BD%BD%E8%BF%9E%E6%8E%A5">下载连接</a>.</p>
<h2 id="U盘"><a href="#U盘" class="headerlink" title="U盘"></a>U盘</h2><p>准备一个内存大于ISO镜像的U盘，插入电脑。</p>
<blockquote>
<p>⚠️ 操作前请务必确认 <strong>U 盘设备名</strong>，否则会把错误的磁盘覆盖！</p>
</blockquote>
<h3 id="确定U盘设备名"><a href="#确定U盘设备名" class="headerlink" title="确定U盘设备名"></a>确定U盘设备名</h3><p>插入 U 盘后执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<p><img src="/Live%E7%9B%98%E5%88%B6%E4%BD%9C/ISO1.png"></p>
<p>你会看到类似：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda           8:0    1  58.6G  0 disk  # ← 这通常是你的 U 盘</span><br><span class="line">├─sda1        8:1    1   3.9G  0 part </span><br><span class="line">└─sda2        8:2    1   3.2M  0 part </span><br><span class="line">nvme1n1     259:0    0 238.5G  0 disk </span><br><span class="line">├─nvme1n1p1 259:1    0   100M  0 part </span><br><span class="line">├─nvme1n1p2 259:2    0    16M  0 part </span><br><span class="line">├─nvme1n1p3 259:3    0     3G  0 part </span><br><span class="line">├─nvme1n1p4 259:4    0   608M  0 part </span><br><span class="line">├─nvme1n1p5 259:5    0   488M  0 part /boot</span><br><span class="line">└─nvme1n1p6 259:6    0 149.5G  0 part /</span><br><span class="line">nvme0n1     259:7    0 476.9G  0 disk </span><br><span class="line">├─nvme0n1p1 259:8    0   260M  0 part /boot/efi</span><br><span class="line">├─nvme0n1p2 259:9    0    16M  0 part </span><br><span class="line">├─nvme0n1p3 259:10   0   200G  0 part </span><br><span class="line">├─nvme0n1p4 259:11   0 274.7G  0 part </span><br><span class="line">└─nvme0n1p5 259:12   0     2G  0 part</span><br></pre></td></tr></table></figure>

<h3 id="卸载-U-盘分区"><a href="#卸载-U-盘分区" class="headerlink" title="卸载 U 盘分区"></a>卸载 U 盘分区</h3><p>如果系统自动挂载了 U 盘，先卸载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo umount /dev/sda*</span><br></pre></td></tr></table></figure>

<h3 id="使用-dd-烧录"><a href="#使用-dd-烧录" class="headerlink" title="使用 dd 烧录"></a>使用 dd 烧录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dd if=你的镜像.iso of=/dev/sda bs=4M status=progress oflag=sync</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<ul>
<li><code>if=</code> 输入文件（你的 ISO）</li>
<li><code>of=</code> 输出设备（整个磁盘，不要写成 sdb1）</li>
<li><code>bs=4M</code> 加快写入速度</li>
<li><code>status=progress</code> 显示进度</li>
<li><code>oflag=sync</code> 确保数据实时写入</li>
</ul>
<p>烧录完成后即可使用。</p>
<h1 id="Live盘恢复为存储U盘"><a href="#Live盘恢复为存储U盘" class="headerlink" title="Live盘恢复为存储U盘"></a>Live盘恢复为存储U盘</h1><p>假设你的 U 盘是 <code>/dev/sda</code>，请用 <code>lsblk</code> 确认！</p>
<blockquote>
<p> 在取消挂载情景下进行操作。</p>
</blockquote>
<h2 id="清空分区表（恢复为全新裸盘）"><a href="#清空分区表（恢复为全新裸盘）" class="headerlink" title="清空分区表（恢复为全新裸盘）"></a>清空分区表（恢复为全新裸盘）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo wipefs -a /dev/sda</span><br><span class="line">sudo dd if=/dev/zero of=/dev/sda bs=1M count=10</span><br></pre></td></tr></table></figure>

<h2 id="用-fdisk-重建分区"><a href="#用-fdisk-重建分区" class="headerlink" title="用 fdisk 重建分区"></a>用 fdisk 重建分区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo fdisk /dev/sda</span><br></pre></td></tr></table></figure>

<p>进入后按：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g     创建全新的 GPT 分区表</span><br><span class="line">n     创建分区</span><br><span class="line">回车  默认分区号</span><br><span class="line">回车  默认起始</span><br><span class="line">回车  默认结束</span><br><span class="line">w     保存并退出</span><br></pre></td></tr></table></figure>

<h2 id="格式化为-FAT32"><a href="#格式化为-FAT32" class="headerlink" title="格式化为 FAT32"></a>格式化为 FAT32</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkfs.vfat -F 32 /dev/sda1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Live盘</tag>
      </tags>
  </entry>
  <entry>
    <title>TexLive_VScode</title>
    <url>/TexLive-VScode.html</url>
    <content><![CDATA[<h1 id="Texlive-in-Vscode"><a href="#Texlive-in-Vscode" class="headerlink" title="Texlive in Vscode"></a>Texlive in Vscode</h1><h1 id="Texlive"><a href="#Texlive" class="headerlink" title="Texlive"></a>Texlive</h1><p>使用 TeX Live 官方安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zcat &lt; install-tl-unx.tar.gz | sudo tar xf -</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ls的结果<br><strong>install-tl-20251209</strong>  install-tl-unx.tar.gz</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd install-tl-20251209</span><br></pre></td></tr></table></figure></blockquote>
<p>进入解压目录后执行安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo perl ./install-tl --no-interaction</span><br></pre></td></tr></table></figure>

<p>….a few moments later</p>
<p>配置环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># 根据自己的shell来</span></span><br></pre></td></tr></table></figure>

<p>加入以下内容（注意一下年份的匹配）</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LaTeX</span></span><br><span class="line"><span class="built_in">export</span> MANPATH=<span class="variable">$&#123;MANPATH&#125;</span>:/usr/local/texlive/2025/texmf-dist/doc/man</span><br><span class="line"><span class="built_in">export</span> INFOPATH=<span class="variable">$&#123;INFOPATH&#125;</span>:/usr/local/texlive/2025/texmf-dist/doc/info</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/usr/local/texlive/2025/bin/x86_64-linux</span><br></pre></td></tr></table></figure></blockquote>
<p>验证安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tex --version</span><br><span class="line">latex --version</span><br></pre></td></tr></table></figure>

<p>再安装Perl模块（后边格式化代码时需要用到）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install cpanminus</span><br><span class="line">sudo cpanm YAML::Tiny</span><br><span class="line">sudo cpanm File::HomeDir</span><br><span class="line">sudo cpanm Unicode::GCString</span><br><span class="line">sudo cpanm Log::Log4perl</span><br><span class="line">sudo cpanm Log::Dispatch</span><br></pre></td></tr></table></figure>

<p>安装tex-fmt</p>
<p>用官方脚本装rustup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y curl build-essential pkg-config libssl-dev</span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y</span><br></pre></td></tr></table></figure>

<p>在当前终端把环境加载进来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/env&quot;</span></span><br></pre></td></tr></table></figure>

<p>切换到stable并更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup update stable</span><br><span class="line">rustup default stable</span><br></pre></td></tr></table></figure>

<p>配置crates镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$HOME</span>/.cargo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &gt; <span class="string">&quot;<span class="variable">$HOME</span>/.cargo/config.toml&quot;</span> &lt;&lt; <span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with = <span class="string">&#x27;hustmirror&#x27;</span></span><br><span class="line"></span><br><span class="line">[source.hustmirror]</span><br><span class="line">registry = <span class="string">&quot;sparse+https://mirrors.hust.edu.cn/crates.io-index/&quot;</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>安装tex-fmt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cargo install tex-fmt</span><br></pre></td></tr></table></figure>

<p>配置环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充一些扩展</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install texlive-xetex texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended</span><br></pre></td></tr></table></figure></blockquote>
<h1 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h1><p>下载以下两个插件</p>
<p><img src="/TexLive-VScode/latex.png" alt="cahjian"></p>
<p>在setting的json中加入以下配置</p>
<p><img src="/TexLive-VScode/latex2.png"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span> <span class="comment">// 自动保存</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnPaste&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 粘贴后自动格式化</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnType&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 键入后自动格式化</span></span><br><span class="line"><span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 保存时自动格式化</span></span><br><span class="line"><span class="comment">// LaTeX</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;--shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;--shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;--shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.fdb_latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.nav&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.pdfsync&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.pre&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.rubbercache&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.snm&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.synctex&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.synctex(busy)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.synctex.gz&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.synctex.gz(busy)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="string">&quot;*.vrb&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 清理上述后缀名的文件</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;glob&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 语法检查</span></span><br><span class="line"><span class="attr">&quot;latex.linter.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// tex文件浏览器，可选项为&quot;none&quot; &quot;browser&quot; &quot;tab&quot; &quot;external&quot;</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tab&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 自动编译tex文件</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onSave&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 显示内容菜单：（1）编译文件；（2）定位游标</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 显示错误</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 显示警告</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 从使用的包中自动补全命令和环境</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 清除辅助文件</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 设置vscode编译tex文档时的默认编译链</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 用于反向同步的内部查看器的键绑定。ctrl/cmd + 点击（默认）或双击</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;double-click&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随便在一个.tex文件中右键，然后点击<code>使用格式化文档</code>，然后选择Latex Workhop</p>
<p>编译记得点击</p>
<p><img src="/TexLive-VScode/latex3.png"></p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2></blockquote>
<p><a href="https://blog.csdn.net/M0rtzz/article/details/136026129">VScode config</a>.</p>
<p><a href="https://blog.csdn.net/rear_queue/article/details/131126256">Texlive</a>.</p>
]]></content>
      <categories>
        <category>— Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Latex</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>cycle</title>
    <url>/cycle.html</url>
    <content><![CDATA[<!--more-->
<h1 id="铁腚行"><a href="#铁腚行" class="headerlink" title="铁腚行"></a>铁腚行</h1><h2 id="已备骑行装备"><a href="#已备骑行装备" class="headerlink" title="已备骑行装备"></a>已备骑行装备</h2><ul>
<li>车</li>
</ul>
<p>喜德盛RC200（2025-2-11） <span class="price" data-price="1499"> 1499 ￥</span></p>
<p><img src="/cycle/init1.png" alt="init1"></p>
<p>喜德胜AD300（2025-12-25） <span class="price" data-price="2999"> 2999 ￥</span></p>
<p>二手收购大学生九九新😍</p>
<p><img src="/cycle/ad300.png"></p>
<ul>
<li>护目镜：</li>
</ul>
<p>匹克日常 <span class="price" data-price="39"> 39 ￥</span></p>
<ul>
<li>手机支架</li>
</ul>
<p>ROCKBROS <span class="price" data-price="29"> 29 ￥</span></p>
<ul>
<li>头盔</li>
</ul>
<p>GUB M5 Mips骑行头盔 <span class="price" data-price="239"> 239 ￥</span></p>
<ul>
<li>手套</li>
</ul>
<p>VEIDOORN 半指 <span class="price" data-price="39"> 39 ￥</span></p>
<ul>
<li>水壶 + 水壶架</li>
</ul>
<p>ROCKBROS <span class="price" data-price="35">&#96;35￥</span></p>
<p>铂朗尼水壶 <span class="price" data-price="23"> 23 ￥</span></p>
<p>碳纹ABS一体成型水杯架 <span class="price" data-price="16"> 16 ￥</span></p>
<ul>
<li>尾灯</li>
</ul>
<p>美利达智能感应刹车灯 <span class="price" data-price="30"> 30 ￥</span></p>
<hr>
<blockquote>
<p><strong>总价</strong>:  <span id="total-price">计算中…</span></p>
</blockquote>
<h2 id="总行程"><a href="#总行程" class="headerlink" title="总行程"></a>总行程</h2><p>2025-03-01之前 <span class="distance" data-distance="147"> 147 km</span></p>
<p>2025-03-01 <span class="distance" data-distance="150"> 150 km<br><img src="/cycle/lvdao1.png" alt="lvdao1"></span></p>
<p>2025-03-11 <span class="distance" data-distance="40"> 40 km<br><img src="/cycle/shouan1.jpg" alt="shouan1"></span></p>
<p>2025-03-15 <span class="distance" data-distance="13"> 13 km</span></p>
<p>2025-03-18 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan2](cycle/shouan2.jpg) -->

<p>2025-03-25 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan3](cycle/shouan3.jpg) -->

<p>2025-04-02 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan4](cycle/shouan4.jpg) -->

<p>2025-04-08 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan5](cycle/shouan5.jpg) -->

<p>2025-04-15 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan6](cycle/shouan6.jpg) -->

<p>2025-04-22 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan7](cycle/shouan7.jpg) -->

<p>2025-05-24 <span class="distance" data-distance="40"> 40 km<br>第一次夜骑，没有前灯只有尾灯，骑的还是乡镇路，伸手不见五指的我完成了pb<br><img src="/cycle/shouan8.jpg" alt="shouan8"></span></p>
<p>2025-05-27 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan9](cycle/shouan9.jpg)
咕噜咕噜牛肉面
<div style="text-align: center;">
  <video style="max-width: 90%;" controls>
    <source src="cycle/beef2.mp4" type="video/mp4">
    您的浏览器不支持 video 标签。
  </video>
</div> -->

<!-- ![beefnoodle1](cycle/beefnoodle1.png) -->

<p>2025-05-29 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan10](cycle/shouan10.jpg) -->

<p>2025-05-30 <span class="distance" data-distance="40"> 40 km</span></p>
<!-- ![shouan11](cycle/shouan11.jpg) -->

<p>2025-06-05 <span class="distance" data-distance="50"> 50 km<br>解锁新路线：北林</span></p>
<!-- ![shouan12_2](cycle/shouan12_2.png) -->

<p><img src="/cycle/shouan12_3.png" alt="shouan12_3"><br><img src="/cycle/shouan12_1.png" alt="shouan12_1"></p>
<p>2025-06-25 <span class="distance" data-distance="40"> 40 km</span></p>
<p>解放的期末，久违的骑行</p>
<!-- ![shouan13](cycle/shouan13.png) -->

<p>2025-06-28 <span class="distance" data-distance="40"> 40 km</span></p>
<p>最累的一集，感觉期末状态没恢复过来</p>
<!-- ![shouan14](cycle/shouan14.png) -->

<p>2025-07-07 <span class="distance" data-distance="25"> 25 km</span></p>
<p>回家了，绕城</p>
<p><img src="/cycle/dianjiang1.png" alt="dianjiang1"></p>
<p>2025-07-15 <span class="distance" data-distance="20"> 20 km</span></p>
<p>2025-07-17 <span class="distance" data-distance="20"> 20 km</span></p>
<p>2025-07-18 <span class="distance" data-distance="15"> 15 km</span></p>
<p>2025-07-24 <span class="distance" data-distance="20"> 20 km</span></p>
<p>2025-07-27 <span class="distance" data-distance="10"> 10 km</span></p>
<p>2025-07-28 <span class="distance" data-distance="20"> 20 km</span></p>
<p>2025-07-30 <span class="distance" data-distance="110"> 100 km<br>最艰难的一集，接近四十度的天气暴晒八小时（不会再顶着高温征战绿道了，差点没活着回来）</span></p>
<p>2025-08-02 <span class="distance" data-distance="40"> 40 km</span></p>
<p>2025-08-03 <span class="distance" data-distance="40"> 40 km<br>双排<br><img src="/cycle/shouan15.png" alt="shouan15"></span></p>
<p>2025-08-06 <span class="distance" data-distance="40"> 40 km</span></p>
<p>2025-08-09 <span class="distance" data-distance="40"> 40 km</span></p>
<p>2025-08-11 <span class="distance" data-distance="50"> 50 km</span></p>
<p>2025-08-13 <span class="distance" data-distance="50"> 50 km</span></p>
<p>2025-08-25 <span class="distance" data-distance="50"> 40 km</span></p>
<p>2025-08-29 <span class="distance" data-distance="40"> 40 km<br>雨骑的魅力在于，越骑越冷…</span></p>
<p>2025-08-31 <span class="distance" data-distance="40"> 40 km</span></p>
<p>2025-09-09 <span class="distance" data-distance="40"> 40 km</span></p>
<p>2025-09-13 <span class="distance" data-distance="40"> 40 km</span></p>
<blockquote>
<p><strong>总行程</strong>: <span id="total-distance"> 计算中…</span></p>
</blockquote>
<hr>
<h2 id="车"><a href="#车" class="headerlink" title="车"></a>车</h2><p>2025-04-21 第一次扎胎，扎到落叶里生命的余韵了🔥<br><img src="/cycle/cy1.jpg" alt="2"></p>
<p>2025-06-29 第一次拆车并装车，一定要经常松动一些关键部位的螺丝，不然生锈了会卡死，拆下来的前轮要放在飞盘的另一侧，轮轴差不多对准放竖杯架的地方。<br><img src="/cycle/offcar1.png" alt="offcar"></p>
<blockquote>
<p>一个月后顺利装车返校…</p>
</blockquote>
<p>2025-08-13 洗车，上油</p>
<script>
document.addEventListener("DOMContentLoaded", function () {
    let totalPrice = 0;
    document.querySelectorAll(".price").forEach(item => {
        totalPrice += parseFloat(item.getAttribute("data-price"));
    });
    document.getElementById("total-price").innerText = totalPrice.toFixed(2) + " ￥";

    let totalDistance = 0;
    document.querySelectorAll(".distance").forEach(item => {
        totalDistance += parseFloat(item.getAttribute("data-distance"));
    });
    document.getElementById("total-distance").innerText = totalDistance + " km";
});
</script>
]]></content>
      <categories>
        <category>Daily</category>
      </categories>
      <tags>
        <tag>Bike</tag>
      </tags>
  </entry>
  <entry>
    <title>Git better</title>
    <url>/learngit.html</url>
    <content><![CDATA[<!--more-->
<h1 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h1><ul>
<li>自报家门</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>查询家门</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
<!--more-->
<hr>
<p>创建SSH连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在本地生成密钥和公钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br><span class="line"></span><br><span class="line">获取公钥（id_rsa.pub）后在Github上创建SSHKey</span><br><span class="line"></span><br><span class="line">验证是否成功</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>pwd 用于显示当前目录</li>
</ul>
<p><code>$ pwd</code></p>
<hr>
<ul>
<li>init 把当前目录变成Git可以管理的仓库</li>
</ul>
<p><code>$ git init</code></p>
<hr>
<ul>
<li>la -ah 用于查看隐藏的.git目录</li>
</ul>
<p><code>$ ls -ah</code></p>
<hr>
<ul>
<li>add 把文件添加到仓库</li>
</ul>
<p><code>$ git add &lt;file&gt;</code></p>
<hr>
<ul>
<li>commit 把文件提交到仓库</li>
</ul>
<p><code>$ git commit -m &lt;message&gt;</code></p>
<hr>
<ul>
<li>status 查看库状态</li>
</ul>
<p><code>$ git status</code></p>
<hr>
<ul>
<li>dif 查看修改内容</li>
</ul>
<p><code>$ git diff &lt;file&gt;</code></p>
<hr>
<ul>
<li>log 查看历史记录</li>
</ul>
<p><code>$ git log</code><br><code>$ git log --pretty=oneline</code></p>
<ul>
<li>reflog 查看每一次命令</li>
</ul>
<p><code>$ git reflog</code></p>
<hr>
<ul>
<li>reset 版本回退</li>
</ul>
<p>–hard会回退到上个版本的已提交状态，而–soft会回退到上个版本的未提交状态，–mixed会回退到上个版本已添加但未提交的状态.</p>
<p><code>$ git reset --hard HEAD~&lt;num&gt;</code><br><code>$ git reset --hard &lt;version&gt;</code></p>
<hr>
<ul>
<li>cat 查看内容</li>
</ul>
<p><code>$ cat &lt;file&gt;</code></p>
<hr>
<ul>
<li>撤销工作区修改</li>
</ul>
<p><code>$ git checkout -- &lt;file&gt;</code></p>
<ul>
<li>撤销暂存区修改</li>
</ul>
<p><code>$ git reset HEAD &lt;file&gt;</code></p>
<hr>
<ul>
<li>删除文件</li>
</ul>
<p><code>$ git rm &lt;file&gt;</code></p>
<hr>
<ul>
<li>添加远程库</li>
</ul>
<p><code>$ git remote add origin git@github.com:&lt;yourname&gt;/learngit.git</code></p>
<ul>
<li>推送</li>
</ul>
<p><code>$ git push -u origin master</code></p>
<ul>
<li>本地做了提交后</li>
</ul>
<p><code>$ git push origin master</code></p>
<ul>
<li>查看远程库信息</li>
</ul>
<p><code>$ git remote -v</code></p>
<ul>
<li>删除远程库</li>
</ul>
<p><code>$ git remote rm &lt;name&gt;</code></p>
<hr>
<ul>
<li>克隆</li>
</ul>
<p><code>$ git clone git@github.com:&lt;name&gt;/gitskills.git</code></p>
<hr>
<ul>
<li>创建并切换至新分支</li>
</ul>
<p><code>$ git checkout -b &lt;name&gt;</code><br><code>$ git switch -c &lt;name&gt;</code> </p>
<p>等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>

<ul>
<li>查看分支</li>
</ul>
<p><code>$ git branch</code></p>
<ul>
<li>合并分支</li>
</ul>
<p><code>$ git merge &lt;name&gt;</code></p>
<ul>
<li>删除分支</li>
</ul>
<p><code>$ git branch -d &lt;name&gt;</code></p>
<ul>
<li>强制删除</li>
</ul>
<p><code>$ git branch -D &lt;name&gt;</code></p>
<ul>
<li><code>--no-ff</code>方式的<code>git merge</code></li>
</ul>
<p><code>$ git merge --no-ff -m &quot;merge with no-ff&quot; &lt;name&gt;</code></p>
<ul>
<li>stash储藏工作现场</li>
</ul>
<p><code>$ git stash</code></p>
<ul>
<li>查看</li>
</ul>
<p><code>$ git stash list</code></p>
<ul>
<li>恢复现场</li>
</ul>
<p>恢复并删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure>
<p>或<br><code>$ git stash pop</code></p>
<ul>
<li>复制修改</li>
</ul>
<p><code>$ git cherry-pick &lt;version&gt;</code></p>
<ul>
<li>推送冲突后抓取文件到本地合并</li>
</ul>
<p><code>$ git pull</code></p>
<ul>
<li>变基</li>
</ul>
<p><code>$ git rebase</code></p>
<hr>
<ul>
<li>打标签</li>
</ul>
<p><code>$ git tag &lt;tag&gt;</code><br><code>$ git tag &lt;tag&gt; &lt;version&gt;</code></p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<p><code>$ git tag -a &lt;tag&gt; -m &quot;info&quot; &lt;version&gt;</code></p>
<ul>
<li>查看标签</li>
</ul>
<p><code>$ git tag</code></p>
<ul>
<li>查看标签内容</li>
</ul>
<p><code>$ git show &lt;tag&gt;</code></p>
<ul>
<li>删除标签</li>
</ul>
<p><code>$ git tag -d &lt;tag&gt;</code></p>
<ul>
<li>推送标签</li>
</ul>
<p><code>$ git push origin &lt;tag&gt;</code><br><code>$ git push origin --tags</code></p>
<ul>
<li>删除远程标签</li>
</ul>
<p>先删除本地再：<br><code>$ git push origin :refs/tags/&lt;tag&gt;</code></p>
<p>补充</p>
<p><img src="/learngit/git1.png" alt="git1"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://liaoxuefeng.com/">廖雪峰</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo better</title>
    <url>/learnhexo.html</url>
    <content><![CDATA[<!--more-->

<h1 id="来时路"><a href="#来时路" class="headerlink" title="来时路"></a>来时路</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="1：无法初始化"><a href="#1：无法初始化" class="headerlink" title="1：无法初始化"></a>1：无法初始化</h3><p>hexo init （blog）时因为代理无法正常初始化完成，修改代理地址，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:7890</span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>这将允许 Git 通过本地代理进行连接。如果不再需要代理，或者想要清除代理设置，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>


<h3 id="2：npm速度慢"><a href="#2：npm速度慢" class="headerlink" title="2：npm速度慢"></a>2：npm速度慢</h3><p><a href="https://npmmirror.com/">淘宝镜像</a></p>
<p><img src="/learnhexo/taobao1.png" alt="p1"></p>
<p>之后在npm前加个c!</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="建站前"><a href="#建站前" class="headerlink" title="建站前"></a>建站前</h3><p>在gitbase中cd到博客文件夹</p>
<p>下载hexo框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<hr>
<p>初始化博客项目（若已经在下一级文件夹中可不加folder）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init [folder] </span><br></pre></td></tr></table></figure>
<hr>
<p>进入folder</p>
<p>安装依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<hr>
<p>下载部署器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<hr>
<p>之后可随时部署到Github上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h3 id="建站后"><a href="#建站后" class="headerlink" title="建站后"></a>建站后</h3><p>new 新建一篇文章</p>
<p>-p 自定义文章路径</p>
<p>-r 如果存在则替换</p>
<p>-s 文章别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br></pre></td></tr></table></figure>
<hr>
<p>generate 生成静态文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<hr>
<p>publish 发布草稿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>server 启动服务器</p>
<p>-p 重设端口</p>
<p>-s 只使用静态文件</p>
<p>-l 启用日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<hr>
<p>deploy 部署网站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<hr>
<p>render 渲染文件<br>-o output destination</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>
<hr>
<p>migrate 从其他博客系统迁移内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo migrate&lt;type&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>list 列出所有路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>version 显示版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<hr>
<p>config 列出网站的配置（_config.yml）。 如果指定了 key，则只展示配置中对应 key 的值；如果同时指定了 key 和 value，则将配置中对应的 key 的值修改为 value。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo config [key] [value]</span><br></pre></td></tr></table></figure>

<p>查看已经安装的插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ls --depth=0</span><br></pre></td></tr></table></figure>


<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dayuzy.com/">资深技术博客</a></p>
<p><a href="https://blog.csdn.net/cat_bayi/article/details/128725230">CSDN良心教学</a></p>
<p><a href="https://mp.weixin.qq.com/s/GmTmhpkB0QmoHIL5bmXQGw">小岛码农</a></p>
<p><a href="https://hexo.io/zh-cn/">官方文档</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh/oh_my_zsh</title>
    <url>/zsh-oh-my-zsh.html</url>
    <content><![CDATA[<!--more-->

<h1 id="zsh-oh-my-zsh配置-debian-ubuntu"><a href="#zsh-oh-my-zsh配置-debian-ubuntu" class="headerlink" title="zsh&#x2F;oh_my_zsh配置(debian&#x2F;ubuntu)"></a>zsh&#x2F;oh_my_zsh配置(debian&#x2F;ubuntu)</h1><p>如果bash的脚本开头是以!#&#x2F;bin&#x2F;bash的话，在zsh下完全兼容bash,其余的我就不知道鸟  </p>
<blockquote>
<p> 注意以下所有指令均在debian系下运行  </p>
</blockquote>
<h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><p>查看shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>

<p>安装zsh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure>

<p>设置默认shell</p>
<ul>
<li>为sudo用户设置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上指令不能正常运行时可以试试以下指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chsh -s $(which zsh)</span><br></pre></td></tr></table></figure></blockquote>
<ul>
<li>为特定用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chsh -s /bin/zsh &lt;username&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;username&gt; 替换为实际用户名</span></span><br></pre></td></tr></table></figure>

<h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh_my_zsh"></a>oh_my_zsh</h1><p>安装git</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<p>自动安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>网络不好时可尝试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://gitee.com/leok77s/ohmyzsh-gitee/raw/main/install.gitee.sh)&quot;</span><br></pre></td></tr></table></figure></blockquote>
<p>也可以手动自行去github上克隆安装，然后将配置cp到自己的.zshrc上</p>
<ul>
<li><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3></li>
</ul>
<p>功能介绍：优雅主题、自动补全、语法高亮、esc两次等于添加sudo</p>
<p><strong>主题</strong></p>
<p>祖传powerlevel10k，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;/themes/powerlevel10k</span><br></pre></td></tr></table></figure>

<p>在<code>~/.zshrc</code>中配置<code>ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Set name of the theme to load --- <span class="keyword">if</span> <span class="built_in">set</span> to <span class="string">&quot;random&quot;</span>, it will</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">load a random theme each time Oh My Zsh is loaded, <span class="keyword">in</span> <span class="built_in">which</span> <span class="keyword">case</span>,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to know <span class="built_in">which</span> specific one was loaded, run: <span class="built_in">echo</span> <span class="variable">$RANDOM_THEME</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZSH_THEME=<span class="string">&quot;robbyrussell&quot;</span></span></span><br><span class="line">ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot;</span><br></pre></td></tr></table></figure>

<p><code>source ~/.zshrc</code>一下</p>
<p><strong>plus</strong></p>
<p>找到plugin再添加如下配置（还可以自己补充，不过以下三条足以）</p>
<p><strong>zsh-autosuggestion:</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-$&#123;ZSH:-~/.oh-my-zsh&#125;/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p><strong>zsh-syntax-highlighting</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>编辑<code>~/.zshrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Which plugins would you like to load?</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Standard plugins can be found <span class="keyword">in</span> <span class="variable">$ZSH</span>/plugins/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Custom plugins may be added to <span class="variable">$ZSH_CUSTOM</span>/plugins/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example format: plugins=(rails git textmate ruby lighthouse)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">        git</span><br><span class="line">        sudo</span><br><span class="line">        zsh-syntax-highlighting</span><br><span class="line">        zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>最后记得<code>source .zshrc</code>，然后会进入主题的配置界面，非常简单的交互<br><img src="/zsh-oh-my-zsh/p1.png"><br>最终效果，简约，补全（根据最近历史记录)，时间显示，按两次esc可以直接sudo</p>
<blockquote>
<p>熟练后在新设备上五分钟不到就OK，如果你发现怎么都没办法把zsh调成默认shell，不妨试一下重启，血压飙升！</p>
</blockquote>
<h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><p><a href="https://ohmyz.sh/">oh_my_zsh官网</a></p>
<p><a href="https://sysin.org/blog/linux-zsh/">sysin</a></p>
<p><a href="https://www.zhihu.com/question/33277508">知乎_theme</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>zsh/oh_my_zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>algorithm</title>
    <url>/algorithm.html</url>
    <content><![CDATA[<!--more-->

<h1 id="PDF下载"><a href="#PDF下载" class="headerlink" title="PDF下载"></a>PDF下载</h1><p><a href="/pdfs/algorithm.pdf">📥 下载煮波同款PDF</a>.</p>
<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>三种建图方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">11</span>; <span class="comment">// 最大点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">21</span>; <span class="comment">// 最大边数（无向图需 2 倍）</span></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="type">int</span> graph1[MAXN][MAXN];</span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; graph2;</span><br><span class="line"><span class="comment">// 链式前向星</span></span><br><span class="line"><span class="type">int</span> head[MAXN], nxt[MAXM], to[MAXM], weight[MAXM], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 清空邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 清空邻接表</span></span><br><span class="line">    graph2.<span class="built_in">clear</span>();</span><br><span class="line">    graph2.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 清空链式前向星</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    nxt[ ++cnt] = head[u];</span><br><span class="line">    to[cnt] = v;</span><br><span class="line">    weight[cnt] = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">directGraph</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        graph2[edge[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无向</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">undirectGraph</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">        graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        graph1[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        graph2[edge[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        graph2[edge[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">addEdge</span>(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;邻接矩阵遍历:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; graph1[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;邻接表遍历:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; (邻居,边权): &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; edge : graph2[i]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; edge.first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; edge.second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;链式前向星遍历:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; (邻居,边权): &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ei = head[i]; ei &gt; <span class="number">0</span>; ei = nxt[ei]) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; to[ei] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; weight[ei] &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">4</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges1 = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;, &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">build</span>(n1);</span><br><span class="line">    <span class="built_in">directGraph</span>(edges1);</span><br><span class="line">    <span class="built_in">traversal</span>(n1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;==============================&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> n2 = <span class="number">5</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges2 = &#123;&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>&#125;, &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>&#125;, &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">build</span>(n2);</span><br><span class="line">    <span class="built_in">undirectGraph</span>(edges2);</span><br><span class="line">    <span class="built_in">traversal</span>(n2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="欧拉回路与欧拉路径"><a href="#欧拉回路与欧拉路径" class="headerlink" title="欧拉回路与欧拉路径"></a>欧拉回路与欧拉路径</h3><p>七桥问题源自柯尼斯堡城（现加里宁格勒）的七座桥，询问能否从某处出发，<strong>恰好一次</strong>走过每座桥并回到起点（或不回到起点）。</p>
<p><strong>度（degree）</strong>：无向图中与顶点相 incident 的边条数，记作 <code>deg(v)</code>。</p>
<p><strong>欧拉路径（Euler trail&#x2F;path）</strong>：经过<strong>每条边恰好一次</strong>的<strong>路</strong>。</p>
<p><strong>欧拉回路（Euler circuit&#x2F;tour）</strong>：经过<strong>每条边恰好一次</strong>并<strong>回到起点</strong>的<strong>环</strong>。</p>
<p><strong>连通性</strong>：忽略度为 0 的顶点后，图在无向意义下应当<strong>连通</strong>。</p>
<p>判定定理（必要且充分）</p>
<p><strong>无向图（允许多重边）</strong>：</p>
<ol>
<li>非零度顶点诱导的子图连通；</li>
<li>设奇度顶点个数为 <code>k</code>：<ul>
<li><code>k = 0</code> ⇒ 存在<strong>欧拉回路</strong>（也存在路径）；</li>
<li><code>k = 2</code> ⇒ 存在<strong>欧拉路径但无回路</strong>（起点&#x2F;终点为这两个奇度顶点之一）；</li>
<li>其他 <code>k</code> ⇒ <strong>不存在</strong>欧拉路径。</li>
</ul>
</li>
</ol>
<p><strong>直观理解</strong>：进入与离开同一顶点消耗 2 条 incident 边，所以除起点&#x2F;终点外应为偶度；若回路（起点&#x3D;终点），则所有顶点偶度。</p>
<h3 id="图最短路"><a href="#图最短路" class="headerlink" title="图最短路"></a>图最短路</h3><p>从某一基点到其他点的最短路径</p>
<h4 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h4><h5 id="普通堆"><a href="#普通堆" class="headerlink" title="普通堆"></a>普通堆</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, st;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; st;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">g</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, u, v, w; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> 	priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; q1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : g[st])&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(&#123;it.second,it.first&#125;);  </span><br><span class="line">    &#125;</span><br><span class="line">    distance[st] = <span class="number">0</span>;</span><br><span class="line">    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="type">int</span> u, w, v;</span><br><span class="line">    <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp = q1.<span class="built_in">top</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        u = temp.second;</span><br><span class="line">        w = temp.first;</span><br><span class="line">        <span class="keyword">if</span>(visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        distance[u] = w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : g[u])&#123;</span><br><span class="line">            v = it.first;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; it.second + distance[u] &lt; distance[v])&#123;</span><br><span class="line">                q1.<span class="built_in">push</span>(&#123;it.second + distance[u], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; distance[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反向索引堆"><a href="#反向索引堆" class="headerlink" title="反向索引堆"></a>反向索引堆</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//heap</span></span><br><span class="line"><span class="type">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"><span class="type">int</span> MAXM = <span class="number">200001</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next1</span><span class="params">(MAXM)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">to</span><span class="params">(MAXM)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(MAXM)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heap</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="type">int</span> sizeh = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">where</span><span class="params">(MAXN,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance1</span><span class="params">(MAXN,INT_MAX)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[i], heap[j]);</span><br><span class="line">    where[heap[i]] = i;</span><br><span class="line">    where[heap[j]] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; distance1[heap[i]] &lt; distance1[heap[(i - <span class="number">1</span>) / <span class="number">2</span>]])&#123;</span><br><span class="line">        <span class="built_in">swap1</span>(i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> max_mark;</span><br><span class="line">    <span class="type">int</span> mark;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; sizeh) &#123;</span><br><span class="line">        max_mark = l + <span class="number">1</span> &lt; sizeh &amp;&amp; distance1[heap[l + <span class="number">1</span>]] &lt; distance1[heap[l]] ? l + <span class="number">1</span> : l;</span><br><span class="line">        mark =distance1[ heap[i]] &lt;distance1[ heap[max_mark]] ? i : max_mark;</span><br><span class="line">        <span class="keyword">if</span> (mark == i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap1</span>(i, mark);</span><br><span class="line">            i = mark;</span><br><span class="line">            l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y, w; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        next1[cnt] = head[x];</span><br><span class="line">        to[cnt] = y;</span><br><span class="line">        weight[cnt] = w;</span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[sizeh++] = s;</span><br><span class="line">    distance1[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sizeh) &#123;</span><br><span class="line">        <span class="type">int</span> u = heap[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">swap1</span>(<span class="number">0</span>, --sizeh);</span><br><span class="line">        <span class="built_in">heapify</span>(<span class="number">0</span>);</span><br><span class="line">        where[u] = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ei = head[u]; ei &gt; <span class="number">0</span>; ei = next1[ei]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[ei];</span><br><span class="line">            <span class="type">int</span> w = weight[ei];</span><br><span class="line">            <span class="keyword">if</span> (where[v] == <span class="number">-1</span>) &#123;</span><br><span class="line">                distance1[v] = w + distance1[u];</span><br><span class="line">                where[v] = sizeh;</span><br><span class="line">                heap[sizeh++] = v;</span><br><span class="line">                <span class="built_in">heapInsert</span>(where[v]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (where[v] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                distance1[v] = <span class="built_in">min</span>(distance1[v], distance1[u] + w);</span><br><span class="line">                <span class="built_in">heapInsert</span>(where[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; distance1[i];</span><br><span class="line">        <span class="keyword">if</span> (i != n) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="求最短奇偶路径"><a href="#求最短奇偶路径" class="headerlink" title="求最短奇偶路径"></a>求最短奇偶路径</h5><p>该思想可拓展为某一个节点有n种状态，故每条边增加一个变量为路的数量，一般设置为t &#x3D; 1,而跑DJ算法时，可以在优先队列后面再加一个属性表示状态type，type &#x3D; (type + t) % n。</p>
<p>当再增加一个属性表示节点的类别，相同节点间可以以某个代价相互传送时，则可以抽象为新增了一个祖先节点，该祖先与所有该类别的节点相互联通，节点到祖先的t&#x3D;1，祖先到节点的t&#x3D;0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设边权为1,若不为1则w+1变成w+weight[ei]</span></span><br><span class="line"><span class="comment">// 初始化奇数和偶数路径长度的距离数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis_o</span><span class="params">(n + <span class="number">1</span>, <span class="number">1e18</span>)</span>, <span class="title">dis_e</span><span class="params">(n + <span class="number">1</span>, <span class="number">1e18</span>)</span></span>; <span class="comment">// dis_o: 最短奇数路径，dis_e: 最短偶数路径</span></span><br><span class="line">dis_e[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 起点（节点1）的偶数路径长度为0</span></span><br><span class="line"><span class="comment">// 使用最小堆优先队列存储 &#123;距离, 节点&#125; 对</span></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; q1;</span><br><span class="line">q1.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// 从节点1开始，距离为0</span></span><br><span class="line"><span class="comment">// Dijkstra算法</span></span><br><span class="line"><span class="keyword">while</span> (!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [w, u] = q1.<span class="built_in">top</span>(); <span class="comment">// w: 当前距离，u: 当前节点</span></span><br><span class="line">    q1.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">// 遍历节点u的所有邻居</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ei = head[u]; ei; ei = next[ei]) &#123;</span><br><span class="line">        <span class="type">int</span> v = to[ei]; <span class="comment">// 邻居节点</span></span><br><span class="line">        <span class="keyword">if</span> (w &amp; <span class="number">1</span>) &#123; <span class="comment">// 如果到u的路径长度为奇数</span></span><br><span class="line">            <span class="keyword">if</span> (dis_e[v] &gt; w + <span class="number">1</span>) &#123; <span class="comment">// 尝试更新v的偶数路径</span></span><br><span class="line">                dis_e[v] = w + <span class="number">1</span>;</span><br><span class="line">                q1.<span class="built_in">push</span>(&#123;w + <span class="number">1</span>, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果到u的路径长度为偶数</span></span><br><span class="line">            <span class="keyword">if</span> (dis_o[v] &gt; w + <span class="number">1</span>) &#123; <span class="comment">// 尝试更新v的奇数路径</span></span><br><span class="line">                dis_o[v] = w + <span class="number">1</span>;</span><br><span class="line">                q1.<span class="built_in">push</span>(&#123;w + <span class="number">1</span>, v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*迷宫有n个房间，通过m条单向道路连接，迷宫的起点是1号房间，终点是n号房间。每条道路都有一个守路人，需要支付对应数量的金币才能通过，这个迷宫还存在着两个神秘的规则：</span></span><br><span class="line"><span class="comment">1.只有当走到终点时经过的路的数量是3的倍数时她才能顺利逃离迷宫。</span></span><br><span class="line"><span class="comment">2.每个房间都有一个类别属性，她可以花费x个金币在相同类别的属性之间瞬移（注意每次瞬移也算作走过了一条路），特殊地她可以在同个房间内进行瞬移</span></span><br><span class="line"><span class="comment">如果怎样都不能走出迷宫的话输出“-1”*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> inf = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n, m, k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">		<span class="function">vector <span class="title">adj</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, vector&lt;array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&gt;())</span></span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sta</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">			cin &gt;&gt; sta[i];</span><br><span class="line">			adj[i].<span class="built_in">push_back</span>(&#123;sta[i] + n, k, <span class="number">1</span>&#125;);</span><br><span class="line">			adj[sta[i] + n].<span class="built_in">push_back</span>(&#123;i, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; i ++)&#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">			adj[u].<span class="built_in">push_back</span>(&#123;v, w, <span class="number">1</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt; <span class="built_in">dis</span>(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, &#123;inf, inf, inf&#125;);</span><br><span class="line">		priority_queue&lt;array&lt;<span class="type">int</span>, 3&gt;, vector&lt;array&lt;<span class="type">int</span>, 3&gt;&gt;, greater&lt;&gt;&gt; q1;</span><br><span class="line">		array&lt;<span class="type">int</span>, 3&gt; t1;</span><br><span class="line">		<span class="type">int</span> u, val, in, in1;</span><br><span class="line">		dis[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		q1.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		<span class="keyword">while</span>(!q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			t1 = q1.<span class="built_in">top</span>();</span><br><span class="line">			q1.<span class="built_in">pop</span>();</span><br><span class="line">			val = t1[<span class="number">0</span>], u = t1[<span class="number">1</span>], in = t1[<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> [v, w, gap] : adj[u])&#123;</span><br><span class="line">				in1 = (in + gap) % <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">if</span>(dis[v][in1] &gt; val + w)&#123;</span><br><span class="line">					dis[v][in1] = val + w;</span><br><span class="line">					q1.<span class="built_in">push</span>(&#123;dis[v][in1], v, in1&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dis[n][<span class="number">0</span>] == inf)&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; dis[n][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floydWarshallTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 初始化邻接矩阵，默认不可达时权值为 INF</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INF));</span><br><span class="line">    <span class="comment">// 自己到自己距离为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入边，假设输入为无向图，若为有向图则只更新一边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        u--; v--; <span class="comment">// 若输入顶点编号从 1 开始则转换为从 0 开始</span></span><br><span class="line">        <span class="comment">// 对于多重边取权值最小的一条</span></span><br><span class="line">        dist[u][v] = <span class="built_in">min</span>(dist[u][v], w);</span><br><span class="line">        dist[v][u] = <span class="built_in">min</span>(dist[v][u], w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Floyd–Warshall 算法：枚举中转点 k、起点 i 和终点 j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果 i-&gt;k 不可达则无需更新</span></span><br><span class="line">            <span class="keyword">if</span> (dist[i][k] == INF) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 若路径 i-&gt;k 和 k-&gt;j 均可达，更新 i-&gt;j 的最短路径</span></span><br><span class="line">                <span class="keyword">if</span> (dist[k][j] &lt; INF)</span><br><span class="line">                    dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果：若两点不可达则输出 0，否则输出最短路径长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            cout &lt;&lt; (dist[i][j] == INF ? <span class="number">0</span> : dist[i][j]) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SPFA（Shortest-Path-Faster-Algorithm）算法"><a href="#SPFA（Shortest-Path-Faster-Algorithm）算法" class="headerlink" title="SPFA（Shortest Path Faster Algorithm）算法"></a><code>SPFA</code>（Shortest Path Faster Algorithm）算法</h4><p><code>SPFA</code> 算法是对 Bellman-Ford 算法的一种改进，主要用于在含有负权边的图中求最短路径。它利用队列来维护“待更新”的节点，从而提高更新效率。</p>
<p>根据最短路径理论，在没有负权回路的图中，从起点到任一节点的最短路径最多只需要经过 <code>n-1</code> 条边。所以若某节点的路径更新次数超过 <code>n-1</code>，就能确定有负权回路存在。</p>
<p><code>visited</code>：标记当前节点是否在队列中，防止重复入队</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">6001</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(M/<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next1</span><span class="params">(M)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">to</span><span class="params">(M)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(M)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    next1[cnt] = head[x];</span><br><span class="line">    to[cnt] = y;</span><br><span class="line">    weight[cnt] = w;</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fill</span>(head.<span class="built_in">begin</span>(),head.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y, w; i &lt; m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        <span class="built_in">addedge</span>(x,y,w);</span><br><span class="line">        <span class="keyword">if</span> (w &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">addedge</span>(y,x,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">distance</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">upcnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    heap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    distance[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    upcnt[<span class="number">1</span>]++;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = heap.<span class="built_in">front</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        visited[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ei = head[u];ei &gt; <span class="number">0</span>;ei = next1[ei]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[ei];</span><br><span class="line">            <span class="type">int</span> w = weight[ei];</span><br><span class="line">            <span class="keyword">if</span> (w + distance[u] &lt; distance[v]) &#123;</span><br><span class="line">                distance[v] = w + distance[u];</span><br><span class="line">                <span class="keyword">if</span> (visited[v]==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((++upcnt[v])  &gt; n<span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="comment">//存在负权回路</span></span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[v] = <span class="number">1</span>;</span><br><span class="line">                    heap.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>树上的一条无回路的连通所有节点的一条权值最小的路径</p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Kruskal 算法：利用并查集求最小生成树</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edges; <span class="comment">// (权值, 点u, 点v)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;w, u, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) parent[i] = i;</span><br><span class="line">	<span class="keyword">auto</span> find = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> x) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(parent[x] != x)&#123;</span><br><span class="line">			parent[x] = <span class="built_in">f</span>(f,parent[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> parent[x];</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [w, u, v] : edges) &#123;</span><br><span class="line">        <span class="type">int</span> pu = <span class="built_in">find</span>(find, u), pv = <span class="built_in">find</span>(find, v);</span><br><span class="line">        <span class="keyword">if</span> (pu != pv) &#123;</span><br><span class="line">            parent[pu] = pv;</span><br><span class="line">            sum += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prim 算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        graph[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        graph[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 优先队列：pair(权值, 节点)</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">    visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : graph[<span class="number">1</span>]) pq.<span class="built_in">push</span>(&#123;edge.second, edge.first&#125;);</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [w, u] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (visited[u]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        sum += w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge : graph[u])</span><br><span class="line">            <span class="keyword">if</span> (!visited[edge.first])</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;edge.second, edge.first&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的序列化与反序列化及先中序构造"><a href="#二叉树的序列化与反序列化及先中序构造" class="headerlink" title="二叉树的序列化与反序列化及先中序构造"></a>二叉树的序列化与反序列化及先中序构造</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode * left, * right;</span><br><span class="line">    <span class="built_in">TreeNode</span> (<span class="type">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//先序的序列化与反序列化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string r;</span><br><span class="line">        <span class="built_in">serialize_h</span>(root,r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vals = <span class="built_in">split</span>(data,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserialize_h</span>(vals,cnt);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize_h</span><span class="params">(TreeNode* root,string&amp; r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            r+=<span class="string">&quot;#,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r+=<span class="built_in">to_string</span>(root-&gt;val)+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">            <span class="built_in">serialize_h</span>(root-&gt;left,r);</span><br><span class="line">            <span class="built_in">serialize_h</span>(root-&gt;right,r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize_h</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; vals,<span class="type">int</span>&amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= vals.<span class="built_in">size</span>() || vals[cnt]==<span class="string">&quot;#&quot;</span> )&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(vals[cnt++]));</span><br><span class="line">        node-&gt;left=<span class="built_in">deserialize_h</span>(vals,cnt);</span><br><span class="line">        node-&gt;right=<span class="built_in">deserialize_h</span>(vals,cnt);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp;s,<span class="type">char</span> delimiter)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="function">istringstream <span class="title">tokenStream</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(tokenStream,token,delimiter))&#123;</span><br><span class="line">            tokens.<span class="built_in">push_back</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按层的序列化与反序列化</span></span><br><span class="line">    <span class="function">string <span class="title">serialize1</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string result;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                result += <span class="built_in">to_string</span>(node-&gt;val)+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;<span class="keyword">else</span> result+=<span class="string">&quot;#,&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize1</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        string item;</span><br><span class="line">        <span class="built_in">getline</span>(ss,item,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(item));</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getline</span>(ss,item,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(item==<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                    node-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(item));</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getline</span>(ss,item,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(item==<span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                    node-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    node-&gt;right=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(item));</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="利用先序和中序构造二叉树"><a href="#利用先序和中序构造二叉树" class="headerlink" title="利用先序和中序构造二叉树"></a>利用先序和中序构造二叉树</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序和中序构造二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.<span class="built_in">empty</span>() || inorder.<span class="built_in">empty</span>() || preorder.<span class="built_in">size</span>() != inorder.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.<span class="built_in">size</span>();i++) map[inorder[i]]=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,inorder,<span class="number">0</span>,inorder.<span class="built_in">size</span>()<span class="number">-1</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder,<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder,<span class="type">int</span> l2,<span class="type">int</span> r2,</span></span></span><br><span class="line"><span class="params"><span class="function">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1&gt;r1) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[l1]);</span><br><span class="line">        <span class="keyword">if</span>(l1==r1) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">int</span> k=map[preorder[l1]];</span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(preorder,l1+<span class="number">1</span>,l1+k-l2,inorder,l2,k<span class="number">-1</span>,map);</span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(preorder,l1+k-l2+<span class="number">1</span>,r1,inorder,k+<span class="number">1</span>,r2,map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树中LCA算法"><a href="#二叉树中LCA算法" class="headerlink" title="二叉树中LCA算法"></a>二叉树中LCA算法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LCA问题</span></span><br><span class="line"><span class="comment">//求二叉树两个节点的最近公共祖先</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || root==p || root==q)&#123;</span><br><span class="line">        	<span class="keyword">return</span> root;</span><br><span class="line">		&#125;</span><br><span class="line">        TreeNode* l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">nullptr</span> &amp;&amp; r!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        	<span class="comment">//左右两边都已经找到</span></span><br><span class="line">        	<span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">nullptr</span> &amp;&amp; r==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        	<span class="comment">//左右两边都没有找到</span></span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一边找到了，返回找到的一边</span></span><br><span class="line">        <span class="keyword">return</span> l==<span class="literal">nullptr</span>?r:l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//求线索二叉树两个节点的最近公共祖先</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// root从上到下</span></span><br><span class="line">		<span class="comment">// 如果先遇到了p，说明p是答案</span></span><br><span class="line">		<span class="comment">// 如果先遇到了q，说明q是答案</span></span><br><span class="line">		<span class="comment">// 如果root在p~q的值之间，不用管p和q谁大谁小，只要root在中间，那么此时的root就是答案</span></span><br><span class="line">		<span class="comment">// 如果root在p~q的值的左侧，那么root往右移动</span></span><br><span class="line">		<span class="comment">// 如果root在p~q的值的右侧，那么root往左移动</span></span><br><span class="line">        <span class="keyword">while</span>(root-&gt;val!=p-&gt;val &amp;&amp; root-&gt;val!=q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &lt; <span class="built_in">max</span>(p-&gt;val,q-&gt;val) &amp;&amp; root-&gt;val &gt; <span class="built_in">min</span>(p-&gt;val,q-&gt;val))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;val &lt; <span class="built_in">min</span>(q-&gt;val,p-&gt;val)?root-&gt;right:root-&gt;left;</span><br><span class="line">        &#125;<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>Morris遍历是二叉树遍历的进阶算法，相比递归（O(h)空间）和非递归栈实现（O(h)空间），它巧妙利用树中空闲指针（叶节点左右为空），将<strong>空间复杂度极限优化至O(1)</strong>，<strong>时间复杂度仍为O(N)</strong>，实现高效无栈遍历。</p>
<p>实现原则（以当前节点cur为例）：</p>
<ol>
<li>若cur无左子树，直接向右移动：cur &#x3D; cur-&gt;right。</li>
<li>若cur有左子树，找到左子树最右节点mostRight：<ul>
<li>若mostRight-&gt;right &#x3D;&#x3D; null（首次访问）：设mostRight-&gt;right &#x3D; cur，然后向左移动：cur &#x3D; cur-&gt;left。</li>
<li>若mostRight-&gt;right &#x3D;&#x3D; cur（二次访问）：恢复mostRight-&gt;right &#x3D; null，然后向右移动：cur &#x3D; cur-&gt;right。</li>
</ul>
</li>
</ol>
<p>遵循此机制，即完成Morris遍历框架。</p>
<p>实质洞察：通过临时“线索”指针（右指针线程化），确保<strong>无左子树节点访问1次</strong>，有<strong>左子树节点访问2次（首次入左、二次出左）</strong>，从而模拟递归路径而不耗额外空间。适用于<strong>前&#x2F;中&#x2F;后序遍历</strong>及衍生问题（如<strong>BST校验、最小深度、LCA</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ===== 通用Morris框架 =====</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">morrisFrame</span><span class="params">(TreeNode* head, function&lt;<span class="type">void</span>(TreeNode*)&gt; process)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;  <span class="comment">// 第一次</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 第二次</span></span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">process</span>(cur);  <span class="comment">// 自定义处理</span></span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 1. 前序遍历 (LeetCode 144) =====</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) mostRight = mostRight-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 访问</span></span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 2. 中序遍历 (LeetCode 94) =====</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">morrisFrame</span>(head, [&amp;](TreeNode* node) &#123; ans.<span class="built_in">push_back</span>(node-&gt;val); &#125;);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 3. 后序遍历 (LeetCode 145) =====</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseRightEdge</span><span class="params">(TreeNode* from, vector&lt;<span class="type">int</span>&gt;&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!from) <span class="keyword">return</span>;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* next = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* tail = from;</span><br><span class="line">    <span class="comment">// 第一遍翻转</span></span><br><span class="line">    <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">        next = tail-&gt;right;</span><br><span class="line">        tail-&gt;right = pre;</span><br><span class="line">        pre = tail;</span><br><span class="line">        tail = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pre 现在是原尾部，链已反转</span></span><br><span class="line">    <span class="comment">// 收集：从pre遍历right（反转链），得到逆序</span></span><br><span class="line">    TreeNode* cur = pre;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复：从pre（原尾）再翻转一次</span></span><br><span class="line">    tail = pre;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (tail) &#123;</span><br><span class="line">        next = tail-&gt;right;</span><br><span class="line">        tail-&gt;right = pre;</span><br><span class="line">        pre = tail;</span><br><span class="line">        tail = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 现在链恢复，原头是pre</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> ans;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) mostRight = mostRight-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="built_in">reverseRightEdge</span>(cur-&gt;left, ans);  <span class="comment">// 左边界逆序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverseRightEdge</span>(head, ans);  <span class="comment">// 根右边界逆序</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 4. 检查BST (LeetCode 98) =====</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) mostRight = mostRight-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= cur-&gt;val) valid = <span class="literal">false</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 5. 最小深度 (LeetCode 111) =====</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> preLevel = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> rightLen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            rightLen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) &#123;</span><br><span class="line">                rightLen++;</span><br><span class="line">                mostRight = mostRight-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                preLevel++;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mostRight-&gt;left) ans = <span class="built_in">min</span>(ans, preLevel);  <span class="comment">// 左无子</span></span><br><span class="line">                preLevel -= rightLen;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preLevel++;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最右叶</span></span><br><span class="line">    rightLen = <span class="number">1</span>; cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;right) &#123; rightLen++; cur = cur-&gt;right; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cur-&gt;left) ans = <span class="built_in">min</span>(ans, rightLen);</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 6. LCA (LeetCode 236) =====</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">preOrderFind</span><span class="params">(TreeNode* head, TreeNode* o1, TreeNode* o2)</span> </span>&#123;  <span class="comment">// 先序找第一个o1/o2</span></span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) mostRight = mostRight-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!res &amp;&amp; (cur == o1 || cur == o2)) res = cur;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res &amp;&amp; (cur == o1 || cur == o2)) res = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rightCheck</span><span class="params">(TreeNode* head, TreeNode* target)</span> </span>&#123;  <span class="comment">// 右边界找target</span></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        head = head-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* head, TreeNode* o1, TreeNode* o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">preOrderFind</span>(o1-&gt;left, o1, o2) || <span class="built_in">preOrderFind</span>(o1-&gt;right, o1, o2)) <span class="keyword">return</span> o1;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">preOrderFind</span>(o2-&gt;left, o1, o2) || <span class="built_in">preOrderFind</span>(o2-&gt;right, o1, o2)) <span class="keyword">return</span> o2;</span><br><span class="line">    TreeNode* left = <span class="built_in">preOrderFind</span>(head, o1, o2);</span><br><span class="line">    <span class="keyword">if</span> (!left) <span class="keyword">return</span> head;  <span class="comment">// 如果left为空，head是LCA</span></span><br><span class="line">    TreeNode* cur = head;</span><br><span class="line">    TreeNode* mostRight = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* lca = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        mostRight = cur-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight-&gt;right &amp;&amp; mostRight-&gt;right != cur) mostRight = mostRight-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (!mostRight-&gt;right) &#123;</span><br><span class="line">                mostRight-&gt;right = cur;</span><br><span class="line">                cur = cur-&gt;left; <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostRight-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span> (!lca) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">rightCheck</span>(cur-&gt;left, left)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">preOrderFind</span>(left-&gt;right, o1, o2)) lca = left;</span><br><span class="line">                        left = cur;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lca ? lca : left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 示例测试 =====</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建树: LeetCode 236 样例</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;left-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    root-&gt;left-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">8</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Preorder: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : <span class="built_in">preorderTraversal</span>(root)) cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : <span class="built_in">inorderTraversal</span>(root)) cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Postorder: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : <span class="built_in">postorderTraversal</span>(root)) cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Is BST: &quot;</span> &lt;&lt; (<span class="built_in">isValidBST</span>(root) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Min Depth: &quot;</span> &lt;&lt; <span class="built_in">minDepth</span>(root) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    TreeNode* n1 = root-&gt;left-&gt;right-&gt;left;  <span class="comment">// 7</span></span><br><span class="line">    TreeNode* n2 = root-&gt;right-&gt;left;        <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;LCA(7,8): &quot;</span> &lt;&lt; <span class="built_in">lowestCommonAncestor</span>(root, n1, n2)-&gt;val &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><h5 id="单点修改区间查询"><a href="#单点修改区间查询" class="headerlink" title="单点修改区间查询"></a>单点修改区间查询</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        v1[i] += x;</span><br><span class="line">        i += <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        ans += v1[i];</span><br><span class="line">        i -= <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">range</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(j) - <span class="built_in">get</span>(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, op, x, y; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">range</span>(x, y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="区间修改单点查询"><a href="#区间修改单点查询" class="headerlink" title="区间修改单点查询"></a>区间修改单点查询</h5><p>在单点基础上，利用一维差分，最后求从0到i的累加和即为i点的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">v1</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        v1[i] += x;</span><br><span class="line">        i += <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        ans += v1[i];</span><br><span class="line">        i -= <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">range</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(j) - <span class="built_in">get</span>(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(i, x);</span><br><span class="line">        <span class="built_in">add</span>(i + <span class="number">1</span>, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, op, x, y, z; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, z);</span><br><span class="line">            <span class="built_in">add</span>(y + <span class="number">1</span>, -z);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">range</span>(<span class="number">1</span>, x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="范围修改范围查询"><a href="#范围修改范围查询" class="headerlink" title="范围修改范围查询"></a>范围修改范围查询</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">v1</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">v2</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        v[i] += x;</span><br><span class="line">        i += <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i)&#123;</span><br><span class="line">        ans += v[i];</span><br><span class="line">        i -= <span class="built_in">low</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">range</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> j * <span class="built_in">get</span>(j, v1) - <span class="built_in">get</span>(j, v2) - ((i - <span class="number">1</span>) * <span class="built_in">get</span>(i - <span class="number">1</span>, v1) - <span class="built_in">get</span>(i <span class="number">-1</span>, v2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">long</span> <span class="type">long</span> w)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x, w, v1);</span><br><span class="line">    <span class="built_in">add</span>(y + <span class="number">1</span>, -w, v1);</span><br><span class="line">    <span class="built_in">add</span>(x, (x - <span class="number">1</span>) * w, v2);</span><br><span class="line">    <span class="built_in">add</span>(y + <span class="number">1</span>, - y * w, v2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(i, i, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, op, x, y, z; i &lt; m; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">range</span>(x,  y) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><h5 id="单点修改范围查询"><a href="#单点修改范围查询" class="headerlink" title="单点修改范围查询"></a>单点修改范围查询</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp; bit, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w, <span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">low</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">low</span>(j)) &#123;</span><br><span class="line">            bit[i][j] += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;bit, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= <span class="built_in">low</span>(i)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y; j &gt; <span class="number">0</span>; j -= <span class="built_in">low</span>(j)) &#123;</span><br><span class="line">            ans += bit[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;bit, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x1 &gt; x2 || y1 &gt; y2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(bit, x2, y2) - <span class="built_in">query</span>(bit, x1 - <span class="number">1</span>, y2) - <span class="built_in">query</span>(bit, x2, y1 - <span class="number">1</span>) + <span class="built_in">query</span>(bit, x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v1</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 原始数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bit</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 树状数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; v1[i][j];</span><br><span class="line">            <span class="built_in">add</span>(bit, i, j, v1[i][j], n, m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> x, y, w;</span><br><span class="line">    <span class="type">int</span> diff;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        cin &gt;&gt; type;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123; </span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">            diff = w - v1[x][y];</span><br><span class="line">            v1[x][y] = w;</span><br><span class="line">            <span class="built_in">add</span>(bit, x, y, diff, n, m);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">get</span>(bit, x1, y1, x2, y2) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="范围查询范围修改"><a href="#范围查询范围修改" class="headerlink" title="范围查询范围修改"></a>范围查询范围修改</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2050</span>;</span><br><span class="line"><span class="type">int</span> bit1[N][N];</span><br><span class="line"><span class="type">int</span> bit2[N][N];</span><br><span class="line"><span class="type">int</span> bit3[N][N];</span><br><span class="line"><span class="type">int</span> bit4[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a, b, c, d, w;</span><br><span class="line"><span class="type">int</span> v1, v2, v3, v4;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    v1 = v;</span><br><span class="line">    v2 = x * v;</span><br><span class="line">    v3 = y * v;</span><br><span class="line">    v4 = x * y * v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">low</span>(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y; j &lt;= m; j += <span class="built_in">low</span>(j))&#123;</span><br><span class="line">            bit1[i][j] += v1;</span><br><span class="line">            bit2[i][j] += v2;</span><br><span class="line">            bit3[i][j] += v3;</span><br><span class="line">            bit4[i][j] += v4;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">low</span>(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = y; j; j -= <span class="built_in">low</span>(j))&#123;</span><br><span class="line">            ans += (x + <span class="number">1</span>) * (y + <span class="number">1</span>) * bit1[i][j] - (y + <span class="number">1</span>) * bit2[i][j] - (x + <span class="number">1</span>) * bit3[i][j] + bit4[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x1, y1, v);</span><br><span class="line">    <span class="built_in">add</span>(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, v);</span><br><span class="line">    <span class="built_in">add</span>(x1, y2 + <span class="number">1</span>, - v);</span><br><span class="line">    <span class="built_in">add</span>(x2 + <span class="number">1</span>, y1, - v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(x2, y2) + <span class="built_in">get</span>(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>) - <span class="built_in">get</span>(x1 - <span class="number">1</span>, y2) - <span class="built_in">get</span>(x2, y1 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">char</span> C)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(C == <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c, d, w);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(C != <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">get</span>(a, b, c, d) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">char</span> C;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; C) &#123;</span><br><span class="line">        <span class="built_in">solve</span>(C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><h4 id="范围增加范围查询累加和"><a href="#范围增加范围查询累加和" class="headerlink" title="范围增加范围查询累加和"></a>范围增加范围查询累加和</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3372</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">		<span class="type">int</span> n, q;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">sum</span><span class="params">((n &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>)</span>, <span class="title">add</span><span class="params">((n &lt;&lt; <span class="number">2</span>) + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">			cin &gt;&gt; v1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">				sum[i] = v1[l];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">				<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">				sum[i] = sum[i &lt;&lt; <span class="number">1</span>] + sum[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			add[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">			sum[i] = sum[i &lt;&lt; <span class="number">1</span>] + sum[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> lazy = [&amp;](<span class="type">int</span> i, <span class="type">int</span> val, <span class="type">int</span> len)&#123;</span><br><span class="line">			sum[i] += val * len;</span><br><span class="line">			add[i] += val;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> down = [&amp;](<span class="type">int</span> i, <span class="type">int</span> lenl, <span class="type">int</span> lenr)&#123;</span><br><span class="line">			<span class="keyword">if</span>(add[i] == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">lazy</span>(i &lt;&lt; <span class="number">1</span>, add[i], lenl);</span><br><span class="line">			<span class="built_in">lazy</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, add[i], lenr);</span><br><span class="line">			add[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> add1 = [&amp;](<span class="keyword">auto</span> &amp;&amp; f,<span class="type">int</span> i, <span class="type">int</span> val, <span class="type">int</span> basel, <span class="type">int</span> baser, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(basel &lt;= l &amp;&amp; baser &gt;= r)&#123;</span><br><span class="line">				<span class="built_in">lazy</span>(i, val, r - l + <span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">down</span>(i, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">				<span class="keyword">if</span>(basel &lt;= mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, val, basel, baser, l, mid);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(baser &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, val, basel ,baser, mid + <span class="number">1</span>, r);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">up</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">		<span class="keyword">auto</span> query = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> basel, <span class="type">int</span> baser, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(basel &lt;= l &amp;&amp; baser &gt;= r)&#123;</span><br><span class="line">				<span class="keyword">return</span> sum[i];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">down</span>(i, mid - l + <span class="number">1</span>, r - mid);</span><br><span class="line">				<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(basel &lt;= mid)&#123;</span><br><span class="line">					ans += <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, basel, baser, l, mid);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(baser &gt;= mid + <span class="number">1</span>)&#123;</span><br><span class="line">					ans += <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, basel, baser, mid + <span class="number">1</span>, r);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> op;</span><br><span class="line">			cin &gt;&gt; op;</span><br><span class="line">			<span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="type">int</span> l, r, val;</span><br><span class="line">				cin &gt;&gt; l &gt;&gt; r &gt;&gt; val;</span><br><span class="line">				<span class="built_in">add1</span>(add1, <span class="number">1</span>, val, l , r, <span class="number">1</span>, n);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> l, r;</span><br><span class="line">				cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">query</span>(query, <span class="number">1</span>, l, r, <span class="number">1</span>, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有优先级调整的多范围修改任务"><a href="#有优先级调整的多范围修改任务" class="headerlink" title="有优先级调整的多范围修改任务"></a>有优先级调整的多范围修改任务</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P1253</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">		 <span class="type">int</span> n, q;</span><br><span class="line">		 cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">		 <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">change</span><span class="params">((n &lt;&lt; <span class="number">2</span>))</span>, <span class="title">max1</span><span class="params">((n &lt;&lt; <span class="number">2</span>))</span>, <span class="title">add</span><span class="params">((n &lt;&lt; <span class="number">2</span>))</span></span>;</span><br><span class="line">		 <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">has</span><span class="params">((n &lt;&lt; <span class="number">2</span>))</span></span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">		 	cin &gt;&gt; v1[i];</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">auto</span> biuld = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">		 	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">			 	 max1[i] = v1[l];</span><br><span class="line">		 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		 		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		 		<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">		 		<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">		 		max1[i] = <span class="built_in">max</span>(max1[i &lt;&lt; <span class="number">1</span>], max1[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">		 	&#125;</span><br><span class="line">		 	has[i] = <span class="literal">false</span>;</span><br><span class="line">		 	add[i] = <span class="number">0</span>;</span><br><span class="line">		 &#125;;</span><br><span class="line">		 <span class="built_in">biuld</span>(biuld, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">		 <span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">		 	max1[i] = <span class="built_in">max</span>(max1[i &lt;&lt; <span class="number">1</span>], max1[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">		 &#125;;</span><br><span class="line">		 <span class="keyword">auto</span> lazyadd = [&amp;](<span class="type">int</span> i, <span class="type">int</span> val) &#123;</span><br><span class="line">		 	max1[i] += val;</span><br><span class="line">		 	add[i] += val;</span><br><span class="line">		 &#125;;</span><br><span class="line">		 <span class="keyword">auto</span> lazyset = [&amp;](<span class="type">int</span> i, <span class="type">int</span> val) &#123;</span><br><span class="line">		 	max1[i] = val;</span><br><span class="line">		 	change[i] = val;</span><br><span class="line">		 	add[i] = <span class="number">0</span>;</span><br><span class="line">		 	has[i] = <span class="literal">true</span>;</span><br><span class="line">		 &#125;;</span><br><span class="line">		 <span class="keyword">auto</span> down = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(has[i])&#123;</span><br><span class="line">				<span class="built_in">lazyset</span>(i &lt;&lt; <span class="number">1</span>, change[i]);</span><br><span class="line">				<span class="built_in">lazyset</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, change[i]);</span><br><span class="line">				has[i] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(add[i])&#123;</span><br><span class="line">				<span class="built_in">lazyadd</span>(i &lt;&lt; <span class="number">1</span>, add[i]);</span><br><span class="line">				<span class="built_in">lazyadd</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, add[i]);</span><br><span class="line">				add[i] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;;</span><br><span class="line">		 <span class="keyword">auto</span> add1 = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> val, <span class="type">int</span> basel, <span class="type">int</span> baser, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">		 	<span class="keyword">if</span>(basel &lt;= l &amp;&amp; baser &gt;= r)&#123;</span><br><span class="line">		 		<span class="built_in">lazyadd</span>(i, val);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">down</span>(i);</span><br><span class="line">				<span class="keyword">if</span>(basel &lt;= mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, val, basel, baser, l, mid);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(baser &gt; mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, val, basel, baser, mid + <span class="number">1</span>, r);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">up</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> set = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> val, <span class="type">int</span> basel, <span class="type">int</span> baser, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(basel &lt;= l &amp;&amp; baser &gt;= r)&#123;</span><br><span class="line">				<span class="built_in">lazyset</span>(i, val);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">down</span>(i);</span><br><span class="line">				<span class="keyword">if</span>(basel &lt;= mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, val, basel, baser, l, mid);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(baser &gt; mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, val, basel, baser, mid + <span class="number">1</span>, r);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">up</span>(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> query = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> basel, <span class="type">int</span> baser, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(basel &lt;= l &amp;&amp; baser &gt;= r)&#123;</span><br><span class="line">				<span class="keyword">return</span> max1[i];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">down</span>(i);</span><br><span class="line">				<span class="type">int</span> ans = <span class="number">-1e18</span>;</span><br><span class="line">				<span class="keyword">if</span>(basel &lt;= mid)&#123;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, basel, baser, l, mid));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(baser &gt; mid)&#123;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, basel, baser, mid + <span class="number">1</span>, r));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> ans;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> op;</span><br><span class="line">			cin &gt;&gt; op;</span><br><span class="line">			<span class="type">int</span> l, r;</span><br><span class="line">			cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">			<span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">				<span class="type">int</span> x;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				<span class="built_in">add1</span>(add1, <span class="number">1</span>, x, l, r, <span class="number">1</span>, n);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="type">int</span> x;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				<span class="built_in">set</span>(set, <span class="number">1</span>, x, l, r, <span class="number">1</span>, n);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">query</span>(query, <span class="number">1</span>, l, r, <span class="number">1</span>, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><p>离散化之后要注意间隙，如覆盖问题，要在离散化之后的两个差值不为一i的数据中间添加一个数</p>
<h4 id="区间最值和历史最值"><a href="#区间最值和历史最值" class="headerlink" title="区间最值和历史最值"></a>区间最值和历史最值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P6242</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max1</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,    <span class="comment">// 区间当前最大值</span></span></span><br><span class="line"><span class="function">                    <span class="title">sec</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,     <span class="comment">// 区间严格次大值</span></span></span><br><span class="line"><span class="function">                    <span class="title">cnt</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,     <span class="comment">// 区间等于最大值的元素个数</span></span></span><br><span class="line"><span class="function">                    <span class="title">sum</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,     <span class="comment">// 区间元素和</span></span></span><br><span class="line"><span class="function">                    <span class="title">his</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,     <span class="comment">// 区间历史最大值（曾经出现过的最大值）</span></span></span><br><span class="line"><span class="function">                    <span class="title">add1</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,    <span class="comment">// 懒标记 A：对“当前最大值元素”做加法</span></span></span><br><span class="line"><span class="function">                    <span class="title">add2</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,    <span class="comment">// 懒标记 B：对“非最大值元素”做加法</span></span></span><br><span class="line"><span class="function">                    <span class="title">adds1</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span>,   <span class="comment">// 历史最大值懒标记 A</span></span></span><br><span class="line"><span class="function">                    <span class="title">adds2</span><span class="params">(n&lt;&lt;<span class="number">2</span>)</span></span>;   <span class="comment">// 历史最大值懒标记 B</span></span><br><span class="line">        <span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i)&#123;</span><br><span class="line">            sum[i] = sum[i&lt;&lt;<span class="number">1</span>] + sum[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">            his[i] = <span class="built_in">max</span>(his[i&lt;&lt;<span class="number">1</span>], his[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            max1[i] = <span class="built_in">max</span>(max1[i&lt;&lt;<span class="number">1</span>], max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 合并 cnt 与 sec</span></span><br><span class="line">            <span class="keyword">if</span>(max1[i&lt;&lt;<span class="number">1</span>] == max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])&#123;</span><br><span class="line">                cnt[i] = cnt[i&lt;&lt;<span class="number">1</span>] + cnt[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">                sec[i] = <span class="built_in">max</span>(sec[i&lt;&lt;<span class="number">1</span>], sec[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(max1[i&lt;&lt;<span class="number">1</span>] &gt; max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])&#123;</span><br><span class="line">                cnt[i] = cnt[i&lt;&lt;<span class="number">1</span>];</span><br><span class="line">                sec[i] = <span class="built_in">max</span>(sec[i&lt;&lt;<span class="number">1</span>], max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[i] = cnt[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">                sec[i] = <span class="built_in">max</span>(sec[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>], max1[i&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                <span class="type">int</span> x;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                max1[i] = sum[i] = his[i] = x;  <span class="comment">// 当前值、区间和值、历史最大均为 x</span></span><br><span class="line">                cnt[i] = <span class="number">1</span>;                     <span class="comment">// 只有一个元素</span></span><br><span class="line">                sec[i] = LLONG_MIN / <span class="number">2</span>;         <span class="comment">// 次大值设为 -INF（用很小的数）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, l, mid);</span><br><span class="line">                <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">                <span class="built_in">up</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 懒标记初始为 0</span></span><br><span class="line">            add1[i] = add2[i] = adds1[i] = adds2[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">        <span class="comment">// 核心懒标记下发函数</span></span><br><span class="line">        <span class="comment">// val1: 加到“当前最大值元素”上的增量</span></span><br><span class="line">        <span class="comment">// val2: 加到“非最大值元素”上的增量</span></span><br><span class="line">        <span class="comment">// val3/val4: 用于更新历史最大值的增量</span></span><br><span class="line">        <span class="comment">// len: 本区间长度</span></span><br><span class="line">        <span class="keyword">auto</span> lazy = [&amp;](<span class="type">int</span> i, <span class="type">int</span> val1, <span class="type">int</span> val2, <span class="type">int</span> val3, <span class="type">int</span> val4, <span class="type">int</span> len)&#123;</span><br><span class="line">            <span class="comment">// 更新历史最大值</span></span><br><span class="line">            his[i] = <span class="built_in">max</span>(his[i], max1[i] + val3);</span><br><span class="line">            <span class="comment">// 更新子树的历史懒标记</span></span><br><span class="line">            adds1[i] = <span class="built_in">max</span>(adds1[i], add1[i] + val3);</span><br><span class="line">            adds2[i] = <span class="built_in">max</span>(adds2[i], add2[i] + val4);</span><br><span class="line">            <span class="comment">// 区间和更新</span></span><br><span class="line">            sum[i] += val1 * cnt[i] + val2 * (len - cnt[i]);</span><br><span class="line">            <span class="comment">// 更新“当前最大值”与“非最大值”懒标记</span></span><br><span class="line">            add1[i] += val1;</span><br><span class="line">            add2[i] += val2;</span><br><span class="line">            <span class="comment">// 更新当前最大值</span></span><br><span class="line">            max1[i] += val1;</span><br><span class="line">            <span class="comment">// 次大值也需加 val2（若不存在则保持 -INF）</span></span><br><span class="line">            <span class="keyword">if</span>(sec[i] &gt; LLONG_MIN/<span class="number">2</span>) sec[i] += val2;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 下推函数：将 i 节点的懒标记传递给左右子节点</span></span><br><span class="line">        <span class="keyword">auto</span> down = [&amp;](<span class="type">int</span> i, <span class="type">int</span> lenL, <span class="type">int</span> lenR)&#123;</span><br><span class="line">            <span class="comment">// 左右子节点新的“当前最大”值</span></span><br><span class="line">            <span class="type">int</span> tL = max1[i&lt;&lt;<span class="number">1</span>], tR = max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 父节点最高值</span></span><br><span class="line">            <span class="type">int</span> mx = <span class="built_in">max</span>(max1[i&lt;&lt;<span class="number">1</span>], max1[i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 左子树</span></span><br><span class="line">            <span class="keyword">if</span>(tL == mx)&#123;</span><br><span class="line">                <span class="comment">// 左子树中有父区间最大值元素</span></span><br><span class="line">                <span class="built_in">lazy</span>(i&lt;&lt;<span class="number">1</span>, add1[i], add2[i], adds1[i], adds2[i], lenL);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左子树中只有“非最大值”元素</span></span><br><span class="line">                <span class="built_in">lazy</span>(i&lt;&lt;<span class="number">1</span>, add2[i], add2[i], adds2[i], adds2[i], lenL);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子树（同理）</span></span><br><span class="line">            <span class="keyword">if</span>(tR == mx)&#123;</span><br><span class="line">                <span class="built_in">lazy</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, add1[i], add2[i], adds1[i], adds2[i], lenR);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">lazy</span>(i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, add2[i], add2[i], adds2[i], adds2[i], lenR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空父节点懒标记</span></span><br><span class="line">            add1[i] = add2[i] = adds1[i] = adds2[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 区间加法 [bl,br] 全加 val</span></span><br><span class="line">        <span class="keyword">auto</span> addRange = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bl &lt;= l &amp;&amp; r &lt;= br)&#123;</span><br><span class="line">                <span class="comment">// 统一打懒标记，val1=val2=val3=val4=val</span></span><br><span class="line">                <span class="built_in">lazy</span>(i, val, val, val, val, r-l+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">down</span>(i, mid-l+<span class="number">1</span>, r-mid);</span><br><span class="line">                <span class="keyword">if</span>(bl &lt;= mid)      <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, bl, br, val, l, mid);</span><br><span class="line">                <span class="keyword">if</span>(br &gt; mid)       <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, bl, br, val, mid+<span class="number">1</span>, r);</span><br><span class="line">                <span class="built_in">up</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 区间 chmin：把区间内所有大于 val 的值降到 val</span></span><br><span class="line">        <span class="keyword">auto</span> chminRange = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(max1[i] &lt;= val) <span class="keyword">return</span>;  <span class="comment">// 本区间最大值已 ≤ val，无需操作</span></span><br><span class="line">            <span class="keyword">if</span>(bl &lt;= l &amp;&amp; r &lt;= br &amp;&amp; sec[i] &lt; val)&#123;</span><br><span class="line">                <span class="comment">// 全区间最大值都大于 val，且次大值 &lt; val</span></span><br><span class="line">                <span class="comment">// 只需把“最大值元素”降到 val</span></span><br><span class="line">                <span class="built_in">lazy</span>(i, val-max1[i], <span class="number">0</span>, val-max1[i], <span class="number">0</span>, r-l+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">down</span>(i, mid-l+<span class="number">1</span>, r-mid);</span><br><span class="line">                <span class="keyword">if</span>(bl &lt;= mid)      <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, bl, br, val, l, mid);</span><br><span class="line">                <span class="keyword">if</span>(br &gt; mid)       <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, bl, br, val, mid+<span class="number">1</span>, r);</span><br><span class="line">                <span class="built_in">up</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 区间求和</span></span><br><span class="line">        <span class="keyword">auto</span> querySum = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bl &lt;= l &amp;&amp; r &lt;= br)&#123;</span><br><span class="line">                <span class="keyword">return</span> sum[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">down</span>(i, mid-l+<span class="number">1</span>, r-mid);</span><br><span class="line">                <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(bl &lt;= mid)    res += <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, bl, br, l, mid);</span><br><span class="line">                <span class="keyword">if</span>(br &gt; mid)     res += <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, bl, br, mid+<span class="number">1</span>, r);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 区间最大值</span></span><br><span class="line">        <span class="keyword">auto</span> queryMax = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bl &lt;= l &amp;&amp; r &lt;= br)&#123;</span><br><span class="line">                <span class="keyword">return</span> max1[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">down</span>(i, mid-l+<span class="number">1</span>, r-mid);</span><br><span class="line">                <span class="type">int</span> res = LLONG_MIN/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(bl &lt;= mid)    res = <span class="built_in">max</span>(res, <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, bl, br, l, mid));</span><br><span class="line">                <span class="keyword">if</span>(br &gt; mid)     res = <span class="built_in">max</span>(res, <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, bl, br, mid+<span class="number">1</span>, r));</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 区间历史最大值</span></span><br><span class="line">        <span class="keyword">auto</span> queryHis = [&amp;](<span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(bl &lt;= l &amp;&amp; r &lt;= br)&#123;</span><br><span class="line">                <span class="keyword">return</span> his[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">down</span>(i, mid-l+<span class="number">1</span>, r-mid);</span><br><span class="line">                <span class="type">int</span> res = LLONG_MIN/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(bl &lt;= mid)    res = <span class="built_in">max</span>(res, <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>, bl, br, l, mid));</span><br><span class="line">                <span class="keyword">if</span>(br &gt; mid)     res = <span class="built_in">max</span>(res, <span class="built_in">self</span>(self, i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, bl, br, mid+<span class="number">1</span>, r));</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 处理 m 次操作</span></span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="type">int</span> op, l, r;</span><br><span class="line">            cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">                <span class="built_in">addRange</span>(addRange, <span class="number">1</span>, l, r, x, <span class="number">1</span>, n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">                <span class="built_in">chminRange</span>(chminRange, <span class="number">1</span>, l, r, x, <span class="number">1</span>, n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">querySum</span>(querySum, <span class="number">1</span>, l, r, <span class="number">1</span>, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">queryMax</span>(queryMax, <span class="number">1</span>, l, r, <span class="number">1</span>, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>)&#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">queryHis</span>(queryHis, <span class="number">1</span>, l, r, <span class="number">1</span>, n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合摩尔投票"><a href="#结合摩尔投票" class="headerlink" title="结合摩尔投票"></a>结合摩尔投票</h4><h5 id="经典摩尔投票，求数组中出现次数大于-frac-n-2-d-数"><a href="#经典摩尔投票，求数组中出现次数大于-frac-n-2-d-数" class="headerlink" title="经典摩尔投票，求数组中出现次数大于$\frac{n}{2}$d 数"></a>经典摩尔投票，求数组中出现次数大于$\frac{n}{2}$d 数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  		<span class="type">int</span> now = <span class="number">-1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  		<span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">  			<span class="keyword">if</span>(!cnt)&#123;</span><br><span class="line">  				now = x;</span><br><span class="line">  				cnt = <span class="number">1</span>;</span><br><span class="line">  			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  				<span class="keyword">if</span>(now == x)&#123;</span><br><span class="line">  					cnt ++;</span><br><span class="line">  				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  					cnt --;</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="结合线段树求区间海王数"><a href="#结合线段树求区间海王数" class="headerlink" title="结合线段树求区间海王数"></a>结合线段树求区间海王数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://leetcode.cn/problems/online-majority-element-in-subarray/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MajorityChecker</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; val, cnt, v1;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; v2;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!cnt[i &lt;&lt; <span class="number">1</span>] &amp;&amp; !cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>])&#123;</span><br><span class="line">			cnt[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!cnt[i &lt;&lt; <span class="number">1</span>])&#123;</span><br><span class="line">			cnt[i] = cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">			val[i] = val[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>])&#123;</span><br><span class="line">			cnt[i] = cnt[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">			val[i] = val[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(val[i &lt;&lt; <span class="number">1</span>] == val[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>])&#123;</span><br><span class="line">				val[i] = val[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">				cnt[i] = cnt[i &lt;&lt; <span class="number">1</span>] + cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(cnt[i &lt;&lt; <span class="number">1</span>] &gt;= cnt[i &lt;&lt; <span class="number">1</span>| <span class="number">1</span>])&#123;</span><br><span class="line">					val[i] = val[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">					cnt[i] = cnt[i &lt;&lt; <span class="number">1</span>] - cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					val[i] = val[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">					cnt[i] = cnt[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] - cnt[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">			cnt[i] = <span class="number">1</span>;</span><br><span class="line">			val[i] = v1[l];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">build</span>(i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">			<span class="built_in">build</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">			<span class="built_in">up</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">get</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(bl &lt;= l &amp;&amp; br &gt;= r)&#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;val[i], cnt[i]&#125;;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; left = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, right = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line">			<span class="keyword">if</span>(bl &lt;= mid)&#123;</span><br><span class="line">				left = <span class="built_in">get</span>(i &lt;&lt; <span class="number">1</span>, bl, br, l, mid);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(br &gt; mid)&#123;</span><br><span class="line">				right = <span class="built_in">get</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, bl, br, mid + <span class="number">1</span>, r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!left.sc &amp;&amp; !right.sc)&#123;</span><br><span class="line">				ans.sc = <span class="number">0</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!left.sc)&#123;</span><br><span class="line">				ans.fr = right.fr;</span><br><span class="line">				ans.sc = right.sc;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!right.sc)&#123;</span><br><span class="line">				ans.fr = left.fr;</span><br><span class="line">				ans.sc = left.sc;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(left.fr == right.fr)&#123;</span><br><span class="line">					ans.fr = left.fr;</span><br><span class="line">					ans.sc = left.sc + right.sc;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span>(left.sc &gt;= right.sc)&#123;</span><br><span class="line">						ans.fr = left.fr;</span><br><span class="line">						ans.sc = left.sc - right.sc;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						ans.fr = right.fr;</span><br><span class="line">						ans.sc = right.sc - left.sc;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> in)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> mid, ans = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">			mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(v2[mid].fr &gt; x)&#123;</span><br><span class="line">				r = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v2[mid].fr &lt; x)&#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(v2[mid].sc &gt;= in)&#123;</span><br><span class="line">                    				ans = mid;</span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> in)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> mid, ans = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">			mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(v2[mid].fr &gt; x)&#123;</span><br><span class="line">				r = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(v2[mid].fr &lt; x)&#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span>(v2[mid].sc &lt;= in)&#123;</span><br><span class="line">                    				ans = mid;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="built_in">MajorityChecker</span>(vector&lt;<span class="type">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">    	v1.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)&#123;</span><br><span class="line">    		v1.<span class="built_in">push_back</span>(x);</span><br><span class="line">    	&#125;</span><br><span class="line">     	n = arr.<span class="built_in">size</span>();</span><br><span class="line">     	val.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">2</span>);</span><br><span class="line">     	cnt.<span class="built_in">resize</span>(n &lt;&lt; <span class="number">2</span>); </span><br><span class="line">     	<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">     	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">     		v2.<span class="built_in">push_back</span>(&#123;v1[i], i&#125;);</span><br><span class="line">     	&#125;</span><br><span class="line">     	<span class="built_in">sort</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)&#123;</span><br><span class="line">     		<span class="keyword">if</span>(a.fr == b.fr)&#123;</span><br><span class="line">     			<span class="keyword">return</span> a.sc &lt; b.sc;</span><br><span class="line">     		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     			<span class="keyword">return</span> a.fr &lt; b.fr;</span><br><span class="line">     		&#125;</span><br><span class="line">     	&#125;);</span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; n; i ++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; v2[i].fr &lt;&lt; &quot; &quot; &lt;&lt; v2[i].sc &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">    	left ++, right ++;</span><br><span class="line">    	pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; temp = <span class="built_in">get</span>(<span class="number">1</span>, left, right, <span class="number">1</span>, n);</span><br><span class="line">    	<span class="keyword">if</span>(temp.sc == <span class="number">0</span>)&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; temp.fr &lt;&lt; &quot; &quot; &lt;&lt;  temp.sc &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    	<span class="type">int</span> l = <span class="built_in">find</span>(temp.fr, left), r = <span class="built_in">find2</span>(temp.fr, right);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;L; &quot; &lt;&lt;  left &lt;&lt; &quot; R: &quot; &lt;&lt; right &lt;&lt; &quot; l1: &quot; &lt;&lt; l &lt;&lt; &quot; r1: &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;; </span></span><br><span class="line">    	<span class="keyword">return</span> (r - l + <span class="number">1</span>) &gt;= threshold ? temp.fr : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="求一个数组中某一个区间出现了某个数的次数"><a href="#求一个数组中某一个区间出现了某个数的次数" class="headerlink" title="求一个数组中某一个区间出现了某个数的次数"></a>求一个数组中某一个区间出现了某个数的次数</h5><p>参考上面摩尔投票结合线段树的例子，将一个数组按照数的大小和出现顺序升序排序，然后用不同逻辑的二分查找得到相对位置</p>
<h4 id="查询最值以及出现位置"><a href="#查询最值以及出现位置" class="headerlink" title="查询最值以及出现位置"></a>查询最值以及出现位置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108307/F</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">p</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">W</span><span class="params">(N &lt;&lt; <span class="number">2</span> | <span class="number">1</span>)</span>, <span class="title">add1</span><span class="params">(N &lt;&lt; <span class="number">2</span> | <span class="number">1</span>)</span>, <span class="title">P</span><span class="params">(N &lt;&lt; <span class="number">2</span> | <span class="number">1</span>)</span>, <span class="title">L</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    	add1[i] = W[i] = <span class="number">0</span>;</span><br><span class="line">    	P[i] = r;</span><br><span class="line">    	<span class="keyword">if</span>(l != r) &#123;</span><br><span class="line">    		<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    		<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    		<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(W[i &lt;&lt; <span class="number">1</span>] &gt;= W[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) W[i] = W[i &lt;&lt; <span class="number">1</span>], P[i] = P[i &lt;&lt; <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">else</span> W[i] = W[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], P[i] = P[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="keyword">auto</span> lazy = [&amp;](<span class="type">int</span> i, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    	W[i] += w, add1[i] += w;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> down = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    	<span class="built_in">lazy</span>(i &lt;&lt; <span class="number">1</span>, add1[i]), <span class="built_in">lazy</span>(i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, add1[i]);</span><br><span class="line">    	add1[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(l &gt;= L &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="built_in">lazy</span>(i, w);</span><br><span class="line">    	<span class="built_in">down</span>(i);</span><br><span class="line">    	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span>(L &lt;= mid) <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, l, mid, L, R, w);</span><br><span class="line">    	<span class="keyword">if</span>(R &gt; mid) <span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, L, R, w);</span><br><span class="line">    	<span class="built_in">up</span>(i);</span><br><span class="line">    &#125;;</span><br><span class="line">   	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    	<span class="built_in">fill</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">begin</span>() + <span class="number">1</span> + n, n + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i ++) &#123;</span><br><span class="line">			cin &gt;&gt; v1[i];</span><br><span class="line">			<span class="keyword">if</span>(p[v1[i]]) r[p[v1[i]]] = i;</span><br><span class="line">			p[v1[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; r[i] &lt;&lt; &quot; &quot; &lt;&lt; p[v1[i]] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>, ans_l = <span class="number">2</span>, ans_r = <span class="number">3</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span></span><br><span class="line">			<span class="keyword">if</span>(L[v1[i]]) <span class="built_in">add</span>(add, <span class="number">1</span>, <span class="number">1</span>, n, L[v1[i]], p[v1[i]], <span class="number">-1</span>);</span><br><span class="line">			L[v1[i]] = r[i] + <span class="number">1</span>;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; L[v1[i]] &lt;&lt; &quot; &quot; &lt;&lt; p[v1[i]] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">			<span class="built_in">add</span>(add, <span class="number">1</span>, <span class="number">1</span>, n, L[v1[i]], p[v1[i]], <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// cout &lt;&lt; W[1] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">			<span class="keyword">if</span>(ans &lt; W[<span class="number">1</span>]) ans = W[<span class="number">1</span>], ans_l = i + <span class="number">1</span>, ans_r = P[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; ans_l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans_r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) p[v1[i]] = L[v1[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稀疏表ST"><a href="#稀疏表ST" class="headerlink" title="稀疏表ST"></a>稀疏表ST</h3><p>**Sparse Table（稀疏表）**是一种高效的数据结构，主要用于 <strong>静态数组的区间最值查询（RMQ）</strong>。</p>
<ul>
<li>适用于：<strong>查询频繁，修改不需要或很少</strong></li>
<li>查询时间复杂度：<strong>O(1)</strong></li>
<li>预处理时间复杂度：<strong>O(n log n)</strong></li>
</ul>
<p>支持的运算</p>
<p>Sparse Table 支持 <strong>幂等操作（idempotent operations）</strong>：</p>
<p>可以求<code>min()</code> 、<code>max()</code> 、<code>gcd()</code> </p>
<p>不可求<code>lcm()</code> （不满足幂等性）、<code>sum()</code> （不满足幂等性）</p>
<p>核心构建流程（以最大值为例）</p>
<ol>
<li>定义</li>
</ol>
<ul>
<li><code>st[i][j]</code> 表示从 <strong>下标 i 开始，长度为 2^j 的区间最大值</strong></li>
</ul>
<ol start="2">
<li>初始化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    st[i][<span class="number">0</span>] = arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>状态转移</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">        st[i][j] = <span class="built_in">max</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预处理 log2 表</p>
<p>为什么要提前预处理 <code>log2[]</code>？</p>
<p>查询时需计算区间长度对应的 <code>log2(r - l + 1)</code>，预处理可避免浮点误差和时间浪费</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    log2[i] = log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间查询（以最大值为例）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> k = log2[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br></pre></td></tr></table></figure>

<p>这个查询方式的核心是使用<strong>两个长度为 <code>2^k</code> 的区间覆盖整个 <code>[l, r]</code> 区间</strong>。</p>
<p>Luogu P4155：环形区间覆盖跳跃优化</p>
<p>**目标：**给定一系列区间，在环上查找覆盖长度为 <code>m</code> 所需的最少跳跃次数（倍增思想）</p>
<p><strong>关键用法：</strong></p>
<ul>
<li><code>st[i][j]</code> 表示从第 <code>i</code> 个区间开始，跳 <code>2^j</code> 步可覆盖到的位置</li>
</ul>
<p><strong>构建：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">st[i][<span class="number">0</span>] = rightmost reachable from i</span><br><span class="line">st[i][j] = st[st[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p><strong>查询：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = logn; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v1[st[cur][j]][<span class="number">2</span>] &lt; goal) &#123;</span><br><span class="line">        cur = st[cur][j];</span><br><span class="line">        ans += <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 Sparse Table 进行跳跃优化（倍增思想）</p>
<p>每次跳跃代表一段区间，用于计算覆盖长度最少的路径</p>
<p>模板封装（最值查询）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>, LOG = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> st[N][LOG], log2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_st</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    log2[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        st[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        log2[i] = log2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            st[i][j] = <span class="built_in">max</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = log2[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h3><p>最近祖先问题，用于快速查询树中两个节点的最近公共祖先。</p>
<h4 id="采用deep数组和st表"><a href="#采用deep数组和st表" class="headerlink" title="采用deep数组和st表"></a>采用deep数组和st表</h4><p>deep数组用于记录深度，st表用于快速查询父亲及以上节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3379</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n, m, root;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; root;</span><br><span class="line">		<span class="function">vector <span class="title">adj</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;  i &lt; n; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> u, v;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 构建LCA结构</span></span><br><span class="line">		<span class="type">int</span> n1 = <span class="built_in">log2</span>(n);</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deep</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="function">vector <span class="title">st</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(n1 + <span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> d) -&gt; <span class="type">void</span>&#123;</span><br><span class="line">			deep[u] = d;</span><br><span class="line">			st[u][<span class="number">0</span>] = last;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++)&#123;</span><br><span class="line">				st[u][i] = st[st[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">				<span class="keyword">if</span>(v != last)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, v, u, d + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">dfs</span>(dfs, root, root, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> u, v;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			<span class="comment">// 查询公共祖先部分部分</span></span><br><span class="line">            <span class="comment">// 先统一高度</span></span><br><span class="line">			<span class="keyword">if</span>(deep[u] &lt; deep[v])&#123;</span><br><span class="line">				<span class="built_in">swap</span>(u, v);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = n1; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">				<span class="keyword">if</span>(deep[st[u][j]] &gt;= deep[v])&#123;</span><br><span class="line">					u = st[u][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 特判</span></span><br><span class="line">			<span class="keyword">if</span>(u == v)&#123;</span><br><span class="line">				cout &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = n1; j &gt;= <span class="number">0</span>; j --)&#123;</span><br><span class="line">					<span class="keyword">if</span>(st[u][j] != st[v][j])&#123;</span><br><span class="line">						u = st[u][j];</span><br><span class="line">						v = st[v][j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; st[u][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h4><p>利用并查集来一次dfs就构建好lca信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3379</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n, m, root;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; root;</span><br><span class="line">		<span class="function">vector <span class="title">adj</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i ++)&#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">			adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">vector <span class="title">adj2</span><span class="params">(m + <span class="number">1</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;())</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i ++)&#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			adj2[u].<span class="built_in">push_back</span>(&#123;v, i&#125;);</span><br><span class="line">			adj2[v].<span class="built_in">push_back</span>(&#123;u, i&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vi</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">			fa[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> find = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(x != fa[x])&#123;</span><br><span class="line">				fa[x] = <span class="built_in">f</span>(f, fa[x]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fa[x];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> tarjin = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			vi[u] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">				<span class="keyword">if</span>(v != last)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, v, u);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> [v, n1] : adj2[u])&#123;</span><br><span class="line">				<span class="keyword">if</span>(vi[v])&#123;</span><br><span class="line">					ans[n1] = <span class="built_in">find</span>(find, v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fa[u] = last;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">tarjin</span>(tarjin, root, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.luogu.com.cn/problem/P3379">练习题</a></p>
<h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>如果在树中选择某个节点并删除，这棵树将分为若干棵子树，使所有子树最大值最小的节点被称为整个树的重心。</p>
<p>性质：</p>
<ul>
<li>树的重心如果不唯一，则至多有两个，且这两个重心相邻。</li>
<li>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。</li>
<li>树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。</li>
<li>把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。</li>
<li>在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> head[N] ,next1[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> size1[N], max1[N];</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	next1[cnt1] = head[u];</span><br><span class="line">	to[cnt1] = v;</span><br><span class="line">	head[u] = cnt1 ++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> last)</span></span>&#123;</span><br><span class="line">	size1[u] = <span class="number">1</span>;</span><br><span class="line">	max1[u] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei])&#123;</span><br><span class="line">		v = to[ei];</span><br><span class="line">		<span class="keyword">if</span>(v != last)&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v, u);</span><br><span class="line">			max1[u] = <span class="built_in">max</span>(max1[u], size1[v]);</span><br><span class="line">			size1[u] += size1[v];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	max1[u] = <span class="built_in">max</span>(max1[u], n - size1[u]);;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="built_in">fill</span>(head, head + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> u, v;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			<span class="built_in">add</span>(u, v);</span><br><span class="line">			<span class="built_in">add</span>(v, u);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="type">int</span> ans[<span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="comment">// 依照树的重心的定义</span></span><br><span class="line">			<span class="keyword">if</span>(max1[i] &lt;= n &gt;&gt; <span class="number">1</span>)&#123;</span><br><span class="line">				ans[m ++] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">			cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当节点有值时，重心的依据是节点权而不是边权。</p>
<h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><p>树上任意两点之间最常的简单路径为树的直径，一棵树可以有多条直径，长度相等</p>
<h4 id="两次DFS"><a href="#两次DFS" class="headerlink" title="两次DFS"></a>两次DFS</h4><p>适用与无负边树</p>
<p>首先从任意节点 y 开始进行第一次 DFS，到达距离其最远的节点，记为 z，然后再从z 开始做第二次 DFS，到达距离z最远的节点，记为z’，则 $\delta(z,z’)$ 即为树的直径。</p>
<p>显然，如果第一次 DFS 到达的节点z是直径的一端，那么第二次 DFS 到达的节点z’一定是直径的一端。我们只需证明在任意情况下，z必为直径的一端。</p>
<p>定理：在一棵树上，从任意节点y开始进行一次 DFS，到达的距离其最远的节点z必为直径的一端。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">weight</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 两次DFS</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">fa</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">len</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> st, en;</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> val) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    dis[u] = val;</span><br><span class="line">    fa[u] = last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ei = head[u], v, w; ei; ei = next[ei])&#123;</span><br><span class="line">        v = to[ei];</span><br><span class="line">        w = weight[ei];</span><br><span class="line">        <span class="keyword">if</span>(v != last)&#123;</span><br><span class="line">            len[v] = w;</span><br><span class="line">            <span class="built_in">f</span>(f, v, u, val + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, max1 = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max1 &lt; dis[i])&#123;</span><br><span class="line">        max1 = dis[i];</span><br><span class="line">        dis[i] = len[i] = <span class="number">0</span>;</span><br><span class="line">        st = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(dfs, st, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, max1 = <span class="number">0</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max1 &lt; dis[i])&#123;</span><br><span class="line">        max1 = dis[i];</span><br><span class="line">        en = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum1 = dis[en]; <span class="comment">// 直径</span></span><br></pre></td></tr></table></figure>

<h4 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h4><p>可用于有负边树</p>
<p>我们记录当1为树的根时，每个节点作为子树的根向下，所能延伸的最长路径长度$d_{1}$与次长路径（与最长路径无公共边）$d_{2}$，那么直径就是对于每一个点，该点的$d_{1}+d_{2}$能取到的最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head1</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next1</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to1</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">weight</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line">cnt1 = <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span>，<span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dfs3 = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    ans[u] = <span class="number">0</span>, v1[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ei = head1[u], v, w; ei; ei = next1[ei])&#123;</span><br><span class="line">        v = to1[ei], w = weight[ei];</span><br><span class="line">        <span class="keyword">if</span>(v != last)&#123;</span><br><span class="line">            <span class="built_in">f</span>(f, v, u);</span><br><span class="line">            ans[u] = <span class="built_in">max</span>(ans[u], v1[u] + v1[v] + w);</span><br><span class="line">            v1[u] = <span class="built_in">max</span>(v1[u], v1[v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">dfs3</span>(dfs3, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> max2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    max2 = <span class="built_in">max</span>(max2, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树上差分"><a href="#树上差分" class="headerlink" title="树上差分"></a>树上差分</h3><p>在树上对多条路径上的点或者边进行修改时，不能直接便利操作，而是利用差分思想积累信息，最后累加</p>
<ul>
<li>对于点，路径两端++,两端LCA和LCA的父亲–</li>
<li>对于边，路径两端++,其值可理解为该点到其父亲的边，两端LCA-&#x3D;2</li>
</ul>
<h4 id="点差分"><a href="#点差分" class="headerlink" title="点差分"></a>点差分</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3128</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e4</span>, K = <span class="number">1e5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next1</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head2</span><span class="params">(K + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next2</span><span class="params">(K &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to2</span><span class="params">(K &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">in</span><span class="params">(K &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa_lca</span><span class="params">(K + <span class="number">1</span>)</span>, <span class="title">lca</span><span class="params">(K + <span class="number">1</span>)</span>, <span class="title">has</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">fa</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt1 = <span class="number">1</span>, cnt2 = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">   	 <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --)&#123; </span><br><span class="line">		<span class="type">int</span> n, q;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">		<span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> i, <span class="type">int</span> f) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!f) &#123;</span><br><span class="line">				next1[cnt1] = head[u];</span><br><span class="line">				to[cnt1] = v;</span><br><span class="line">				head[u] = cnt1 ++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				next2[cnt2] = head2[u];</span><br><span class="line">				to2[cnt2] = v;</span><br><span class="line">				in[cnt2] = i;</span><br><span class="line">				head2[u] = cnt2 ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i ++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			<span class="built_in">add</span>(u, v, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">add</span>(v, u, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">iota</span>(fa_lca.<span class="built_in">begin</span>() + <span class="number">1</span>, fa_lca.<span class="built_in">begin</span>() + <span class="number">1</span> + q, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">auto</span> find = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(x != fa_lca[x]) fa_lca[x] = <span class="built_in">f</span>(f, fa_lca[x]);</span><br><span class="line">			<span class="keyword">return</span> fa_lca[x];</span><br><span class="line">		&#125;;</span><br><span class="line">		vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(q);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, u, v; i &lt; q; i ++) &#123;</span><br><span class="line">			cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">			edges[i] = &#123;u, v&#125;;</span><br><span class="line">			<span class="built_in">add</span>(u, v, i, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">add</span>(v, u, i, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> tarjan = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			has[u] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">				v = to[ei];</span><br><span class="line">				<span class="keyword">if</span>(v != last) <span class="built_in">f</span>(f, v, u);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ei = head2[u], v; ei; ei = next2[ei]) &#123;</span><br><span class="line">				v = to2[ei];</span><br><span class="line">				<span class="comment">// 注意lca的编号是in[ei]而不是v或者ei</span></span><br><span class="line">				<span class="keyword">if</span>(has[v]) lca[in[ei]] = <span class="built_in">find</span>(find, v);</span><br><span class="line">			&#125;</span><br><span class="line">			fa[u] = last;</span><br><span class="line">			fa_lca[u] = last;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">// 跑lca</span></span><br><span class="line">		<span class="built_in">tarjan</span>(tarjan, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 差分</span></span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++) &#123;</span><br><span class="line">			ans[edges[i].fr] ++, ans[edges[i].sc] ++;</span><br><span class="line">			ans[lca[i]] --, ans[fa[lca[i]]] --;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> last) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">				v = to[ei];</span><br><span class="line">				<span class="keyword">if</span>(v != last) &#123;</span><br><span class="line">					<span class="built_in">f</span>(f, v, u);</span><br><span class="line">					ans[u] += ans[v];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">        <span class="comment">// 跑差分</span></span><br><span class="line">		<span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> max1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ans[i] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">			max1 = <span class="built_in">max</span>(max1, ans[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; max1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="边差分"><a href="#边差分" class="headerlink" title="边差分"></a>边差分</h4><blockquote>
<p>Tarjan</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2680</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>; <span class="comment">// 题目只有一组数据</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123; </span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 树的邻接表存储</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next1</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">wei</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 查询图（用于 Tarjan 离线 LCA）</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head2</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next2</span><span class="params">(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to2</span><span class="params">(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">in</span><span class="params">(m &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 各种辅助数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">len</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">has</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">fa_lca</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">lca</span><span class="params">(m)</span>, <span class="title">cost</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">1</span>, cnt2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加边（树边）</span></span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) &#123;</span><br><span class="line">            next1[cnt1] = head[u];</span><br><span class="line">            to[cnt1] = v;</span><br><span class="line">            wei[cnt1] = w;</span><br><span class="line">            head[u] = cnt1++;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加边（查询边）</span></span><br><span class="line">        <span class="keyword">auto</span> add2 = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> i) &#123;</span><br><span class="line">            next2[cnt2] = head2[u];</span><br><span class="line">            to2[cnt2] = v;</span><br><span class="line">            in[cnt2] = i;</span><br><span class="line">            head2[u] = cnt2++;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(u, v, w);</span><br><span class="line">            <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max1 = <span class="number">0</span>; <span class="comment">// 最大路径长度</span></span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">edges</span>(m);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读入运输任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            cin &gt;&gt; edges[i][<span class="number">0</span>] &gt;&gt; edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">add2</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>], i);</span><br><span class="line">            <span class="built_in">add2</span>(edges[i][<span class="number">1</span>], edges[i][<span class="number">0</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集 find</span></span><br><span class="line">        <span class="keyword">auto</span> find = [&amp;](<span class="keyword">auto</span> &amp;&amp;f, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x != fa_lca[x]) fa_lca[x] = <span class="built_in">f</span>(f, fa_lca[x]);</span><br><span class="line">            <span class="keyword">return</span> fa_lca[x];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">iota</span>(fa_lca.<span class="built_in">begin</span>(), fa_lca.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tarjan 离线 LCA</span></span><br><span class="line">        <span class="keyword">auto</span> tarjan = [&amp;](<span class="keyword">auto</span> &amp;&amp;f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            len[u] = w;    <span class="comment">// 从根到 u 的距离</span></span><br><span class="line">            has[u] = <span class="number">1</span>;    <span class="comment">// 标记已访问</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历树的子节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                <span class="keyword">if</span> (v != last) <span class="built_in">f</span>(f, v, u, w + wei[ei]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历与 u 有关的查询</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head2[u], v; ei; ei = next2[ei]) &#123;</span><br><span class="line">                v = to2[ei];</span><br><span class="line">                <span class="keyword">if</span> (has[v]) &#123;</span><br><span class="line">                    lca[in[ei]] = <span class="built_in">find</span>(find, v); <span class="comment">// 找到 LCA</span></span><br><span class="line">                    <span class="comment">// 路径长度 = len[u] + len[v] - 2 * len[lca]</span></span><br><span class="line">                    cost[in[ei]] = len[v] + len[u] - <span class="number">2</span> * len[lca[in[ei]]];</span><br><span class="line">                    max1 = <span class="built_in">max</span>(max1, cost[in[ei]]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fa_lca[u] = last; <span class="comment">// 回溯并查集父节点</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">tarjan</span>(tarjan, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 从根节点 1 开始</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分答案</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = max1, ans = <span class="number">0</span>, mid;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt, need;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查函数（判断是否能在限制 x 下完成任务）</span></span><br><span class="line">        <span class="keyword">auto</span> cf = [&amp;](<span class="keyword">auto</span> &amp;&amp;f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> w) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                <span class="keyword">if</span> (v != last) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">f</span>(f, v, u, wei[ei])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    num[u] += num[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num[u] == cnt &amp;&amp; w &gt;= need; <span class="comment">// 判断是否找到关键边</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> F = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            need = max1 - x;</span><br><span class="line">            <span class="built_in">fill</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记需要减少的路径</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cost[i] &gt; x) &#123;</span><br><span class="line">                    num[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">                    num[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">                    num[lca[i]] -= <span class="number">2</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !cnt || <span class="built_in">cf</span>(cf, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">F</span>(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ST</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2680</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 树的邻接表</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">next1</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">wei</span><span class="params">(n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            next1[cnt1] = head[u];</span><br><span class="line">            to[cnt1] = v;</span><br><span class="line">            wei[cnt1] = w;</span><br><span class="line">            head[u] = cnt1++;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            <span class="built_in">add</span>(u, v, w);</span><br><span class="line">            <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n1 = <span class="built_in">log2</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">deep</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 深度</span></span><br><span class="line">        <span class="function">vector <span class="title">st_lca</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(n1 + <span class="number">1</span>))</span></span>; <span class="comment">// 倍增父节点表</span></span><br><span class="line">        <span class="function">vector <span class="title">st_len</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(n1 + <span class="number">1</span>))</span></span>; <span class="comment">// 对应的边权和</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理 DFS</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp;f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> d, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            deep[u] = d;</span><br><span class="line">            st_lca[u][<span class="number">0</span>] = last;</span><br><span class="line">            st_len[u][<span class="number">0</span>] = w;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 倍增表更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">                st_lca[u][i] = st_lca[st_lca[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">                st_len[u][i] = st_len[u][i - <span class="number">1</span>] + st_len[st_lca[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                <span class="keyword">if</span> (v != last) <span class="built_in">f</span>(f, v, u, d + <span class="number">1</span>, wei[ei]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>, 4&gt;&gt; <span class="built_in">edges</span>(m);</span><br><span class="line">        <span class="type">int</span> max1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LCA 查询</span></span><br><span class="line">        <span class="keyword">auto</span> lca = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> i1) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (deep[u] &lt; deep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先让 u 和 v 到同一深度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n1; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (deep[st_lca[u][i]] &gt;= deep[v])</span><br><span class="line">                    len += st_len[u][i], u = st_lca[u][i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (u == v) <span class="keyword">goto</span> t1;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同时向上跳</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n1; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st_lca[u][i] != st_lca[v][i]) &#123;</span><br><span class="line">                    len += st_len[u][i] + st_len[v][i];</span><br><span class="line">                    u = st_lca[u][i];</span><br><span class="line">                    v = st_lca[v][i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一步</span></span><br><span class="line">            len += st_len[u][<span class="number">0</span>] + st_len[v][<span class="number">0</span>];</span><br><span class="line">            u = st_lca[u][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            t1:;</span><br><span class="line">            max1 = <span class="built_in">max</span>(max1, len);</span><br><span class="line">            edges[i1][<span class="number">2</span>] = len;</span><br><span class="line">            edges[i1][<span class="number">3</span>] = u; <span class="comment">// 存储 LCA</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入任务并计算路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            cin &gt;&gt; edges[i][<span class="number">0</span>] &gt;&gt; edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">lca</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二分答案</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = max1, ans = <span class="number">0</span>, mid;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> cnt, need;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cf = [&amp;](<span class="keyword">auto</span> &amp;&amp;f, <span class="type">int</span> u, <span class="type">int</span> last, <span class="type">int</span> w) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = next1[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                <span class="keyword">if</span> (v != last) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">f</span>(f, v, u, wei[ei])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    num[u] += num[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num[u] == cnt &amp;&amp; w &gt;= need;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> F = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            need = max1 - x;</span><br><span class="line">            <span class="built_in">fill</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[i][<span class="number">2</span>] &gt; x) &#123;</span><br><span class="line">                    num[edges[i][<span class="number">0</span>]]++;</span><br><span class="line">                    num[edges[i][<span class="number">1</span>]]++;</span><br><span class="line">                    num[edges[i][<span class="number">3</span>]] -= <span class="number">2</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !cnt || <span class="built_in">cf</span>(cf, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">F</span>(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="树上换根"><a href="#树上换根" class="headerlink" title="树上换根"></a>树上换根</h3><p>在树上做DP时，很多时候与根有关，如果把根从父亲换到儿子，答案可能按照同样的计算方法通过可推导公式进行变换，通常是dfs一次先算出某一个节点的值并且同时构造出必要信息，第二次dfs分为直接计算答案和构造前后缀信息。通常的时间复杂度为O(n)</p>
<h4 id="增量换根公式（轻量）"><a href="#增量换根公式（轻量）" class="headerlink" title="增量换根公式（轻量）"></a>增量换根公式（轻量）</h4><p>仅根据第一次dfs时构造的变量，通过第二次遍历按节点传递答案并利用变量进行计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://codeforces.com/problemset/problem/1187/E</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">next1</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">S</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt1;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 建图函数（链式前向星存储）</span></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v) &#123;</span><br><span class="line">        next1[cnt1] = head[u];</span><br><span class="line">        to[cnt1] = v;</span><br><span class="line">        head[u] = cnt1++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cnt1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fill</span>(head.<span class="built_in">begin</span>(), head.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 输入边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++) cin &gt;&gt; u &gt;&gt; v, <span class="built_in">add</span>(u, v), <span class="built_in">add</span>(v, u);</span><br><span class="line">        <span class="type">int</span> val1 = <span class="number">0</span>; <span class="comment">// 以 1 为根时所有子树大小之和</span></span><br><span class="line">        <span class="comment">// 第一次 DFS：计算子树大小和 val1</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> fa) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            S[u] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v = to[ei]; ei; ei = next1[ei], v = to[ei]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != fa) <span class="built_in">f</span>(f, v, u), S[u] += S[v];</span><br><span class="line">            &#125;</span><br><span class="line">            val1 += S[u];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 第二次 DFS：换根，动态维护答案</span></span><br><span class="line">        <span class="keyword">auto</span> dfs2 = [&amp;](<span class="keyword">auto</span>&amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> val) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> val2 = val; <span class="comment">// 当前答案</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v = to[ei]; ei; ei = next1[ei], v = to[ei]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">                    <span class="comment">// 换根公式：val + n - 2 * S[v]</span></span><br><span class="line">                    val2 = <span class="built_in">max</span>(val2, <span class="built_in">f</span>(f, v, u, val + n - (S[v] &lt;&lt; <span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val2;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="built_in">dfs2</span>(dfs2, <span class="number">1</span>, <span class="number">0</span>, val1) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前后缀合并"><a href="#前后缀合并" class="headerlink" title="前后缀合并"></a>前后缀合并</h4><p>当每个点的 DP 来自“合并所有子树的贡献”，且这个合并满足<strong>结合律</strong>（如 max&#x2F;sum&#x2F;min 的组合），就可以用<strong>前缀&#x2F;后缀</strong>把“除某个儿子外的其余贡献”在 O(1) 拿到，再作为“父信息”下推给儿子，实现“从父带来的贡献 + 自己子树贡献”的重组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P6419</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">5e5</span>;</span><br><span class="line"><span class="comment">// 链式前向星存图</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">next1</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">wei</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> cnt1;</span><br><span class="line"><span class="comment">// DP 数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum_in</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">sum_out</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max_in</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">max_in2</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">cho</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">max_out</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">has</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        next1[cnt1] = head[u];</span><br><span class="line">        to[cnt1] = v;</span><br><span class="line">        wei[cnt1] = w;</span><br><span class="line">        head[u] = cnt1++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        cnt1 = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fill</span>(head.<span class="built_in">begin</span>(), head.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 输入边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; i++) cin &gt;&gt; u &gt;&gt; v &gt;&gt; w, <span class="built_in">add</span>(u, v, w), <span class="built_in">add</span>(v, u, w);</span><br><span class="line">        <span class="comment">// 输入特殊节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; k; i++) cin &gt;&gt; x, has[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一次 DFS：自底向上</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span>&amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> fa) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            max_in[u] = max_in2[u] = sum_in[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v = to[ei]; ei; ei = next1[ei], v = to[ei]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">                    <span class="built_in">f</span>(f, v, u);</span><br><span class="line">                    <span class="comment">// 累计子树代价</span></span><br><span class="line">                    sum_in[u] += sum_in[v] + (has[v] || sum_in[v]) * (wei[ei] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 更新最长路径</span></span><br><span class="line">                    <span class="type">int</span> w = max_in[v] + (has[v] || sum_in[v]) * wei[ei];</span><br><span class="line">                    <span class="keyword">if</span> (w &gt; max_in[u]) &#123;</span><br><span class="line">                        cho[u] = v;</span><br><span class="line">                        max_in2[u] = max_in[u];</span><br><span class="line">                        max_in[u] = w;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w &gt; max_in2[u]) max_in2[u] = w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 第二次 DFS：自顶向下</span></span><br><span class="line">        <span class="keyword">auto</span> dfs2 = [&amp;](<span class="keyword">auto</span>&amp;&amp; f, <span class="type">int</span> u, <span class="type">int</span> fa) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v = to[ei]; ei; ei = next1[ei], v = to[ei]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v != fa) &#123;</span><br><span class="line">                    max_out[v] = max_out[u];</span><br><span class="line">                    <span class="keyword">if</span> (cho[u] == v) <span class="comment">// 如果走的是重儿子，用次优的 max_in2</span></span><br><span class="line">                        max_out[v] = <span class="built_in">max</span>(max_out[v] + wei[ei], max_in2[u] + wei[ei]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        max_out[v] = <span class="built_in">max</span>(max_out[v] + wei[ei], max_in[u] + wei[ei]);</span><br><span class="line">                    <span class="comment">// sum_out 的计算</span></span><br><span class="line">                    sum_out[v] = (sum_in[u] - sum_in[v] + sum_out[u]) </span><br><span class="line">                               + (sum_in[v] == <span class="number">0</span> &amp;&amp; !has[v]) * wei[ei] * <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// 特殊情况：该边唯一连接所有特殊点时，去掉重复</span></span><br><span class="line">                    <span class="keyword">if</span> (sum_in[u] == sum_in[v] + (wei[ei] &lt;&lt; <span class="number">1</span>) &amp;&amp; !sum_out[u])</span><br><span class="line">                        max_out[v] = sum_out[v] = <span class="number">0</span>;</span><br><span class="line">                    <span class="built_in">f</span>(f, v, u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs2</span>(dfs2, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 输出答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; sum_in[i] + sum_out[i] - <span class="built_in">max</span>(max_in[i], max_out[i]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p><strong>AVL树</strong>（英语：Adelson-Velsky and Landis tree）是<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中最早被发明的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">自平衡二叉查找树</a>。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度</a>都是 O(log⁡n)。增加和删除元素的操作则可能需要借由一次或多次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>，以实现树的重新平衡。AVL树得名于它的发明者<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA">格奥尔吉·阿杰尔松-韦利斯基</a>和<a href="https://zh.wikipedia.org/wiki/%E8%91%89%E5%A4%AB%E6%A0%B9%E5%B0%BC%C2%B7%E8%98%AD%E8%BF%AA%E6%96%AF">叶夫根尼·兰迪斯</a>，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p>
<p>一种有序表数据结构</p>
<p><strong>定义</strong></p>
<ul>
<li>平衡二叉搜索树，左右子树高度差 ≤ 1</li>
<li>插入、删除、查询操作复杂度：O(log n)</li>
</ul>
<hr>
<p><strong>节点信息</strong></p>
<ul>
<li>key：值</li>
<li>count：重复值频次</li>
<li>height：子树高度</li>
<li>size：子树大小（统计排名、k-th）</li>
<li>left&#x2F;right：左右子节点</li>
</ul>
<hr>
<p><strong>核心函数</strong></p>
<ul>
<li><code>up(i)</code>：更新 size &amp; height</li>
<li><code>maintain(i)</code>：检测平衡并旋转</li>
<li><code>rotateL / rotateR</code>：左旋 &#x2F; 右旋</li>
</ul>
<hr>
<p><strong>插入</strong></p>
<ol>
<li>按 BST 规则递归</li>
<li>命中相等 → count++</li>
<li>回溯时 <code>up + maintain</code></li>
</ol>
<hr>
<p><strong>删除</strong></p>
<ol>
<li>count &gt; 1 → count–</li>
<li>无子 → 直接删</li>
<li>单子 → 用唯一子替代</li>
<li>双子 → 找右子树最左节点替代，删掉它</li>
<li>回溯 <code>up + maintain</code></li>
</ol>
<hr>
<p><strong>查询</strong></p>
<ul>
<li>rank(x)：小于 x 的元素数 + 1</li>
<li>index(k)：第 k 小，靠 size 判断走向</li>
<li>pre(x)：小于 x 的最大值</li>
<li>suf(x)：大于 x 的最小值</li>
</ul>
<hr>
<p><strong>旋转类型</strong></p>
<ul>
<li>LL：右旋</li>
<li>RR：左旋</li>
<li>LR：先左旋子树，再右旋</li>
<li>RL：先右旋子树，再左旋</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3369</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="comment">// 节点信息</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">key</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">height</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">left1</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">right1</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">size1</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">count1</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> head, cnt1; <span class="comment">// head: 根节点编号, cnt1: 节点总数</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 更新节点信息：子树大小 + 高度</span></span><br><span class="line">	<span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">		size1[i] = size1[left1[i]] + size1[right1[i]] + count1[i];</span><br><span class="line">		height[i] = <span class="built_in">max</span>(height[left1[i]], height[right1[i]]) + <span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 左旋</span></span><br><span class="line">	<span class="keyword">auto</span> rotate_l = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="type">int</span> r = right1[i];</span><br><span class="line">		right1[i] = left1[r];</span><br><span class="line">		left1[r] = i;</span><br><span class="line">		<span class="built_in">up</span>(i);</span><br><span class="line">		<span class="built_in">up</span>(r);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 右旋</span></span><br><span class="line">	<span class="keyword">auto</span> rotate_r = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="type">int</span> l = left1[i];</span><br><span class="line">		left1[i] = right1[l];</span><br><span class="line">		right1[l] = i;</span><br><span class="line">		<span class="built_in">up</span>(i);</span><br><span class="line">		<span class="built_in">up</span>(l);</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 保持平衡：检查并旋转</span></span><br><span class="line">	<span class="keyword">auto</span> maintain = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="type">int</span> ln = height[left1[i]], rn = height[right1[i]];</span><br><span class="line">		<span class="keyword">if</span>(ln - rn &gt; <span class="number">1</span>) &#123; <span class="comment">// 左子树更高</span></span><br><span class="line">			<span class="keyword">if</span>(height[left1[left1[i]]] &gt;= height[right1[left1[i]]]) </span><br><span class="line">				i = <span class="built_in">rotate_r</span>(i); <span class="comment">// LL</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				left1[i] = <span class="built_in">rotate_l</span>(left1[i]), i = <span class="built_in">rotate_r</span>(i); <span class="comment">// LR</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(rn - ln &gt; <span class="number">1</span>) &#123; <span class="comment">// 右子树更高</span></span><br><span class="line">			<span class="keyword">if</span>(height[right1[right1[i]]] &gt;= height[left1[right1[i]]]) </span><br><span class="line">				i = <span class="built_in">rotate_l</span>(i); <span class="comment">// RR</span></span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				right1[i] = <span class="built_in">rotate_r</span>(right1[i]), i = <span class="built_in">rotate_l</span>(i); <span class="comment">// RL</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 插入节点 x</span></span><br><span class="line">	<span class="keyword">auto</span> add = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) &#123; <span class="comment">// 新建节点</span></span><br><span class="line">			key[++cnt1] = x;</span><br><span class="line">			count1[cnt1] = size1[cnt1] = height[cnt1] = <span class="number">1</span>;</span><br><span class="line">			left1[cnt1] = right1[cnt1] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> cnt1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(x == key[i]) count1[i] ++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; key[i]) left1[i] = <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">		<span class="keyword">else</span> right1[i] = <span class="built_in">f</span>(f, right1[i], x);</span><br><span class="line">		<span class="built_in">up</span>(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 删除子树中的最左节点</span></span><br><span class="line">	<span class="keyword">auto</span> removel = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == x) <span class="keyword">return</span> right1[i];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			left1[i] = <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">			<span class="built_in">up</span>(i);</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 删除值为 x 的节点（若存在）</span></span><br><span class="line">	<span class="keyword">auto</span> remove = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; key[i]) left1[i] = <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &gt; key[i]) right1[i] = <span class="built_in">f</span>(f, right1[i], x);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			count1[i] --; <span class="comment">// 多次出现，减频次</span></span><br><span class="line">			<span class="keyword">if</span>(!count1[i]) &#123; <span class="comment">// 频次为 0 -&gt; 删除节点</span></span><br><span class="line">				<span class="keyword">if</span>(!left1[i] &amp;&amp; !right1[i]) <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">// 无子</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(!left1[i] &amp;&amp; right1[i]) i = right1[i]; <span class="comment">// 只有右子</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(left1[i] &amp;&amp; !right1[i]) i = left1[i]; <span class="comment">// 只有左子</span></span><br><span class="line">				<span class="keyword">else</span> &#123; <span class="comment">// 两个子</span></span><br><span class="line">					<span class="type">int</span> l = right1[i];</span><br><span class="line">					<span class="keyword">while</span>(left1[l]) l = left1[l]; <span class="comment">// 找右子树最左节点</span></span><br><span class="line">					right1[i] = <span class="built_in">removel</span>(removel, right1[i],  l);</span><br><span class="line">					right1[l] = right1[i];</span><br><span class="line">					left1[l] = left1[i];</span><br><span class="line">					i = l;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">up</span>(i);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">maintain</span>(i);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 统计小于 x 的元素个数</span></span><br><span class="line">	<span class="keyword">auto</span> small = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(key[i] &gt;= x) <span class="keyword">return</span> <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> count1[i] + <span class="built_in">f</span>(f, right1[i], x) + size1[left1[i]];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 查询第 x 小的数</span></span><br><span class="line">	<span class="keyword">auto</span> index = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(size1[left1[i]] &gt;= x) <span class="keyword">return</span> <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(size1[left1[i]] + count1[i] &lt; x) </span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">f</span>(f, right1[i], x - size1[left1[i]] - count1[i]);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> key[i];</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 查询前驱：小于 x 的最大值</span></span><br><span class="line">	<span class="keyword">auto</span> pre = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">		<span class="keyword">if</span>(key[i] &gt;= x) <span class="keyword">return</span> <span class="built_in">f</span>(f, left1[i], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">max</span>(key[i], <span class="built_in">f</span>(f, right1[i], x));</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 查询后继：大于 x 的最小值</span></span><br><span class="line">	<span class="keyword">auto</span> suf = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">		<span class="keyword">if</span>(key[i] &lt;= x) <span class="keyword">return</span> <span class="built_in">f</span>(f, right1[i], x);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(key[i], <span class="built_in">f</span>(f, left1[i], x));</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">while</span>(t --) &#123; </span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		cnt1 = head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, op, x; i &lt; n; i ++) &#123;</span><br><span class="line">			cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span>(op == <span class="number">1</span>) head = <span class="built_in">add</span>(add, head, x);                <span class="comment">// 插入 x</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">2</span>) &#123;                                   <span class="comment">// 删除 x</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">small</span>(small, head, x) != <span class="built_in">small</span>(small, head, x + <span class="number">1</span>)) </span><br><span class="line">					head = <span class="built_in">remove</span>(remove, head, x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) cout &lt;&lt; <span class="built_in">small</span>(small, head, x) + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 查询排名</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">4</span>) cout &lt;&lt; <span class="built_in">index</span>(index, head, x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;     <span class="comment">// 查询第 k 小</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">5</span>) cout &lt;&lt; <span class="built_in">pre</span>(pre, head, x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;         <span class="comment">// 前驱</span></span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; <span class="built_in">suf</span>(suf, head, x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;                     <span class="comment">// 后继</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h3><p>笛卡尔树是一种二叉树，每一个节点由一个键值二元组 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="(k,w)"> 构成。要求 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="k"> 满足二叉搜索树的性质，而 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="w"> 满足堆的性质。如果笛卡尔树的 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="k,w"> 键值确定，且 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="k"> 互不相同，<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="w"> 也互不相同，那么这棵笛卡尔树的结构是唯一的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108306/G</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span>;</span><br><span class="line"><span class="comment">// 单调栈建树相关</span></span><br><span class="line"><span class="type">int</span> head, tot;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">R</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">S</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">H</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">st</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// 组合数预处理</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// 预处理阶乘与逆元：fac[i] = i!，inv[i] = (i!)^&#123;-1&#125;</span></span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="keyword">auto</span> power = [&amp;](<span class="type">int</span> x, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">            x = x * x % mod;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 费马小定理求逆阶乘</span></span><br><span class="line">    inv[N] = <span class="built_in">power</span>(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// 初始化左右儿子指针</span></span><br><span class="line">        <span class="built_in">fill</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(R.<span class="built_in">begin</span>(), R.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> min1 = <span class="number">1e18</span>;</span><br><span class="line">        <span class="comment">// 读入并记录全局最小值位置（Cartesian Tree 的根）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            cin &gt;&gt; v1[i];</span><br><span class="line">            <span class="keyword">if</span>(v1[i] &lt; min1) min1 = v1[i], head = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用单调递增栈构造“最小值 Cartesian Tree”</span></span><br><span class="line">        <span class="comment">// 规则（经典做法）：</span></span><br><span class="line">        <span class="comment">// - 弹出所有比当前值大的栈顶；</span></span><br><span class="line">        <span class="comment">// - 栈顶（若存在）作为当前结点的左/右关系的一端；</span></span><br><span class="line">        <span class="comment">// - 维护 L、R 为每个结点的左右儿子。</span></span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, now; i &lt;= n; i ++) &#123;</span><br><span class="line">            now = tot;</span><br><span class="line">            <span class="keyword">while</span>(tot &amp;&amp; v1[i] &lt; v1[st[tot]]) tot --;   <span class="comment">// 保持单调（严格递增）</span></span><br><span class="line">            <span class="keyword">if</span>(tot) R[st[tot]] = i;                     <span class="comment">// 栈顶的右儿子是当前 i</span></span><br><span class="line">            <span class="keyword">if</span>(now &gt; tot) L[i] = st[tot + <span class="number">1</span>];           <span class="comment">// 被弹出的第一个成为 i 的左儿子</span></span><br><span class="line">            st[++tot] = i;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 组合数 C(k, n) = nCk，这里参数名是 (up, down)，实际返回的是 C(up, down)</span></span><br><span class="line">        <span class="keyword">auto</span> C = [&amp;](<span class="type">int</span> up, <span class="type">int</span> down) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fac[down] * inv[up] % mod * inv[down - up] % mod;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// DFS：</span></span><br><span class="line">        <span class="comment">// - 先递归儿子，得到子树规模 S[*]</span></span><br><span class="line">        <span class="comment">// - 本结点贡献：C(d, d+S[i]-1)（等价于 C(d+S[i]-1, d)）</span></span><br><span class="line">        <span class="comment">// - 返回子树总答案之和</span></span><br><span class="line">        <span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> d) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!L[i] &amp;&amp; !R[i]) &#123;</span><br><span class="line">                S[i] = <span class="number">1</span>;                               <span class="comment">// 叶子</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(L[i]) ans = (ans + <span class="built_in">f</span>(f, L[i], d + <span class="number">1</span>)) % mod;</span><br><span class="line">                <span class="keyword">if</span>(R[i]) ans = (ans + <span class="built_in">f</span>(f, R[i], d + <span class="number">1</span>)) % mod;</span><br><span class="line">                S[i] = S[L[i]] + S[R[i]] + <span class="number">1</span>;           <span class="comment">// 子树规模</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + <span class="built_in">C</span>(d, d + S[i] - <span class="number">1</span>)) % mod;     <span class="comment">// 加上当前结点的组合贡献</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 最后 +1 一般用于把“空集/空方案”等计入答案（具体取决于题意）</span></span><br><span class="line">        cout &lt;&lt; (<span class="built_in">dfs</span>(dfs, head, <span class="number">1</span>) + <span class="number">1</span>) % mod&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>对数据进行分类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归找祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != fa[x]) fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">U</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后使用前记得统一根，即便利一遍时操作find</p>
<h3 id="常见二分"><a href="#常见二分" class="headerlink" title="常见二分"></a>常见二分</h3><p>加速查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 最小大于等于</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = v1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= v1[mid])&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最小大于</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = v1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; v1[mid])&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最长递增子序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = v1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最长递减子序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F2</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> r = v1.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三分"><a href="#三分" class="headerlink" title="三分"></a>三分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// F视具体情况</span></span><br><span class="line"><span class="function">ll <span class="title">ternary_search</span><span class="params">(ll l, ll r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        ll m1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        ll m2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">F</span>(m1) &lt;= <span class="built_in">F</span>(m2)) &#123;</span><br><span class="line">            r = m2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll best = <span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">// 最后暴力求解</span></span><br><span class="line">    <span class="keyword">for</span> (ll i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">F</span>(i) &lt; <span class="built_in">F</span>(best)) &#123;</span><br><span class="line">            best = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="博弈论（SG定理）"><a href="#博弈论（SG定理）" class="headerlink" title="博弈论（SG定理）"></a>博弈论（<code>SG</code>定理）</h3><p>所有相同子游戏最终<code>sg</code>异或结果为0则先手必败，不为零则先手必胜，<code>sg</code>为从某一节点开始，到最大限度往前便利后的第一个没有出现的自然数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 计算集合中缺失的最小非负整数（mex函数）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mex</span><span class="params">(<span class="type">const</span> set&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">count</span>(m)) m++;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入石子堆的石子数量：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 允许的操作：每次可以取 1、2 或 3 个石子</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; moves = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 动态规划数组，sg[i] 表示当前石子数量为 i 时的 SG 值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sg</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    sg[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 没有石子时，SG值为0</span></span><br><span class="line">    <span class="comment">// 计算每个状态的 SG 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; nextSG;</span><br><span class="line">        <span class="comment">// 对每一种允许的走法，计算下一状态的 SG 值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> move : moves) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - move &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nextSG.<span class="built_in">insert</span>(sg[i - move]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sg[i] = <span class="built_in">mex</span>(nextSG);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;状态 &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; 的 SG 值为：&quot;</span> &lt;&lt; sg[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(sg[n] != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;先手必胜\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;后手必胜\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p>保留乘积最小的结果以准备触底反弹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="type">int</span> min1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> max1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans1 = INT_MIN;</span><br><span class="line"><span class="type">int</span> pre1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pre2 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">    max1 = <span class="built_in">max</span>(&#123;v1[i], pre1 * v1[i], pre2 * v1[i]&#125;);</span><br><span class="line">    min1 = <span class="built_in">min</span>(&#123;v1[i], pre1 * v1[i], pre2 * v1[i]&#125;);</span><br><span class="line">    pre1 = max1;</span><br><span class="line">    pre2 = min1;</span><br><span class="line">    ans1 = <span class="built_in">max</span>(ans1, max1);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>求某一侧第一个 大于或者小于其的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">// 求右边第一个比其大的数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v1, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> size=v1.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>() &amp;&amp; v1[i] &gt; v1[s1.<span class="built_in">top</span>()])&#123;</span><br><span class="line">            ans[s1.<span class="built_in">top</span>()] = i+<span class="number">1</span>;</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(v1, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大频率栈"><a href="#最大频率栈" class="headerlink" title="最大频率栈"></a>最大频率栈</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; s1;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; t1;</span><br><span class="line">    <span class="type">int</span> max1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FreqStack</span>() &#123;</span><br><span class="line">        max1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        t1[val]++;</span><br><span class="line">        s1[t1[val]].<span class="built_in">push_back</span>(val);</span><br><span class="line">        max1=t1[val]&gt;max1?t1[val]:max1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int pop() 删除并返回堆栈中出现频率最高的元素。</span></span><br><span class="line"><span class="comment">	如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans=s1[max1].<span class="built_in">back</span>();</span><br><span class="line">        s1[t1[ans]--].<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(t1[ans]==<span class="number">0</span>)&#123;</span><br><span class="line">            t1.<span class="built_in">erase</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1[max1].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            max1--;</span><br><span class="line">            s1.<span class="built_in">erase</span>(max1+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="动态堆寻找中位数"><a href="#动态堆寻找中位数" class="headerlink" title="动态堆寻找中位数"></a>动态堆寻找中位数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">int</span> n;               <span class="comment">// 操作次数</span></span><br><span class="line">string op;            <span class="comment">// 输入的操作命令</span></span><br><span class="line"><span class="type">int</span> size1 = <span class="number">0</span>;        <span class="comment">// 当前栈的大小</span></span><br><span class="line"><span class="type">int</span> minsize = <span class="number">0</span>;      <span class="comment">// 小根堆中元素的数量</span></span><br><span class="line"><span class="type">int</span> maxsize = <span class="number">0</span>;      <span class="comment">// 大根堆中元素的数量</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">stack1</span><span class="params">(N)</span></span>;    <span class="comment">// 用于模拟栈，存储所有插入的数字</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minheap;  <span class="comment">// 小根堆，用于存储大于等于中位数的数</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxheap;  <span class="comment">// 大根堆，用于存储小于等于中位数的数</span></span><br><span class="line"><span class="comment">// 用于延迟删除的映射：记录需要从堆中删除但还未实际删除的数字及其次数</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; delayed;  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prune</span><span class="params">(T &amp;heap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当堆不为空时，检查堆顶元素是否在延迟删除映射中</span></span><br><span class="line">    <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> num = heap.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (delayed.<span class="built_in">count</span>(num)) &#123;  <span class="comment">// 如果堆顶元素需要被删除</span></span><br><span class="line">            delayed[num]--;        <span class="comment">// 延迟删除计数减一</span></span><br><span class="line">            <span class="keyword">if</span> (delayed[num] == <span class="number">0</span>)</span><br><span class="line">                delayed.<span class="built_in">erase</span>(num);  <span class="comment">// 如果次数为0则从映射中删除</span></span><br><span class="line">            heap.<span class="built_in">pop</span>();              <span class="comment">// 弹出堆顶元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 堆顶元素未被延迟删除，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">balance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果大根堆的元素比小根堆多超过1个，则将大根堆的堆顶移动到小根堆中</span></span><br><span class="line">    <span class="keyword">if</span> (maxsize &gt; minsize + <span class="number">1</span>) &#123;</span><br><span class="line">        minheap.<span class="built_in">push</span>(maxheap.<span class="built_in">top</span>());</span><br><span class="line">        maxheap.<span class="built_in">pop</span>();</span><br><span class="line">        minsize++;</span><br><span class="line">        maxsize--;</span><br><span class="line">        <span class="built_in">prune</span>(maxheap);  <span class="comment">// 清理大根堆堆顶可能存在的延迟删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果大根堆的元素数目小于小根堆，则将小根堆的堆顶移动到大根堆中</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maxsize &lt; minsize) &#123;</span><br><span class="line">        maxheap.<span class="built_in">push</span>(minheap.<span class="built_in">top</span>());</span><br><span class="line">        minheap.<span class="built_in">pop</span>();</span><br><span class="line">        maxsize++;</span><br><span class="line">        minsize--;</span><br><span class="line">        <span class="built_in">prune</span>(minheap);  <span class="comment">// 清理小根堆堆顶可能存在的延迟删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记该数字需要延迟删除</span></span><br><span class="line">    delayed[num]++;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= maxheap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        maxsize--;</span><br><span class="line">        <span class="comment">// 如果待删除数字恰好是大根堆堆顶，则立即清理</span></span><br><span class="line">        <span class="keyword">if</span> (num == maxheap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            <span class="built_in">prune</span>(maxheap);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minsize--;</span><br><span class="line">        <span class="comment">// 如果待删除数字恰好是小根堆堆顶，则立即清理</span></span><br><span class="line">        <span class="keyword">if</span> (num == minheap.<span class="built_in">top</span>())</span><br><span class="line">            <span class="built_in">prune</span>(minheap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">balance</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="comment">// peek</span></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size1 == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 中位数为大根堆的堆顶</span></span><br><span class="line">                cout &lt;&lt; maxheap.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// pop</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size1 == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Invalid&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 输出栈顶元素</span></span><br><span class="line">                cout &lt;&lt; stack1[size1 - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 删除栈顶元素，并在堆中延迟删除对应数字</span></span><br><span class="line">                <span class="built_in">erase</span>(stack1[--size1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// push</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; stack1[size1++];</span><br><span class="line">            <span class="comment">// 如果大根堆为空，则直接插入到大根堆中</span></span><br><span class="line">            <span class="keyword">if</span> (maxsize == <span class="number">0</span>) &#123;</span><br><span class="line">                maxheap.<span class="built_in">push</span>(stack1[size1 - <span class="number">1</span>]);</span><br><span class="line">                maxsize++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据新插入数字与当前中位数比较，决定放入哪个堆</span></span><br><span class="line">            <span class="keyword">if</span> (stack1[size1 - <span class="number">1</span>] &gt; maxheap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                minheap.<span class="built_in">push</span>(stack1[size1 - <span class="number">1</span>]);</span><br><span class="line">                minsize++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxheap.<span class="built_in">push</span>(stack1[size1 - <span class="number">1</span>]);</span><br><span class="line">                maxsize++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保持两个堆的平衡</span></span><br><span class="line">            <span class="built_in">balance</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t; </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大小根堆"><a href="#大小根堆" class="headerlink" title="大小根堆"></a>大小根堆</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 向堆中插入新元素，使其满足大顶堆性质</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(arr[i] &gt; arr[(i<span class="number">-1</span>)/<span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[(i<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆化：从下标 i 开始向下调整，使子树满足大顶堆性质，size 为堆的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxIdx;  <span class="comment">// 保存左右孩子中较大值的下标</span></span><br><span class="line">    <span class="type">int</span> idx;     <span class="comment">// 保存父节点与较大孩子中较大者的下标</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 在左右孩子中选择较大者</span></span><br><span class="line">        maxIdx = (l + <span class="number">1</span> &lt; size &amp;&amp; arr[l+<span class="number">1</span>] &gt; arr[l]) ? l + <span class="number">1</span> : l;</span><br><span class="line">        <span class="comment">// 选择父节点与较大孩子中较大者</span></span><br><span class="line">        idx = (arr[i] &gt; arr[maxIdx]) ? i : maxIdx;</span><br><span class="line">        <span class="keyword">if</span>(idx == i) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[idx]);</span><br><span class="line">            i = idx;</span><br><span class="line">            l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">heapPop</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> &amp;size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> top = arr[<span class="number">0</span>];             <span class="comment">// 保存堆顶元素</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[size - <span class="number">1</span>]);    <span class="comment">// 将堆顶与最后一个元素交换</span></span><br><span class="line">    size--;                       <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    <span class="built_in">heapify</span>(arr, <span class="number">0</span>, size);        <span class="comment">// 从顶端重新调整堆</span></span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><p>利用扫描思想平移某一个轴时，加工另一个轴的信息来一边扫过去就能解决问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P5490</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">-2</span>&#125;;</span><br><span class="line">		vector&lt;array&lt;<span class="type">int</span>, 4&gt;&gt; v1;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">			cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">			v2.<span class="built_in">push_back</span>(y1);</span><br><span class="line">			v2.<span class="built_in">push_back</span>(y2);</span><br><span class="line">			v1.<span class="built_in">push_back</span>(&#123;x1, y1, y2, <span class="number">1</span>&#125;);</span><br><span class="line">			v1.<span class="built_in">push_back</span>(&#123;x2, y1, y2, <span class="number">-1</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(v2.<span class="built_in">begin</span>() + <span class="number">1</span>, v2.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">int</span> m = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; v2.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(v2[i] != v2[m])&#123;</span><br><span class="line">				v2[++ m] = v2[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		v2.<span class="built_in">push_back</span>(v2[m]);</span><br><span class="line">		<span class="keyword">auto</span> find = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="type">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">			<span class="type">int</span> mid, ans = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(v2[mid] &gt;= x)&#123;</span><br><span class="line">					ans = mid;</span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum1</span><span class="params">(m &lt;&lt; <span class="number">4</span>)</span>, <span class="title">cnt1</span><span class="params">(m &lt;&lt; <span class="number">4</span>)</span>, <span class="title">cover</span><span class="params">(m &lt;&lt; <span class="number">4</span>)</span></span>;</span><br><span class="line">		<span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">				<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">			&#125;</span><br><span class="line">			cover[i] = v2[r + <span class="number">1</span>] - v2[l];</span><br><span class="line">			sum1[i] = cnt1[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">		<span class="keyword">auto</span> up = [&amp;](<span class="type">int</span> i) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cnt1[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				sum1[i] = cover[i]; </span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				sum1[i] = sum1[i &lt;&lt; <span class="number">1</span>] + sum1[i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> set = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i, <span class="type">int</span> bl, <span class="type">int</span> br, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(bl &lt;= l &amp;&amp; br &gt;= r)&#123;</span><br><span class="line">				cnt1[i] += val;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(bl &lt;= mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span>, bl, br, val, l, mid);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(br &gt; mid)&#123;</span><br><span class="line">					<span class="built_in">f</span>(f, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, bl, br, val, mid + <span class="number">1</span>, r);</span><br><span class="line">				&#125;     </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">up</span>(i);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">		<span class="type">int</span> last = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n &lt;&lt; <span class="number">1</span>; i ++)&#123;</span><br><span class="line">			<span class="type">int</span> now = v1[i][<span class="number">0</span>];</span><br><span class="line">			ans += sum1[<span class="number">1</span>] * (now - last);</span><br><span class="line">			<span class="comment">// cout &lt;&lt; sum1[1] &lt;&lt; &quot; &quot; &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; last &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">			last = now;</span><br><span class="line">			<span class="built_in">set</span>(set, <span class="number">1</span>, <span class="built_in">find</span>(v1[i][<span class="number">1</span>]), <span class="built_in">find</span>(v1[i][<span class="number">2</span>]) - <span class="number">1</span>, v1[i][<span class="number">3</span>], <span class="number">1</span>, m);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="归并分治"><a href="#归并分治" class="headerlink" title="归并分治"></a>归并分治</h4><p>分而治之</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500</span></span><br><span class="line"><span class="type">int</span> a1[M];</span><br><span class="line"><span class="type">int</span> temp[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> m,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="type">int</span> j=m+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mark=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m &amp;&amp; j&lt;=r) a1[mark++]=temp[i]&lt;temp[j]?temp[i++]:temp[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) a1[mark++]=temp[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) a1[mark++]=temp[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++) temp[k]=a1[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">guibing</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="built_in">guibing</span>(l,m);</span><br><span class="line">	<span class="built_in">guibing</span>(m+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">merge</span>(l,m,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a1[i];</span><br><span class="line">        temp[i]=a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">guibing</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;a1[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="随机快排-选择第-k-小-大-的数"><a href="#随机快排-选择第-k-小-大-的数" class="headerlink" title="随机快排 &amp; 选择第 k 小&#x2F;大 的数"></a>随机快排 &amp; 选择第 k 小&#x2F;大 的数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500</span></span><br><span class="line"><span class="comment">// 经典</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition1</span><span class="params">(<span class="type">int</span> a1[],<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="type">int</span> j=r;</span><br><span class="line">    <span class="type">int</span> temp=a1[mid];</span><br><span class="line">    <span class="built_in">swap</span>(a1[mid],a1[l]);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;i &amp;&amp; a1[j]&gt;temp)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a1[i]=a1[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a1[i]&lt;=temp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        a1[j]=a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a1[i]=temp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs1</span><span class="params">(<span class="type">int</span> a1[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x=l+(<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> mid=<span class="built_in">partition1</span>(a1,l,x,r);</span><br><span class="line">    <span class="built_in">qs1</span>(a1,l,mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">qs1</span>(a1,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="type">int</span> first;</span><br><span class="line"><span class="type">int</span> second;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">partition2</span><span class="params">(<span class="type">int</span> a1[],<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    first=l;</span><br><span class="line">    second=r;</span><br><span class="line">    <span class="type">int</span> temp=a1[mid];</span><br><span class="line">    <span class="type">int</span> i=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=second)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a1[i]==temp)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1[i]&lt;temp)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a1[first++],a1[i++]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a1[i],a1[second--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qs2</span><span class="params">(<span class="type">int</span> a1[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x=l+(<span class="built_in">rand</span>()%(r-l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">partition2</span>(a1,l,x,r);</span><br><span class="line">    <span class="type">int</span> left=first;</span><br><span class="line">    <span class="type">int</span> right=second;</span><br><span class="line">    <span class="built_in">qs2</span>(a1,l,left<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">qs2</span>(a1,right+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机选择第 tar 小的元素（0-based）</span></span><br><span class="line"><span class="comment">// 要求第k大的元素等同于求n - k小的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">randomizedSelect</span><span class="params">(<span class="type">int</span> a1[], <span class="type">int</span> k, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> x = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>); <span class="comment">// 随机选取枢纽值</span></span><br><span class="line">        <span class="built_in">partition2</span>(a1, l, x, r); <span class="comment">// 三路划分，结果通过 first 和 second 表示</span></span><br><span class="line">        <span class="keyword">if</span> (k &lt; first) &#123;</span><br><span class="line">            r = first - <span class="number">1</span>; <span class="comment">// 目标在左侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; second) &#123;</span><br><span class="line">            l = second + <span class="number">1</span>; <span class="comment">// 目标在右侧</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a1[k]; <span class="comment">// 命中：tar 位于等于区域内</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若未找到（理论上不会出现），返回 -1 表示错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="阶乘与逆元"><a href="#阶乘与逆元" class="headerlink" title="阶乘与逆元"></a>阶乘与逆元</h3><p>乘以逆元等于除以某一个数再取模&gt;</p>
<blockquote>
<p>1!,2!,3!…n!的逆元</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">auto</span> power = [&amp;](<span class="type">int</span> x, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 阶乘</span></span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    fac[i] = fac[i - <span class="number">1</span>] * i % mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inv</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// 逆元</span></span><br><span class="line">inv[n] = <span class="built_in">power</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">    inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> C = [&amp;](<span class="type">int</span> n, <span class="type">int</span> m) -&gt; <span class="type">int</span> &#123; <span class="comment">// 组合数</span></span><br><span class="line">    <span class="keyword">if</span>(m &gt; n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="线性递推逆元"><a href="#线性递推逆元" class="headerlink" title="线性递推逆元"></a>线性递推逆元</h3><blockquote>
<p>1,2,3….n的逆元</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p 必须为质数</span></span><br><span class="line">inv2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">	inv2[i] = (p - p / i) * inv2[p % i] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>加速矩阵计算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">multiply</span>(<span class="type">const</span> vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;a,<span class="type">const</span> vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; &amp;b) &#123;</span><br><span class="line">		<span class="type">int</span> n = a.<span class="built_in">size</span>(), p = a[<span class="number">0</span>].<span class="built_in">size</span>(), m = b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">		<span class="function">vector <span class="title">ans</span><span class="params">(n, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; p; k++) &#123;</span><br><span class="line">					ans[i][j] += a[i][k] * b[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">power</span>(vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; v, <span class="type">int</span> cnt) &#123;</span><br><span class="line">		<span class="type">int</span> n = v.<span class="built_in">size</span>();</span><br><span class="line">		vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">ans</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			ans[i][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (cnt) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				ans = <span class="built_in">multiply</span>(ans, v);</span><br><span class="line">			&#125;</span><br><span class="line">			v = <span class="built_in">multiply</span>(v, v);</span><br><span class="line">			cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tribonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; start = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; base = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">multiply</span>(start, <span class="built_in">power</span>(base, n - <span class="number">2</span>))[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p>得到某一个ax + by &#x3D; d的各种参数，d为最大公约数，x和y为贝祖系数（裴蜀定理的算法实现）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x, y, px, py;</span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gcd1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        d = a;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">gcd1</span>(b, a % b);</span><br><span class="line">        px = x;</span><br><span class="line">        py = y;</span><br><span class="line">        x = py;</span><br><span class="line">        y = px - py * (a / b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">gcd1</span>(a, b);</span><br><span class="line">    cout &lt;&lt; (x % b + b) % b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h3><p>求解同余方程组<br>$$<br>x \equiv r_i \pmod{m_i}, \quad i &#x3D; 1,2,\dots,n<br>$$<br>若有解，求其最小非负整数解 x。</p>
<ul>
<li><p><strong>互素版（CRT）</strong>：所有模数 $m_i$ 两两互素。<br>   思想：构造总模 $M&#x3D;\prod m_i$​，对每个方程求部分积 $M_i&#x3D;M&#x2F;m_i$​ 的逆元 $inv_i$​，累加<br>  $$<br>  x &#x3D; \sum r_i M_i inv_i \pmod{M}<br>  $$</p>
</li>
<li><p><strong>扩展版（CRT_E）</strong>：模数可不互素。<br>   思想：逐步合并两个方程：<br>  $$<br>  \begin{cases} x \equiv a_1 \pmod{m_1}\ x \equiv a_2 \pmod{m_2} \end{cases} \Rightarrow \text{解 } lcm &#x3D; \frac{m_1m_2}{\gcd(m_1,m_2)}<br>  $$<br>  用扩展欧几里得求解差值方程，判断是否有解并更新。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="comment">// 扩展欧几里得的解：ax + by = d，其中 d = gcd(a, b)</span></span><br><span class="line"><span class="type">int</span> x, y, d;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gcd1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        d = a;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">gcd1</span>(b, a % b);</span><br><span class="line">        <span class="type">int</span> lx = x;</span><br><span class="line">        <span class="type">int</span> ly = y;</span><br><span class="line">        x = ly;</span><br><span class="line">        y = lx - (a / b) * ly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 慢乘法</span></span><br><span class="line"><span class="keyword">auto</span> mul = [](<span class="type">int</span> x, <span class="type">int</span> n, <span class="type">int</span> mod) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    x = (x % mod + mod) % mod;</span><br><span class="line">    n = (n % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = (ans + x) % mod;</span><br><span class="line">        x = (x + x) % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中国剩余定理（互素版）</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *   n, 接着 n 行，每行：m_i  r_i   表示 x ≡ r_i (mod m_i)</span></span><br><span class="line"><span class="comment"> * 假设：</span></span><br><span class="line"><span class="comment"> *   所有模数 m_i 两两互素</span></span><br><span class="line"><span class="comment"> * 原理：</span></span><br><span class="line"><span class="comment"> *   总模 M = ∏ m_i</span></span><br><span class="line"><span class="comment"> *   对于第 i 个同余：令 M_i = M / m_i</span></span><br><span class="line"><span class="comment"> *   求 M_i 在模 m_i 下的乘法逆元 inv_i，使得 M_i * inv_i ≡ 1 (mod m_i)</span></span><br><span class="line"><span class="comment"> *   则解为：x ≡ Σ (r_i * M_i * inv_i) (mod M)</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *   最小非负解 x ∈ [0, M)</span></span><br><span class="line"><span class="comment"> * 注意：</span></span><br><span class="line"><span class="comment"> *   代码里用扩展欧几里得求 inv_i，并用 mul 避免溢出。</span></span><br><span class="line"><span class="comment"> *   lcm0 = ∏ m_i 若过大可能溢出 64 位，本实现不做额外防护。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> lcm0 = <span class="number">1</span>; <span class="comment">// 实际上是所有 m_i 的乘积（互素场景下等于 LCM）</span></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">v1</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [modi, ri] : v1) &#123;</span><br><span class="line">        cin &gt;&gt; modi &gt;&gt; ri;</span><br><span class="line">        lcm0 *= modi; <span class="comment">// 可能溢出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; <span class="comment">// 累加式构造的解（最终对 lcm0 取模）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> Mi = lcm0 / v1[i].fr; <span class="comment">// M_i</span></span><br><span class="line">        <span class="built_in">gcd1</span>(Mi, v1[i].fr);       <span class="comment">// 求 gcd 及系数 x,y，其中 x 是 Mi 关于模 m_i 的“逆元”原型</span></span><br><span class="line">        <span class="comment">// 将 x 规约到 [0, m_i) 作为逆元 inv_i</span></span><br><span class="line">        x = ((x % v1[i].fr) + v1[i].fr) % v1[i].fr;</span><br><span class="line">        <span class="comment">// ans += r_i * M_i * inv_i （全过程都在 mod M 下做）</span></span><br><span class="line">        ans = (ans + <span class="built_in">mul</span>(<span class="built_in">mul</span>(v1[i].sc, Mi, lcm0), x, lcm0)) % lcm0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans; <span class="comment">// 最小非负解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 中国剩余定理（扩展版 / 非互素也可）</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *   n, 接着 n 行，每行：m_i  r_i   表示 x ≡ r_i (mod m_i)</span></span><br><span class="line"><span class="comment"> * 能力：</span></span><br><span class="line"><span class="comment"> *   支持模数 m_i 之间不互素的情况；</span></span><br><span class="line"><span class="comment"> *   若系统无解，返回 -1。</span></span><br><span class="line"><span class="comment"> * 思路（增量合并）：</span></span><br><span class="line"><span class="comment"> *   已有方程组合并为 x ≡ tail (mod lcm)</span></span><br><span class="line"><span class="comment"> *   加入新方程 x ≡ r (mod m)：</span></span><br><span class="line"><span class="comment"> *     令 c = r - tail</span></span><br><span class="line"><span class="comment"> *     解 lcm * t ≡ c (mod m)</span></span><br><span class="line"><span class="comment"> *     设 d = gcd(lcm, m)，若 c % d != 0 则无解</span></span><br><span class="line"><span class="comment"> *     化简： (lcm/d) * t ≡ c/d (mod m/d)</span></span><br><span class="line"><span class="comment"> *     由扩展欧几里得求 (lcm/d) 关于模 (m/d) 的逆元 inv = x（gcd1 填的全局 x）</span></span><br><span class="line"><span class="comment"> *     得 t ≡ inv * (c/d) (mod m/d)</span></span><br><span class="line"><span class="comment"> *     用 tail + lcm * t 更新 tail，并把模数并成 lcm = lcm * (m/d)</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> *   合并后最小非负解 ∈ [0, lcm)，或 -1 表示无解</span></span><br><span class="line"><span class="comment"> * 复杂度：</span></span><br><span class="line"><span class="comment"> *   O(n log V)，V 为数值上界</span></span><br><span class="line"><span class="comment"> * 备注：</span></span><br><span class="line"><span class="comment"> *   为避免乘法溢出，使用 mul 实现“lcm * t (mod temp)”等运算。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CRT_E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">v1</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [modi, ri] : v1) cin &gt;&gt; modi &gt;&gt; ri;</span><br><span class="line">    <span class="type">int</span> lcm = <span class="number">1</span>;   <span class="comment">// 当前合并后的模（不一定是严格 LCM，逐步扩大）</span></span><br><span class="line">    <span class="type">int</span> tail = <span class="number">0</span>;  <span class="comment">// 当前合并后的解（最小非负）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> m = v1[i].fr;  <span class="comment">// 新模</span></span><br><span class="line">        <span class="type">int</span> r = v1[i].sc;  <span class="comment">// 新余数</span></span><br><span class="line">        <span class="built_in">gcd1</span>(lcm, m);      <span class="comment">// 得到 d=gcd(lcm,m) 以及一组 (x,y) 使 lcm*x + m*y = d</span></span><br><span class="line">        <span class="type">int</span> c = ((r - tail) % m + m) % m; <span class="comment">// 目标差 c（化到 [0,m)），要解：lcm*t ≡ c (mod m)</span></span><br><span class="line">        <span class="keyword">if</span> (c % d != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无解：c 不是 d 的倍数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 化简同余：(lcm/d)*t ≡ (c/d) (mod m/d)</span></span><br><span class="line">        <span class="comment">// 由 gcd1 得到的 x 是 lcm 关于 m 的“贝祖系数”，</span></span><br><span class="line">        <span class="comment">// 将其在模 (m/d) 下作为 (lcm/d) 的逆元使用（需要取模规约）。</span></span><br><span class="line">        x = <span class="built_in">mul</span>(x, c / d, m / d);                <span class="comment">// t ≡ x * (c/d) (mod m/d)</span></span><br><span class="line">        x = (x % (m / d) + (m / d)) % (m / d);   <span class="comment">// 规约到 [0, m/d)</span></span><br><span class="line">        <span class="type">int</span> temp = lcm * (m / d);                <span class="comment">// 新模（等价于 lcm 与 m 的最小公倍数）</span></span><br><span class="line">        <span class="comment">// 更新 tail： x_new = tail + lcm * t （在模 temp 下）</span></span><br><span class="line">        tail = (tail + <span class="built_in">mul</span>(lcm, x, temp)) % temp;</span><br><span class="line">        lcm = temp; <span class="comment">// 扩大模</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;    <span class="comment">// 返回最终最小非负解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">        <span class="comment">// 演示：调用扩展 CRT（非互素也可）。如需互素版请改为 CRT()</span></span><br><span class="line">        <span class="comment">// 输入格式示例：</span></span><br><span class="line">        <span class="comment">//   n</span></span><br><span class="line">        <span class="comment">//   m1 r1</span></span><br><span class="line">        <span class="comment">//   m2 r2</span></span><br><span class="line">        <span class="comment">//   ...</span></span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">//   最小非负解；若无解输出 -1</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; CRT() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">CRT_E</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>一个数组的GCD前缀不同种类是log级别的，可通过此题进行进一步了解和体会<a href="https://codeforces.com/gym/105386/problem/E">2024ICPCKunming</a>.</p>
<p>对任意a &gt;&#x3D; b, 有gcd(a, b) &#x3D; gcd(a - b, b);</p>
<h4 id="GCD-本质"><a href="#GCD-本质" class="headerlink" title="GCD 本质"></a>GCD 本质</h4><p>求$gcd(a^b, c^d)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108304/J</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --) &#123; </span><br><span class="line">		<span class="type">int</span> a, b, c, d;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">		<span class="keyword">auto</span> power = [&amp;](<span class="type">int</span> x, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">			x %= mod;</span><br><span class="line">			<span class="keyword">while</span>(n) &#123;</span><br><span class="line">				<span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">				x = x * x % mod;</span><br><span class="line">				n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(b &gt; d) <span class="built_in">swap</span>(a, c), <span class="built_in">swap</span>(b, d);</span><br><span class="line">			<span class="type">int</span> temp = <span class="built_in">gcd</span>(a, c);</span><br><span class="line">			ans = ans * <span class="built_in">power</span>(temp, b) % mod;</span><br><span class="line">			a = a / temp;</span><br><span class="line"><span class="comment">//             c = temp;</span></span><br><span class="line">			d -= b;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">gcd</span>(a, c) == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stein-GCD算法"><a href="#Stein-GCD算法" class="headerlink" title="Stein GCD算法"></a>Stein GCD算法</h4><p>Stein算法是一种计算两个非负整数的最大公约数的算法。它比传统的欧几里得算法在某些情况下更高效，<br>因为它避免了使用除法操作。该算法利用了以下几条规则：<br>GCD(0, b) &#x3D; b：如果一个数是0，另一个数就是最大公约数。<br>GCD(a, 0) &#x3D; a：同上，如果一个数是0，另一个数就是最大公约数。<br>如果a和b都是偶数，那么GCD(a, b) &#x3D; 2 * GCD(a&#x2F;2, b&#x2F;2)。<br>如果a是偶数且b是奇数，那么GCD(a, b) &#x3D; GCD(a&#x2F;2, b)。<br>如果a是奇数且b是偶数，那么GCD(a, b) &#x3D; GCD(a, b&#x2F;2)。<br>如果a和b都是奇数，并且a &gt;&#x3D; b，那么GCD(a, b) &#x3D; GCD((a - b)&#x2F;2, b)。<br>如果a和b都是奇数，并且a &lt; b，那么GCD(a, b) &#x3D; GCD((b - a)&#x2F;2, a)。<br>通过不断应用这些规则，最终可以将两个数变为0，从而找到它们的最大公约数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">steinGCD</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a, <span class="type">unsigned</span> <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="comment">// 找到a和b的共同因子2的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((a | b) &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        shift++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使a成为奇数</span></span><br><span class="line">    <span class="keyword">while</span> ((a &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 使b成为奇数</span></span><br><span class="line">        <span class="keyword">while</span> ((b &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证a &lt;= b</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b - a是偶数，所以我们可以继续右移</span></span><br><span class="line">        b = (b - a);</span><br><span class="line">    &#125; <span class="keyword">while</span> (b != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 恢复共同因子2的数量</span></span><br><span class="line">    <span class="keyword">return</span> a &lt;&lt; shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Least-Recently-Used-LRU-算法"><a href="#Least-Recently-Used-LRU-算法" class="headerlink" title="Least Recently Used (LRU)算法"></a>Least Recently Used (LRU)算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1010</span></span><br><span class="line"><span class="comment">// Least Recently Used (LRU) 缓存实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义双向链表节点</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> key;    <span class="comment">// 节点对应的 key</span></span><br><span class="line">        <span class="type">int</span> val;    <span class="comment">// 节点对应的 value</span></span><br><span class="line">        DoubleNode* next; <span class="comment">// 后继节点指针</span></span><br><span class="line">        DoubleNode* last; <span class="comment">// 前驱节点指针</span></span><br><span class="line">        <span class="built_in">DoubleNode</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k), <span class="built_in">val</span>(v), <span class="built_in">last</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义双向链表，用于维护访问顺序</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        DoubleNode* head; <span class="comment">// 链表头部（最久未使用）</span></span><br><span class="line">        DoubleNode* tail; <span class="comment">// 链表尾部（最近使用）</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">DoubleList</span>(): <span class="built_in">head</span>(<span class="literal">nullptr</span>), <span class="built_in">tail</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="comment">// 在链表尾部添加新节点（最新使用的节点）</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">addNode</span><span class="params">(DoubleNode* newNode)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!newNode) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = tail = newNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = newNode;</span><br><span class="line">                newNode-&gt;last = tail;</span><br><span class="line">                tail = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将已有节点移动到链表尾部（表示最近使用）</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">moveNodeToTail</span><span class="params">(DoubleNode* node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == node) <span class="keyword">return</span>;  <span class="comment">// 节点已在尾部，无需移动</span></span><br><span class="line">            <span class="keyword">if</span> (head == node) &#123;        <span class="comment">// 节点位于头部</span></span><br><span class="line">                head = node-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (head) head-&gt;last = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                   <span class="comment">// 节点在中间</span></span><br><span class="line">                node-&gt;last-&gt;next = node-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;next)</span><br><span class="line">                    node-&gt;next-&gt;last = node-&gt;last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将节点移动到尾部</span></span><br><span class="line">            node-&gt;last = tail;</span><br><span class="line">            node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">if</span> (tail) tail-&gt;next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除链表头部节点（最久未使用的节点）并返回该节点</span></span><br><span class="line">        <span class="function">DoubleNode* <span class="title">removeHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            DoubleNode* ans = head;</span><br><span class="line">            <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                head = tail = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (head) head-&gt;last = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 辅助函数：清空链表，释放所有节点</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            DoubleNode* cur = head;</span><br><span class="line">            <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">                DoubleNode* next = cur-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = tail = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">// 提供链表头部访问，用于析构时遍历</span></span><br><span class="line">        <span class="function">DoubleNode* <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DoubleNode*&gt; keyNodeMap; <span class="comment">// 快速定位 key 对应的节点</span></span><br><span class="line">    DoubleList nodeList;                        <span class="comment">// 维护节点顺序的双向链表</span></span><br><span class="line">    <span class="type">int</span> cap;                                    <span class="comment">// 缓存容量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">LRU</span>(<span class="type">int</span> c): <span class="built_in">cap</span>(c) &#123;&#125;</span><br><span class="line">    <span class="comment">// 析构函数，释放所有申请的内存</span></span><br><span class="line">    ~<span class="built_in">LRU</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历双向链表释放节点</span></span><br><span class="line">        DoubleNode* cur = nodeList.<span class="built_in">getHead</span>();</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            DoubleNode* next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        keyNodeMap.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取 key 对应的值，并将该节点移到尾部表示最近使用</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param key 缓存中的键</span></span><br><span class="line"><span class="comment">     * @return int 若 key 存在则返回对应值，否则返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            DoubleNode* ans = keyNodeMap[key];</span><br><span class="line">            nodeList.<span class="built_in">moveNodeToTail</span>(ans);  <span class="comment">// 更新最近使用</span></span><br><span class="line">            <span class="keyword">return</span> ans-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 向缓存中插入或更新一个 key-value 对</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 若 key 存在，则更新其值并将节点移到尾部；</span></span><br><span class="line"><span class="comment">     * 若 key 不存在，则插入新节点，若缓存已满，则移除最久未使用的节点。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param key 缓存中的键</span></span><br><span class="line"><span class="comment">     * @param val1 缓存中的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyNodeMap.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// key 存在，更新值并移到尾部</span></span><br><span class="line">            DoubleNode* node = keyNodeMap[key];</span><br><span class="line">            node-&gt;val = val1;</span><br><span class="line">            nodeList.<span class="built_in">moveNodeToTail</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果缓存已满，删除最久未使用的节点</span></span><br><span class="line">            <span class="keyword">if</span> (keyNodeMap.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                DoubleNode* removed = nodeList.<span class="built_in">removeHead</span>();</span><br><span class="line">                <span class="keyword">if</span>(removed) &#123;</span><br><span class="line">                    keyNodeMap.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                    <span class="keyword">delete</span> removed;  <span class="comment">// 释放内存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新节点</span></span><br><span class="line">            DoubleNode* newNode = <span class="keyword">new</span> <span class="built_in">DoubleNode</span>(key, val1);</span><br><span class="line">            keyNodeMap[key] = newNode;</span><br><span class="line">            nodeList.<span class="built_in">addNode</span>(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 测试用例：创建容量为3的LRU缓存</span></span><br><span class="line">    <span class="function">LRU <span class="title">cache</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 访问 key 1，将其更新为最近使用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(1): &quot;</span> &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 100</span></span><br><span class="line">    <span class="comment">// 插入新数据，当缓存满时会淘汰最久未使用的 key（此时 key 2 被淘汰）</span></span><br><span class="line">    cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 尝试获取被淘汰的 key 2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(2): &quot;</span> &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 -1，表示不存在</span></span><br><span class="line">    <span class="comment">// 继续获取其他 key 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(3): &quot;</span> &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 300</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get(4): &quot;</span> &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">4</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二进制位"><a href="#二进制位" class="headerlink" title="二进制位"></a>二进制位</h3><h4 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h4><p>判断某一个数是否存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	arr[num/<span class="number">32</span>] |= <span class="number">1</span>&lt;&lt;(num%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	arr[num/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(num%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	arr[num/<span class="number">32</span>] ^= <span class="number">1</span>&lt;&lt;(num%<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arr[num/<span class="number">32</span>] &amp; (<span class="number">1</span>&lt;&lt;(num%<span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="type">int</span> set[(n + <span class="number">32</span> - <span class="number">1</span>) / <span class="number">32</span>]; <span class="comment">// 表示存储n个数需要的大小</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位运算实现四则运算"><a href="#位运算实现四则运算" class="headerlink" title="位运算实现四则运算"></a>位运算实现四则运算</h4><p>加速运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无进位相加</span></span><br><span class="line">        ans = n ^ m;</span><br><span class="line">        <span class="comment">// 计算进位，注意进位要左移一位</span></span><br><span class="line">        m = (n &amp; m) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        n = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">neg</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对 n 取反后加 1 得到 -n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minus1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(n, <span class="built_in">neg</span>(m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((m &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = <span class="built_in">add</span>(ans, n);</span><br><span class="line">        &#125;</span><br><span class="line">        n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转为正数处理，保存符号信息</span></span><br><span class="line">    <span class="type">int</span> a = n &lt; <span class="number">0</span> ? <span class="built_in">neg</span>(n) : n;</span><br><span class="line">    <span class="type">int</span> b = m &lt; <span class="number">0</span> ? <span class="built_in">neg</span>(m) : m;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从最高位开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = <span class="built_in">minus1</span>(i, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 判断 a 右移 i 位后是否大于等于 b</span></span><br><span class="line">        <span class="keyword">if</span>((a &gt;&gt; i) &gt;= b) &#123;</span><br><span class="line">            <span class="comment">// 减去 b 左移 i 位</span></span><br><span class="line">            a = <span class="built_in">minus1</span>(a, (b &lt;&lt; i));</span><br><span class="line">            <span class="comment">// 将结果对应位设为1</span></span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 n 与 m 符号不同，则结果取负</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ^ (m &lt; <span class="number">0</span>) ? <span class="built_in">neg</span>(ans) : ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完整版</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == INT_MIN &amp;&amp; b == INT_MIN) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a != INT_MIN &amp;&amp; b != INT_MIN) <span class="keyword">return</span> <span class="built_in">div1</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span>(b == INT_MIN) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 除数为 INT_MIN，其它数除以它的商为0</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="built_in">neg</span>(<span class="number">1</span>)) <span class="keyword">return</span> INT_MAX;  <span class="comment">// 防止 INT_MIN / -1 溢出</span></span><br><span class="line">    <span class="comment">// 近似处理：调整 a 的值</span></span><br><span class="line">    a = <span class="built_in">add</span>(a, b &gt; <span class="number">0</span> ? b : <span class="built_in">neg</span>(b));</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">div1</span>(a, b);</span><br><span class="line">    <span class="comment">// 根据除数的正负决定偏移</span></span><br><span class="line">    <span class="type">int</span> offset = b &gt; <span class="number">0</span> ? <span class="built_in">neg</span>(<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(ans, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="位运算骚操作"><a href="#位运算骚操作" class="headerlink" title="位运算骚操作"></a>位运算骚操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//判断一个数是不是2的幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jurge1</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; n == (n&amp;(-n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断一个数是不是3的幂</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1162261467</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jurge2</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; M%n==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求大于等于n的最小2次幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	n--;</span><br><span class="line">	n |= n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	n |= n&gt;&gt;<span class="number">2</span>;</span><br><span class="line">	n |= n&gt;&gt;<span class="number">4</span>;</span><br><span class="line">	n |= n&gt;&gt;<span class="number">8</span>;</span><br><span class="line">	n |= n&gt;&gt;<span class="number">16</span>;;</span><br><span class="line">	<span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//逆序二进制状态</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F2</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	n= ((n&amp;<span class="number">0xaaaaaaaa</span>)&gt;&gt;<span class="number">1</span>) | ((n&amp;<span class="number">0x55555555</span>)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	n= ((n&amp;<span class="number">0xcccccccc</span>)&gt;&gt;<span class="number">2</span>) | ((n&amp;<span class="number">0x33333333</span>)&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	n= ((n&amp;<span class="number">0xf0f0f0f0</span>)&gt;&gt;<span class="number">4</span>) | ((n&amp;<span class="number">0x0f0f0f0f</span>)&lt;&lt;<span class="number">4</span>);</span><br><span class="line">	n= ((n&amp;<span class="number">0xff00ff00</span>)&gt;&gt;<span class="number">8</span>) | ((n&amp;<span class="number">0x00ff00ff</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">	n = (n&gt;&gt;<span class="number">16</span>) | (n&lt;&lt;<span class="number">16</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回n的二进制中有几个1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F3</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	n = (n&amp;<span class="number">0x55555555</span>)+((n&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0x55555555</span>);</span><br><span class="line">	n = (n&amp;<span class="number">0x33333333</span>)+((n&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0x33333333</span>);</span><br><span class="line">	n = (n&amp;<span class="number">0x0f0f0f0f</span>)+((n&gt;&gt;<span class="number">4</span>)&amp;<span class="number">0x0f0f0f0f</span>);</span><br><span class="line">	n = (n&amp;<span class="number">0x00ff00ff</span>)+((n&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0x00ff00ff</span>);</span><br><span class="line">	n = (n&amp;<span class="number">0x0000ffff</span>)+((n&gt;&gt;<span class="number">18</span>)&amp;<span class="number">0x0000ffff</span>);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求x到y的所有数&amp;的结果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F4</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(y&gt;x)&#123;</span><br><span class="line">		y -= y &amp;(-y);</span><br><span class="line">	&#125;<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Brain-Kernighan算法"><a href="#Brain-Kernighan算法" class="headerlink" title="Brain Kernighan算法"></a>Brain Kernighan算法</h3><p>异或技巧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500</span></span><br><span class="line"><span class="type">int</span> a1[M];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">// 以下两个全局变量用于功能1：两个出现次数为奇数次的数字</span></span><br><span class="line"><span class="type">int</span> ero1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ero2 = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    ero1 = <span class="number">0</span>;</span><br><span class="line">    ero2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算所有数字的异或结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        ero1 ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到最右侧的1</span></span><br><span class="line">    <span class="type">int</span> rightone = ero1 &amp; (-ero1);</span><br><span class="line">    <span class="comment">// 根据该位是否为1将数字分组，并对其中一组异或</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] &amp; rightone) == <span class="number">0</span>) &#123;</span><br><span class="line">            ero2 ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 另一个奇数次数字</span></span><br><span class="line">    ero1 = ero1 ^ ero2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以下全局变量用于功能2：求数组中出现次数少于 cnt 次的数字</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bits[<span class="number">32</span>];  <span class="comment">// 用于统计各二进制位1的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> cnt, <span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bits, <span class="number">0</span>, <span class="built_in">sizeof</span>(bits));</span><br><span class="line">    <span class="comment">// 统计每一位的1的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 等价于：if(a[i] &amp; (1 &lt;&lt; j)) bits[j]++;</span></span><br><span class="line">            bits[j] += (a[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每一位判断是否为目标数字的1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[j] % cnt) &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表基本操作"><a href="#链表基本操作" class="headerlink" title="链表基本操作"></a>链表基本操作</h3><h4 id="返回两个无环链表相交的第一个节点"><a href="#返回两个无环链表相交的第一个节点" class="headerlink" title="返回两个无环链表相交的第一个节点"></a>返回两个无环链表相交的第一个节点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode *next;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回两个无环链表相交的第一个节点</span></span><br><span class="line"><span class="function">LinkNode *<span class="title">converge</span><span class="params">(LinkNode *&amp;L1,LinkNode *&amp;L2)</span></span>&#123;</span><br><span class="line">    LinkNode *p1=L1-&gt;next;</span><br><span class="line">    LinkNode *p2=L2-&gt;next;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L1==<span class="literal">nullptr</span> || L2==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cnt--;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p1=L1;</span><br><span class="line">    p2=L2;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(cnt--) p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cnt=<span class="built_in">abs</span>(cnt);</span><br><span class="line">        <span class="keyword">while</span>(cnt--) p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1!=p2 &amp;&amp; p1!=<span class="literal">nullptr</span> &amp;&amp; p2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">        p2=p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="每k个节点一组翻转链表"><a href="#每k个节点一组翻转链表" class="headerlink" title="每k个节点一组翻转链表"></a>每k个节点一组翻转链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每k个节点一组翻转链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> k, LinkNode *&amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">1</span> || L==<span class="literal">nullptr</span> || L-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    LinkNode *p1=L-&gt;next;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;k) <span class="keyword">return</span>;</span><br><span class="line">    p1=L;</span><br><span class="line">    LinkNode *pre;</span><br><span class="line">    LinkNode *p;</span><br><span class="line">    LinkNode *pp;</span><br><span class="line">    LinkNode *p0=L;</span><br><span class="line">    LinkNode *last=p0-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) p1=p1-&gt;next;</span><br><span class="line">    p=p0-&gt;next;</span><br><span class="line">    pp=p-&gt;next;</span><br><span class="line">    p-&gt;next=p1-&gt;next;</span><br><span class="line">    pre=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">        p=pp;</span><br><span class="line">        pp=p-&gt;next;</span><br><span class="line">        p-&gt;next=pre;</span><br><span class="line">        pre=p;</span><br><span class="line">    &#125;</span><br><span class="line">    p0-&gt;next=p1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=cnt-k;j&gt;=k;j-=k)&#123;</span><br><span class="line">        p0=last;</span><br><span class="line">        p1=last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) p1=p1-&gt;next;</span><br><span class="line">        p=p0-&gt;next;</span><br><span class="line">        last=p;</span><br><span class="line">        pp=p-&gt;next;</span><br><span class="line">        p-&gt;next=p1-&gt;next;</span><br><span class="line">        pre=p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            p=pp;</span><br><span class="line">            pp=p-&gt;next;</span><br><span class="line">            p-&gt;next=pre;</span><br><span class="line">            pre=p;</span><br><span class="line">        &#125;</span><br><span class="line">        p0-&gt;next=p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复制带随机指针的链表"><a href="#复制带随机指针的链表" class="headerlink" title="复制带随机指针的链表"></a>复制带随机指针的链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制带随机指针的链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NodeR</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    NodeR *next;</span><br><span class="line">    NodeR *random;</span><br><span class="line">    <span class="built_in">NodeR</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">        next=<span class="literal">nullptr</span>;</span><br><span class="line">        random=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">NodeR * <span class="title">copy</span><span class="params">(NodeR *&amp;L1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L1==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    NodeR* cur=L1-&gt;next;</span><br><span class="line">    <span class="comment">//复制节点并插入原节点之后</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        NodeR* next=<span class="keyword">new</span> <span class="built_in">NodeR</span>(cur-&gt;val);</span><br><span class="line">        next-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=next;</span><br><span class="line">        cur=next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新节点的随机指针</span></span><br><span class="line">    cur=L1-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;random!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur-&gt;next-&gt;random=cur-&gt;random;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分离链表</span></span><br><span class="line">    cur=L1-&gt;next;</span><br><span class="line">    NodeR* L2=<span class="keyword">new</span> <span class="built_in">NodeR</span>(<span class="number">0</span>);</span><br><span class="line">    NodeR* temp=L2;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        temp-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断是否是回文结构（快慢指针）"><a href="#判断是否是回文结构（快慢指针）" class="headerlink" title="判断是否是回文结构（快慢指针）"></a>判断是否是回文结构（快慢指针）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断链表是否是回文结构（快慢指针）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge_HuiWen</span><span class="params">(LinkNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">nullptr</span> || L-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//快慢指针找中点</span></span><br><span class="line">    LinkNode* f=L;</span><br><span class="line">    LinkNode* s=L;</span><br><span class="line">    <span class="keyword">while</span>(f!=<span class="literal">nullptr</span> &amp;&amp; f-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        f=f-&gt;next-&gt;next;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//翻转</span></span><br><span class="line">    LinkNode* pre=s;</span><br><span class="line">    LinkNode* cur=s-&gt;next;</span><br><span class="line">    LinkNode* next=<span class="literal">nullptr</span>;</span><br><span class="line">    pre-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断回文</span></span><br><span class="line">    <span class="type">bool</span> ans=<span class="literal">true</span>;</span><br><span class="line">    LinkNode* sta1=L-&gt;next;</span><br><span class="line">    LinkNode* sta2=pre;</span><br><span class="line">    <span class="keyword">while</span>(sta1!=<span class="literal">nullptr</span> &amp;&amp; sta2!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sta1-&gt;val!=sta2-&gt;val)&#123;</span><br><span class="line">            ans=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sta1=sta1-&gt;next;</span><br><span class="line">        sta2=sta2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//还原</span></span><br><span class="line">    cur=pre-&gt;next;</span><br><span class="line">    pre-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=pre;</span><br><span class="line">        pre=cur;</span><br><span class="line">        cur=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="返回第一个入环节点"><a href="#返回第一个入环节点" class="headerlink" title="返回第一个入环节点"></a>返回第一个入环节点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回链表的第一个入环节点</span></span><br><span class="line"><span class="function">LinkNode* <span class="title">cycle</span><span class="params">(LinkNode *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || L-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode* f=L;</span><br><span class="line">    LinkNode* s=L;</span><br><span class="line">    <span class="keyword">while</span>(f!=<span class="literal">nullptr</span> &amp;&amp; f-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        s=s-&gt;next;</span><br><span class="line">        f=f-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(s==f)&#123;</span><br><span class="line">            f=L;</span><br><span class="line">            <span class="keyword">while</span>(f!=s)&#123;</span><br><span class="line">                f=f-&gt;next;</span><br><span class="line">                s=s-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在链表上排序，时间复杂度O（n*logn），额外空间复杂度（1），排序有稳定性</span></span><br><span class="line"><span class="function">LinkNode* <span class="title">createNode</span><span class="params">(<span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">LinkNode</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在链表尾部添加节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">appendNode</span><span class="params">(LinkNode*&amp; head, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    LinkNode* newNode = <span class="built_in">createNode</span>(data);</span><br><span class="line">    LinkNode* temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    temp-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line">LinkNode* start;</span><br><span class="line">LinkNode* end1;</span><br><span class="line"><span class="function">LinkNode* <span class="title">FindEnd</span><span class="params">(LinkNode* l,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; --len!=<span class="number">0</span>)&#123;</span><br><span class="line">        l=l-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(LinkNode* l1, LinkNode* r1, LinkNode* l2, LinkNode* r2)</span> </span>&#123;</span><br><span class="line">    LinkNode* pre;</span><br><span class="line">    <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        start = l1;</span><br><span class="line">        pre = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        start = l2;</span><br><span class="line">        pre = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            pre-&gt;next = l1;</span><br><span class="line">            pre = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre-&gt;next = l2;</span><br><span class="line">            pre = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;next = l1;</span><br><span class="line">        end1 = r1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;next = l2;</span><br><span class="line">        end1 = r2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(LinkNode*&amp; L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || L-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    LinkNode* temp=L;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode* l1;</span><br><span class="line">    LinkNode* r1;</span><br><span class="line">    LinkNode* l2;</span><br><span class="line">    LinkNode* r2;</span><br><span class="line">    LinkNode* lastTeamend;</span><br><span class="line">    LinkNode* next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        l1=L;</span><br><span class="line">        r1=<span class="built_in">FindEnd</span>(l1,i);</span><br><span class="line">        l2=r1-&gt;next;</span><br><span class="line">        r2=<span class="built_in">FindEnd</span>(l2,i);</span><br><span class="line">        next = r2-&gt;next;</span><br><span class="line">        r1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        r2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">merge</span>(l1,r1,l2,r2);</span><br><span class="line">        L=start;</span><br><span class="line">        lastTeamend=end1;</span><br><span class="line">        <span class="keyword">while</span>(next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            l1=next;</span><br><span class="line">            r1=<span class="built_in">FindEnd</span>(l1,i);</span><br><span class="line">        	l2 = r1-&gt;next;</span><br><span class="line">        	<span class="keyword">if</span>(l2==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        		lastTeamend-&gt;next = l1;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">            r2 = <span class="built_in">FindEnd</span>(l2, i);</span><br><span class="line">            next = r2-&gt;next;</span><br><span class="line">            r1-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            r2-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="built_in">merge</span>(l1,r1,l2,r2);</span><br><span class="line">            lastTeamend-&gt;next=start;</span><br><span class="line">            lastTeamend=end1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="合并n个有序链表"><a href="#合并n个有序链表" class="headerlink" title="合并n个有序链表"></a>合并n个有序链表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode * next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(ListNode *&amp;q)</span></span>&#123;</span><br><span class="line">    q=(ListNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">    q-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a,ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode *<span class="title">merge</span><span class="params">(vector&lt;ListNode*&gt;&amp; v1)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt; pq1;</span><br><span class="line">    <span class="keyword">for</span>(ListNode* it : v1) <span class="keyword">if</span>(it) pq1.<span class="built_in">push</span>(it);</span><br><span class="line">    ListNode* ans;</span><br><span class="line">    <span class="built_in">Create</span>(ans);</span><br><span class="line">    ListNode* temp;</span><br><span class="line">    ListNode* pre=ans;</span><br><span class="line">    <span class="keyword">while</span>(!pq1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        temp=pq1.<span class="built_in">top</span>();</span><br><span class="line">        pq1.<span class="built_in">pop</span>();</span><br><span class="line">        pre-&gt;next=temp;</span><br><span class="line">        pre=temp;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;next) pq1.<span class="built_in">push</span>(temp-&gt;next);</span><br><span class="line">    &#125;pre-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    ListNode* pre;</span><br><span class="line">    <span class="type">int</span> temp1;</span><br><span class="line">    vector&lt;ListNode*&gt; v1;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin&gt;&gt;cnt;</span><br><span class="line">        ListNode * l=(ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">        l-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        pre=l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">            cin&gt;&gt;temp1;</span><br><span class="line">            ListNode *temp=(ListNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ListNode));</span><br><span class="line">            temp-&gt;val=temp1;</span><br><span class="line">            temp-&gt;next=pre-&gt;next;</span><br><span class="line">            pre-&gt;next=temp;</span><br><span class="line">            pre=temp;</span><br><span class="line">        &#125;v1.<span class="built_in">push_back</span>(l-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode * <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">Create</span>(<span class="keyword">final</span>);</span><br><span class="line">    <span class="keyword">final</span>=<span class="built_in">merge</span>(v1);</span><br><span class="line">    pre=<span class="keyword">final</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(pre)&#123;</span><br><span class="line">        cout&lt;&lt;pre-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        pre=pre-&gt;next;</span><br><span class="line">    &#125;cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h3><p>离线加速处理查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, id, blk;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">original</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">ans</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    	cin &gt;&gt; original[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 离散化</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; temp = original;</span><br><span class="line">    <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>()+<span class="number">1</span>, temp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(temp[m] != temp[i])&#123;</span><br><span class="line">    		temp[++ m] = temp[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    	<span class="type">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">    	<span class="type">int</span> mid, ans;</span><br><span class="line">    	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">    		mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    		<span class="keyword">if</span>(temp[mid] &lt;= x)&#123;</span><br><span class="line">    			ans = mid;</span><br><span class="line">    			l = mid + <span class="number">1</span>;</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			r = mid - <span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 莫队函数</span></span><br><span class="line">    <span class="type">int</span> now_ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fre</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">    	<span class="type">int</span> &amp; f = fre[<span class="built_in">find</span>(x)];</span><br><span class="line">    	<span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">	        now_ans++;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">2</span>) &#123;</span><br><span class="line">	        now_ans--;</span><br><span class="line">	    &#125;</span><br><span class="line">        f++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> remove = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">    	<span class="type">int</span> &amp;f = fre[<span class="built_in">find</span>(x)];</span><br><span class="line">	    <span class="keyword">if</span> (f == <span class="number">2</span>) &#123;</span><br><span class="line">	        now_ans--;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">3</span>) &#123;</span><br><span class="line">	        now_ans++;</span><br><span class="line">	    &#125;</span><br><span class="line">        f--;</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="comment">// 窗口优化</span></span><br><span class="line">    <span class="type">int</span> blk = (<span class="type">int</span>)<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="function">vector&lt;Query&gt; <span class="title">queries</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; queries[i].l &gt;&gt; queries[i].r;</span><br><span class="line">        queries[i].id = i;</span><br><span class="line">        queries[i].blk = queries[i].l / blk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(queries.<span class="built_in">begin</span>(), queries.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> Query &amp;A, <span class="type">const</span> Query &amp;B) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.blk == B.blk) <span class="keyword">return</span> A.r &lt; B.r;</span><br><span class="line">        <span class="keyword">return</span> A.blk &lt; B.blk;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> curL = <span class="number">1</span>, curR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;q : queries) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curR &lt; q.r) <span class="built_in">add</span>(original[++curR]);</span><br><span class="line">        <span class="keyword">while</span> (curR &gt; q.r) <span class="built_in">remove</span>(original[curR--]);</span><br><span class="line">        <span class="keyword">while</span> (curL &lt; q.l) <span class="built_in">remove</span>(original[curL++]);</span><br><span class="line">        <span class="keyword">while</span> (curL &gt; q.l) <span class="built_in">add</span>(original[--curL]);</span><br><span class="line">        ans[q.id] = now_ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>字符匹配匹配加速，加速的点在于匹配失败后不一定直接返回起点重新匹配，而是跳到最大前缀处，如<code>abab......</code>匹配失败时，会跳到2位置而不是0位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">int</span>(s1.<span class="built_in">size</span>());</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">int</span>(s2.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next1</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i1 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> mark1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i1 &lt;= m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2[i1 - <span class="number">1</span>] == s2[mark1])&#123;</span><br><span class="line">            next1[i1++] = ++ mark1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mark1 != <span class="number">0</span>)&#123;</span><br><span class="line">            mark1 = next1[mark1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            next1[i1++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j1 = i1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j1 &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[j1] == s2[i1])&#123;</span><br><span class="line">            j1 ++, i1 ++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i1 != <span class="number">0</span>)&#123;</span><br><span class="line">            i1 = next1[i1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j1 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i1 == m)&#123;</span><br><span class="line">            cout &lt;&lt; j1 - i1 + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            i1 = next1[i1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)&#123;</span><br><span class="line">    	cout &lt;&lt; next1[i];</span><br><span class="line">    	<span class="keyword">if</span>(i != m) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="manacher算法"><a href="#manacher算法" class="headerlink" title="manacher算法"></a>manacher算法</h3><p>以某一节点为中心向两端扩展的最大回文串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function">string <span class="title">manacherss</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	string ss = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">		ss += s[i];</span><br><span class="line">		ss += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	string ss = <span class="built_in">manacherss</span>(s);</span><br><span class="line">	<span class="type">int</span> n = ss.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r1</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 真实回文串的长度为r[i] - 1;</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>, c = <span class="number">0</span>, len; i &lt; n; i ++)&#123;</span><br><span class="line">		len = r &gt; i ? <span class="built_in">min</span>(r1[<span class="number">2</span> * c - i], r - i) : <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i - len &gt;= <span class="number">0</span> &amp;&amp; i + len &lt; n &amp;&amp; ss[i - len] == ss[i + len])&#123;</span><br><span class="line">			len ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(len + i &gt; r)&#123;</span><br><span class="line">			r = len + i;</span><br><span class="line">			c = i;</span><br><span class="line">		&#125;</span><br><span class="line">		r1[i] = len;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, len);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">	     <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h3><p>对于一个长度为n的字符串s，定义函数z[i]表示s和s[i, n - 1]的最长公共前缀（LCP）的长度则z被成为s的Z函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P5410</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Z1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; z, string s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	z[<span class="number">0</span>] = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, c = <span class="number">1</span>, r = <span class="number">1</span>, len; i &lt; n; i ++)&#123;</span><br><span class="line">		len = r &gt; i ? <span class="built_in">min</span>(z[i - c], r - i) : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i + len &lt; n &amp;&amp; s[len] == s[i + len])&#123;</span><br><span class="line">			len ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i + len &gt; r)&#123;</span><br><span class="line">			r = i + len;</span><br><span class="line">			c = i;</span><br><span class="line">		&#125;</span><br><span class="line">		z[i] = len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">E1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; e, vector&lt;<span class="type">int</span>&gt; &amp; z, string s1, string s2, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>, c = <span class="number">0</span>, len; i &lt; n; i ++)&#123;</span><br><span class="line">		len = r &gt; i ? <span class="built_in">min</span>(z[i - c], r - i) : <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i + len &lt; n &amp;&amp; s1[i + len] == s2[len])&#123;</span><br><span class="line">			len ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i + len &gt; r)&#123;</span><br><span class="line">			r = i + len;</span><br><span class="line">			c = i;</span><br><span class="line">		&#125;</span><br><span class="line">		e[i] = len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">	<span class="comment">// 求得该字符串的最长前缀</span></span><br><span class="line">	<span class="type">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Z</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="built_in">Z1</span>(Z, s2, n);</span><br><span class="line">	<span class="comment">// 求该串以某一串为基准的最长前缀</span></span><br><span class="line">	<span class="type">int</span> m = s1.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">E</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="built_in">E1</span>(E, Z, s1, s2, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态数组版本</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">150001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M2 = <span class="number">28</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pass1[M];</span><br><span class="line"><span class="type">int</span> end1[M];</span><br><span class="line"><span class="type">int</span> t1[M][M2];</span><br><span class="line"><span class="type">int</span> op1;</span><br><span class="line">string op2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(t1, <span class="number">0</span>, <span class="built_in">sizeof</span>(t1));</span><br><span class="line">    <span class="built_in">memset</span>(end1, <span class="number">0</span>, <span class="built_in">sizeof</span>(end1));</span><br><span class="line">    <span class="built_in">memset</span>(pass1, <span class="number">0</span>, <span class="built_in">sizeof</span>(pass1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    pass1[cur]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> path = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1[cur][path]==<span class="number">0</span>)&#123;</span><br><span class="line">            t1[cur][path]=++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=t1[cur][path];</span><br><span class="line">        pass1[cur]++;</span><br><span class="line">    &#125;end1[cur]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;<span class="type">int</span> path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        path=word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1[cur][path]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=t1[cur][path];</span><br><span class="line">    &#125;<span class="keyword">return</span> end1[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> string&amp; word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">search</span>(word)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> path;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            path = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(--pass1[t1[cur][path]]==<span class="number">0</span>)&#123;</span><br><span class="line">                t1[cur][path]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//  之后会重新分配节点，所以遍历不到未减减的end</span></span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;cur=t1[cur][path];</span><br><span class="line">        &#125;</span><br><span class="line">        end1[cur]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefixNumber</span><span class="params">(<span class="type">const</span> string&amp; pre)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pre.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        path = pre[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1[cur][path]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=t1[cur][path];</span><br><span class="line">    &#125;<span class="keyword">return</span> pass1[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">stoi</span>(line);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="built_in">getline</span>(cin, line);</span><br><span class="line">            <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">            <span class="type">int</span> op;</span><br><span class="line">            string word;</span><br><span class="line">            ss &gt;&gt; op &gt;&gt; word;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">insert</span>(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">erase</span>(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">                cout &lt;&lt; (<span class="built_in">search</span>(word) &gt; <span class="number">0</span> ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="built_in">prefixNumber</span>(word) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3796</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span>;</span><br><span class="line"><span class="type">int</span> cnt1;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fail1</span><span class="params">(N)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">tree1</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">end1</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">times1</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span></span>; <span class="comment">// BFS队列实现</span></span><br><span class="line"><span class="comment">//  链式前向星</span></span><br><span class="line"><span class="type">int</span> cnt2;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next1</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">to</span><span class="params">(N)</span></span>;</span><br><span class="line">string s1;</span><br><span class="line"><span class="comment">// 构建前缀树</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">F1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;string&gt; <span class="title">s1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	string temp1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; temp1;</span><br><span class="line">        s1[i] = temp1; </span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>, y; j &lt; temp1.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">            y = temp1[j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(tree1[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                tree1[x][y] = ++cnt1;</span><br><span class="line">            &#125;</span><br><span class="line">            x = tree1[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        end1[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建自动机</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// BFS遍历</span></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree1[<span class="number">0</span>][i] != <span class="number">0</span>)&#123;</span><br><span class="line">            v1[r++] = tree1[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        u = v1[l ++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tree1[u][i] == <span class="number">0</span>)&#123;</span><br><span class="line">                tree1[u][i] = tree1[fail1[u]][i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                fail1[tree1[u][i]] = tree1[fail1[u]][i];</span><br><span class="line">                v1[r ++] = tree1[u][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反向建图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    next1[++cnt2] = head[u];</span><br><span class="line">    head[u] = cnt2;</span><br><span class="line">    to[cnt2] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计次数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F3</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> e = head[x]; e &gt; <span class="number">0</span>; e = next1[e])&#123;</span><br><span class="line">        <span class="built_in">F3</span>(to[e]);</span><br><span class="line">        times1[x] += times1[to[e]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)&#123;</span><br><span class="line">			tree1[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cnt2 = cnt1 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">fill</span>(head.<span class="built_in">begin</span>(), head.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fill</span>(times1.<span class="built_in">begin</span>(), times1.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">fill</span>(fail1.<span class="built_in">begin</span>(), fail1.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line">    vector&lt;string&gt; ss = <span class="built_in">F1</span>();</span><br><span class="line">    <span class="built_in">F2</span>();</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, u = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        u = tree1[u][s1[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        times1[u] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt1; i ++)&#123;</span><br><span class="line">        <span class="built_in">add1</span>(fail1[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">F3</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> max1 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(times1[end1[i]] &gt; max1)&#123;</span><br><span class="line">        	max1 = times1[end1[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; max1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(times1[end1[i]] == max1)&#123;</span><br><span class="line">    		cout &lt;&lt; ss[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">    	<span class="built_in">solve</span>();</span><br><span class="line">    	cin &gt;&gt; n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3370</span></span><br><span class="line"><span class="comment">// 利用质数进制信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="type">int</span> base = <span class="number">39127</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">v</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans;</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; <span class="string">&#x27;9&#x27;</span> &gt;= c)&#123;</span><br><span class="line">		ans = c - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; <span class="string">&#x27;z&#x27;</span> &gt;= c)&#123;</span><br><span class="line">		ans = c - <span class="string">&#x27;a&#x27;</span> + <span class="number">11</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		ans = c - <span class="string">&#x27;A&#x27;</span> + <span class="number">37</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加速进制</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="built_in">v</span>(s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">		ans = ans * base + <span class="built_in">v</span>(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n)</span></span>;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		v1[i] = <span class="built_in">F</span>(s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(v1[i] != v1[i - <span class="number">1</span>])&#123;</span><br><span class="line">			ans ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// https://www.luogu.com.cn/record/204776127</span></span><br><span class="line"><span class="comment">// 要求一段区间内的hash值，用前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">H</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; hash, vector&lt;<span class="type">int</span>&gt; &amp; power, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		l = hash[l - <span class="number">1</span>] * power[r - l + <span class="number">1</span>]; </span><br><span class="line">	&#125;</span><br><span class="line">	r = hash[r];</span><br><span class="line">	<span class="keyword">return</span> r - l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1 &gt;&gt; s2;	</span><br><span class="line">	<span class="type">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash1</span><span class="params">(n)</span>, <span class="title">hash2</span><span class="params">(m)</span>, <span class="title">power</span><span class="params">(max(n, m))</span></span>;</span><br><span class="line">	power[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; power.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">		power[i] = power[i - <span class="number">1</span>] * base;</span><br><span class="line">	&#125;	</span><br><span class="line">	hash1[<span class="number">0</span>] = s1[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		hash1[i] = hash1[i - <span class="number">1</span>] * base + s1[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	hash2[<span class="number">0</span>] = s2[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++)&#123;</span><br><span class="line">		hash2[i] = hash2[i - <span class="number">1</span>] * base + s2[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l1, l2, r1;</span><br><span class="line">	<span class="type">int</span> l, r, len, mid;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i ++)&#123;</span><br><span class="line">		l1 = i, r1 = i + m - <span class="number">1</span>;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		l2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(l1 &lt;= r1 &amp;&amp; k &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">			l = l1, r = r1;</span><br><span class="line">			len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">				mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">H</span>(hash1, power, l1, mid) == <span class="built_in">H</span>(hash2, power, l2, l2 + mid - l1))&#123;</span><br><span class="line">					len = mid - l1 + <span class="number">1</span>;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					r = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(l1 + len &lt;= r1)&#123;</span><br><span class="line">				k ++;</span><br><span class="line">				l1 += len + <span class="number">1</span>;</span><br><span class="line">				l2 += len + <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(k &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">			ans ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异或哈希"><a href="#异或哈希" class="headerlink" title="异或哈希"></a>异或哈希</h3><p>题目大概描述：给定一个数字序列a，请你找出最长的连续子区间，使得这个子区间内所有数字的乘积是一个完全平方数。如果存在多个长度相同的子区间，选择最靠左的一个。</p>
<p>完全平方数可以差分为质因数乘积，且所有质因数的个数均为偶数。</p>
<p>故把每一个数的值改为落单质因数的哈希值，如果某一个区间的异或值为0，就说明该区间的质因数都是偶数，说明乘积是一个完全平方数，利用前缀和思想可以加速这一查找过程（当一个状态第一次出现时，记录位置，以后每次出现都说明中间与第一次出现的位置的间隔为一个完全平方数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spf</span><span class="params">(N)</span></span>; <span class="comment">// 最小质因子</span></span><br><span class="line"><span class="function">vector&lt;ull&gt; <span class="title">prime_hash</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">init</span><span class="params">()</span> </span>= [&amp;]()&#123;</span><br><span class="line">	<span class="built_in">iota</span>(spf.<span class="built_in">begin</span>(), spf.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(spf[i] == i)&#123;</span><br><span class="line">            prime_hash[i] = <span class="built_in">rng</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt; N; j += i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(spf[j] == j)&#123;</span><br><span class="line">                    spf[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据最小质因子求某一个数的hash值</span></span><br><span class="line"><span class="keyword">auto</span> get_hash = [&amp;](<span class="type">int</span> x) -&gt; ull &#123;</span><br><span class="line">    ull ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> p = spf[x];</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x % p == <span class="number">0</span>)&#123;</span><br><span class="line">            x /= p;</span><br><span class="line">            cnt ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans ^= prime_hash[p];		</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ull&gt; <span class="title">pref</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    pref[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; v1[i];</span><br><span class="line">        pref[i] = pref[i - <span class="number">1</span>] ^ <span class="built_in">get_hash</span>(v1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;ull,<span class="type">int</span>&gt; pos;</span><br><span class="line">    pos[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, l = <span class="number">-1</span>, r = <span class="number">-1</span>;</span><br><span class="line">    ull x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        x = pref[i];</span><br><span class="line">        <span class="keyword">if</span>(pos.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - pos[x] &gt; ans)&#123;</span><br><span class="line">                ans = i - pos[x];</span><br><span class="line">                l = pos[x] + <span class="number">1</span>, r = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pos[x] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="质数-素数"><a href="#质数-素数" class="headerlink" title="质数&#x2F;素数"></a>质数&#x2F;素数</h3><h4 id="质数判别"><a href="#质数判别" class="headerlink" title="质数判别"></a>质数判别</h4><p>Miller Rabin的时间复杂度为$O(log\ n)^{3}$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 普通判别方法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">p</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; n % <span class="number">6</span> != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sqrt1 = (<span class="type">int</span>) <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= sqrt1; i += <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> || n % (i + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Miller Rabin Prime判别法</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="comment">// 大数的时候用</span></span><br><span class="line"><span class="comment">//typedef __int128 ll;</span></span><br><span class="line">vector&lt;ll&gt; primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>&#125;;</span><br><span class="line"><span class="function">ll <span class="title">power</span><span class="params">(ll base, ll exp, ll mod)</span> </span>&#123;</span><br><span class="line">    ll result = <span class="number">1</span>;</span><br><span class="line">    base %= mod;</span><br><span class="line">    <span class="keyword">while</span> (exp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp &amp; <span class="number">1</span>) result = (result * base) % mod;</span><br><span class="line">        base = (base * base) % mod;</span><br><span class="line">        exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">witness</span><span class="params">(ll a, ll n)</span> </span>&#123;</span><br><span class="line">    ll u = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((u &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        t++;</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x = <span class="built_in">power</span>(a, u, n);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        x = (x * x) % n;</span><br><span class="line">        <span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">millerRabin</span><span class="params">(ll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll p : primes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">witness</span>(p, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线性质数筛"><a href="#线性质数筛" class="headerlink" title="线性质数筛"></a>线性质数筛</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 质数筛</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i ++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x % i != <span class="number">0</span>)&#123;</span><br><span class="line">			v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">			<span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) v1.<span class="built_in">push_back</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求数值小于等于n的质数的个数,</span></span><br><span class="line"><span class="comment">// 质数筛-埃氏筛</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">  	cin &gt;&gt; n;</span><br><span class="line">  	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">	v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (v[i] == <span class="number">0</span>)&#123;</span><br><span class="line">	    	<span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i) v[j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!v[i]) cnt++;</span><br><span class="line">  	&#125;</span><br><span class="line">  	cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只是计数的话，埃氏筛还能改进</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ehrlich2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = (n + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 估计质数数量(奇数)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i * i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += <span class="number">2</span> * i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visit[j]) &#123;</span><br><span class="line">                    visit[j] = <span class="literal">true</span>;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线性筛法计算每个数字的最小质因子 `spf`（smallest prime factor）</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spf</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">init</span><span class="params">()</span> </span>= [&amp;]()&#123;</span><br><span class="line">	<span class="built_in">iota</span>(spf.<span class="built_in">begin</span>(), spf.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(spf[i] == i)&#123;</span><br><span class="line">            prime_hash[i] = <span class="built_in">rng</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i &lt;&lt; <span class="number">1</span>; j &lt; N; j += i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(spf[j] == j)&#123;</span><br><span class="line">                    spf[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 欧拉筛时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime</span><span class="params">(n / <span class="number">2</span> + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">            prime[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">    			<span class="comment">// 保证每个合数只被最小的质数遍历一次</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Pick定理"><a href="#Pick定理" class="headerlink" title="Pick定理"></a>Pick定理</h3><p><code>S = i + b / 2 - 1</code></p>
<p><code>S</code>：图形的面积（可以是实数）；</p>
<p><code>i</code>：图形内部的格点数；</p>
<p><code>b</code>：图形边界上的格点数（包括顶点）；</p>
<p>给定两个整数点<code>(x1, y1), (y1, y2)</code>,  两点间（包括端点)的格点数为<code>gcd(|x2 - x1|, |y2 - y1|) + 1</code></p>
<p>则求某区域内的格点数的方法为<code>i = S − 2 / b + 1</code></p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>对区间进行快速加法操作</p>
<h4 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若有原数组则要分开处理，最后加上原数组或者进行以下处理</span></span><br><span class="line">v[i] = original[i] - original[i - <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">	v[l] += x;</span><br><span class="line">	v[r + <span class="number">1</span>] -= x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    v[i] += v[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和原数组分开处理，最后加上原数组，或者进行以下处理</span></span><br><span class="line">v[i][j] = a[i][j] - a[i - <span class="number">1</span>][j] - a[i][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v)</span></span>&#123;</span><br><span class="line">	v[x1][y1] += val;</span><br><span class="line">    v[x2 + <span class="number">1</span>][y1] -= val;</span><br><span class="line">    v[x1][y2 + <span class="number">1</span>] -= val;</span><br><span class="line">    v[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊差分"><a href="#特殊差分" class="headerlink" title="特殊差分"></a>特殊差分</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">2</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span>, <span class="title">v2</span><span class="params">(N)</span>, <span class="title">v3</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">	<span class="comment">// cin.tie(nullptr);</span></span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="built_in">fill</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fill</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">fill</span>(v3.<span class="built_in">begin</span>(), v3.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, op, st; i &lt;= m; i ++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;op, &amp;st);</span><br><span class="line">			<span class="comment">// add (1 1 1 1 1 1)</span></span><br><span class="line">			v1[st] ++;</span><br><span class="line">			<span class="comment">// add (1 2 3 4 5 6)</span></span><br><span class="line">			<span class="keyword">if</span>(op == <span class="number">2</span>) v2[st + <span class="number">1</span>] ++;</span><br><span class="line">			<span class="comment">// add (1 4 9 16 25 36)</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="number">3</span>) v2[st + <span class="number">1</span>] += <span class="number">3</span>, v3[st + <span class="number">2</span>] += <span class="number">2</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			v3[i] = (v3[i - <span class="number">1</span>] + v3[i]) % mod;</span><br><span class="line">			v2[i] = (v2[i] + v2[i - <span class="number">1</span>] + v3[i]) % mod;</span><br><span class="line">			v1[i] = (v1[i] + v1[i - <span class="number">1</span>] + v2[i]) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, v1[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列-数组问题"><a href="#序列-数组问题" class="headerlink" title="序列&#x2F;数组问题"></a>序列&#x2F;数组问题</h3><h4 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h4><p>递归&#x2F;递推+路径</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">string s1, s2;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">1001</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1001</span>, <span class="number">-1</span>));</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == n || j == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j] != <span class="number">-1</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(&#123;<span class="built_in">F1</span>(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="number">1</span>, <span class="built_in">F1</span>(i + <span class="number">1</span>, j), <span class="built_in">F1</span>(i , j + <span class="number">1</span>)&#125;);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(<span class="built_in">F1</span>(i + <span class="number">1</span>, j), <span class="built_in">F1</span>(i, j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递推版</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[ j - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][ j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求路径</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n, j = m; i &amp;&amp; j;)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])&#123;</span><br><span class="line">    		s += s1[i - <span class="number">1</span>];</span><br><span class="line">    		i --;</span><br><span class="line">    		j --;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="keyword">if</span>(dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>]) i --;</span><br><span class="line">    		<span class="keyword">else</span> j --;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">    	cout &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i ++, j --) <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><p>两个序列包含完全相同的数字使，可以将一个数组的顺序映射到另一个数组上，这时其最长公共子序列变成求最长递增子序列问题（或者反向求最长递减子序列）</p>
<h5 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; v[mid]) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">temp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        temp[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; v2[i];  </span><br><span class="line">        v2[i] = temp[v2[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n, x; i; i --)&#123;</span><br><span class="line">        x = <span class="built_in">F1</span>(v2[i], ans);</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(v2[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[x] = v2[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="字典序最小版"><a href="#字典序最小版" class="headerlink" title="字典序最小版"></a>字典序最小版</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F1</span><span class="params">(<span class="type">int</span> x, vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; v[mid])&#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			r = mid - <span class="number">1</span>;</span><br><span class="line">			ans = mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : v1) cin &gt;&gt; x;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, ans; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">		ans = <span class="built_in">F1</span>(v1[i], v2);</span><br><span class="line">		<span class="keyword">if</span>(ans == <span class="number">-1</span>)&#123;</span><br><span class="line">			v2.<span class="built_in">push_back</span>(v1[i]);</span><br><span class="line">			dp[i] = v2.<span class="built_in">size</span>();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			v2[ans] = v1[i];</span><br><span class="line">			dp[i] = ans + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = v2.<span class="built_in">size</span>();</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m, <span class="number">1e9</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : dp) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, x; i &lt; n; i ++)&#123;</span><br><span class="line">		x = dp[i];</span><br><span class="line">		<span class="keyword">if</span>(x == m) ans[<span class="number">0</span>] = v1[i];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[m - x - <span class="number">1</span>] &lt; v1[i])&#123;</span><br><span class="line">				ans[m - x] = v1[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)&#123;</span><br><span class="line">		cout &lt;&lt; ans[i];</span><br><span class="line">		<span class="keyword">if</span>(i != m) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="累加和不大于k的最长子数组"><a href="#累加和不大于k的最长子数组" class="headerlink" title="累加和不大于k的最长子数组"></a>累加和不大于k的最长子数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) cin &gt;&gt; x;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">min1</span><span class="params">(n)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minend</span><span class="params">(n)</span></span>;</span><br><span class="line">	min1[n - <span class="number">1</span>] = v1[n - <span class="number">1</span>];</span><br><span class="line">	minend[n - <span class="number">1</span>] = n - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i --)&#123;</span><br><span class="line">		<span class="keyword">if</span>(min1[i + <span class="number">1</span>] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">			min1[i] = v1[i] + min1[i + <span class="number">1</span>];</span><br><span class="line">			minend[i] = minend[i + <span class="number">1</span>];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			min1[i] = v1[i];</span><br><span class="line">			minend[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, sum1 = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(r &lt; n  &amp;&amp; sum1 + min1[r] &lt;= k)&#123;</span><br><span class="line">			sum1 += min1[r];</span><br><span class="line">			r = minend[r] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(r &gt; i)&#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, r - i);</span><br><span class="line">			sum1 -= v1[i];</span><br><span class="line">		&#125;<span class="keyword">else</span> r = i + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><h4 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数位dp https://www.luogu.com.cn/problem/P2602</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> cur, temp = n, l, r = <span class="number">1</span>; temp; r *= <span class="number">10</span>, temp /= <span class="number">10</span>)&#123;</span><br><span class="line">        cur = temp % <span class="number">10</span>;</span><br><span class="line">        l = temp / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(d == <span class="number">0</span>) l --;</span><br><span class="line">        ans += l * r;</span><br><span class="line">        <span class="keyword">if</span>(d &lt; cur)&#123;</span><br><span class="line">            ans += r;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d == cur)&#123;</span><br><span class="line">            ans += n % r + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">F</span>(r, i) - <span class="built_in">F</span>(l - <span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">9</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3413</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j; i &lt; s.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        j = i - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((j &gt;= <span class="number">0</span> &amp;&amp; s[j] == s[i]) || s[i] == s[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计0-n中所有不是回文数的数 f1表示是否选过数 f2表示是否可以任意选</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F</span><span class="params">(<span class="type">int</span> i1, string s, <span class="type">int</span> l, <span class="type">int</span> ll, <span class="type">bool</span> f1, <span class="type">bool</span> f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!f1)&#123;</span><br><span class="line">        ans = (ans + <span class="built_in">F</span>(i1 + <span class="number">1</span>, s, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">        <span class="keyword">if</span>(!f2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s[i1] - <span class="string">&#x27;0&#x27;</span>; i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != l &amp;&amp; i != ll)&#123;</span><br><span class="line">                    ans = (ans + <span class="built_in">F</span>(i1 + <span class="number">1</span>, s, i, l, <span class="literal">true</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i1] - <span class="string">&#x27;0&#x27;</span> != l &amp;&amp; s[i1] - <span class="string">&#x27;0&#x27;</span> != ll) ans = (ans + <span class="built_in">F</span>(i1 + <span class="number">1</span>, s, s[i1] - <span class="string">&#x27;0&#x27;</span>, l, <span class="literal">true</span>, <span class="literal">false</span>)) % mod;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">if</span>(++i1 != s.<span class="built_in">size</span>()) sum *= <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">while</span>(++i1 &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                sum = (sum * <span class="number">8</span>) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s[i1] - <span class="string">&#x27;0&#x27;</span>; i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != l &amp;&amp; i != ll)&#123;</span><br><span class="line">                    ans = (ans + <span class="built_in">F</span>(i1 + <span class="number">1</span>, s, i, l, <span class="literal">true</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i1] - <span class="string">&#x27;0&#x27;</span> != l &amp;&amp; s[i1] - <span class="string">&#x27;0&#x27;</span> != ll) ans = (ans + <span class="built_in">F</span>(i1 + <span class="number">1</span>, s, s[i1] - <span class="string">&#x27;0&#x27;</span>, l, <span class="literal">true</span>, <span class="literal">false</span>)) % mod;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> sum;</span><br><span class="line">            <span class="keyword">if</span>(ll == <span class="number">-1</span>)&#123;</span><br><span class="line">                sum = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">while</span>(++ i1 &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    sum = (sum * <span class="number">8</span>) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum = <span class="number">8</span>;</span><br><span class="line">                <span class="keyword">while</span>(++ i1 &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    sum = (sum * <span class="number">8</span>) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统计0-n中的所有数 f1表示是否选过数 f2表示是否可以任意选</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">F2</span><span class="params">(<span class="type">int</span> i1, string s, <span class="type">bool</span> f1, <span class="type">bool</span> f2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i1 == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!f1)&#123;</span><br><span class="line">        ans = (ans + <span class="built_in">F2</span>(i1 + <span class="number">1</span>, s, <span class="literal">false</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">        <span class="keyword">if</span>(!f2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s[i1] - <span class="string">&#x27;0&#x27;</span>; i ++)&#123;</span><br><span class="line">                ans = (ans + <span class="built_in">F2</span>(i1 + <span class="number">1</span>, s, <span class="literal">true</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + <span class="built_in">F2</span>(i1 + <span class="number">1</span>, s, <span class="literal">true</span>, <span class="literal">false</span>)) % mod;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">9</span>; <span class="comment">// 不能为零</span></span><br><span class="line">            <span class="keyword">while</span>(++ i1 &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                sum = (sum * <span class="number">10</span>) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f2)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s[i1] - <span class="string">&#x27;0&#x27;</span>; i ++)&#123;</span><br><span class="line">                ans = (ans + <span class="built_in">F2</span>(i1 + <span class="number">1</span>, s, <span class="literal">true</span>, <span class="literal">true</span>)) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + <span class="built_in">F2</span>(i1 + <span class="number">1</span>, s, <span class="literal">true</span>, <span class="literal">false</span>)) % mod;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">10</span>; <span class="comment">// 能为零</span></span><br><span class="line">            <span class="keyword">while</span>(++ i1 &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                sum = (sum * <span class="number">10</span>) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + sum) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="built_in">F</span>(<span class="number">0</span>, s1, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n2 = <span class="built_in">F</span>(<span class="number">0</span>, s2, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> ans1 = (n2 - n1  + <span class="built_in">is</span>(s1) + mod) % mod;</span><br><span class="line">    <span class="type">int</span> n3 = <span class="built_in">F2</span>(<span class="number">0</span>, s1, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n4 = <span class="built_in">F2</span>(<span class="number">0</span>, s2, <span class="literal">false</span> ,<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> ans2 = (n4 - n3 + <span class="number">1</span> + mod) % mod;</span><br><span class="line">    cout &lt;&lt; (ans2 - ans1 + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树形DP-1"><a href="#树形DP-1" class="headerlink" title="树形DP"></a>树形DP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// https://pintia.cn/problem-sets/1859417373569925120/exam/problems/type/7?problemSetProblemId=1859417373590896646</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my</span>&#123;</span><br><span class="line">	<span class="type">int</span> w, b;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; qw, qb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	cin &gt;&gt; n;</span><br><span class="line">    	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">color</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">val</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">root</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    	<span class="function">vector <span class="title">adj</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    		<span class="type">int</span> m;</span><br><span class="line">    		cin &gt;&gt; color[i] &gt;&gt; val[i] &gt;&gt; m;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++)&#123;</span><br><span class="line">    			<span class="type">int</span> v;</span><br><span class="line">    			cin &gt;&gt; v;</span><br><span class="line">    			adj[i].<span class="built_in">push_back</span>(v);</span><br><span class="line">    			root[v] --;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 传回可以被改色的节点</span></span><br><span class="line">		<span class="keyword">auto</span> F = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> u) -&gt; my &#123;</span><br><span class="line">			<span class="type">int</span> w1 = <span class="number">0</span>, b1 = <span class="number">0</span>;</span><br><span class="line">			priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; qw1, qb1;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[u])&#123;</span><br><span class="line">				my temp = <span class="built_in">f</span>(f, v);</span><br><span class="line">				w1 += temp.w;</span><br><span class="line">				b1 += temp.b;</span><br><span class="line">				<span class="keyword">while</span>(!temp.qw.<span class="built_in">empty</span>())&#123;</span><br><span class="line">					qw1.<span class="built_in">push</span>(temp.qw.<span class="built_in">top</span>());</span><br><span class="line">					temp.qw.<span class="built_in">pop</span>();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">while</span>(!temp.qb.<span class="built_in">empty</span>())&#123;</span><br><span class="line">					qb1.<span class="built_in">push</span>(temp.qb.<span class="built_in">top</span>());</span><br><span class="line">					temp.qb.<span class="built_in">pop</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; w1 &lt;&lt; &quot; &quot; &lt;&lt; b1 &lt;&lt;  &quot;\n&quot;;</span></span><br><span class="line">			<span class="comment">// priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; q11 = qw1, q22 = qb1;</span></span><br><span class="line">			<span class="comment">// cout &lt;&lt; &quot;w: &quot;;</span></span><br><span class="line">			<span class="comment">// while(!q11.empty())&#123;</span></span><br><span class="line">				<span class="comment">// cout &lt;&lt; q11.top() &lt;&lt; &quot; &quot;;</span></span><br><span class="line">				<span class="comment">// q11.pop();</span></span><br><span class="line">			<span class="comment">// &#125;cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">			<span class="comment">// cout &lt;&lt; &quot;b: &quot;;</span></span><br><span class="line">			<span class="comment">// while(!q22.empty())&#123;</span></span><br><span class="line">				<span class="comment">// cout &lt;&lt; q22.top() &lt;&lt; &quot; &quot;;</span></span><br><span class="line">				<span class="comment">// q22.pop();</span></span><br><span class="line">			<span class="comment">// &#125;cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">			my temp;</span><br><span class="line">			priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; q1, q2;</span><br><span class="line">			temp.w = temp.b = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(color[u] == <span class="number">0</span>)&#123;</span><br><span class="line">				temp.w ++;</span><br><span class="line">				q1.<span class="built_in">push</span>(val[u]);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				temp.b ++;</span><br><span class="line">				q2.<span class="built_in">push</span>(val[u]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(w1 != b1)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">abs</span>(w1 - b1) == <span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(w1 &gt; b1)&#123;</span><br><span class="line">						q1.<span class="built_in">push</span>(qw1.<span class="built_in">top</span>());</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						q2.<span class="built_in">push</span>(qb1.<span class="built_in">top</span>());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">while</span>(<span class="built_in">abs</span>(w1 - b1) &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">						<span class="keyword">if</span>(w1 &gt; b1)&#123;</span><br><span class="line">							ans += qw1.<span class="built_in">top</span>();</span><br><span class="line">							qw1.<span class="built_in">pop</span>();</span><br><span class="line">							w1 --, b1 ++;</span><br><span class="line">						&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">							ans += qb1.<span class="built_in">top</span>();</span><br><span class="line">							qb1.<span class="built_in">pop</span>();</span><br><span class="line">							w1 --, b1 ++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			temp.qw = q1, temp.qb = q2;</span><br><span class="line">			temp.w += w1, temp.b += b1;</span><br><span class="line">			<span class="keyword">return</span> temp;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(root[i] == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">F</span>(F, i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><p>一般的区间DP是$O(n^{4})$复杂度，但可以在第三层时通过搜索优化达到$O(n^{3}log\ n)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108298/I</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">pre</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">		pre[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v1[i], pre[i] = pre[i - <span class="number">1</span>] + v1[i];</span><br><span class="line">		<span class="function">vector <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, vector(n + <span class="number">1</span>, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;()))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dp[i][i].<span class="built_in">push_back</span>(&#123;<span class="number">0ll</span>, <span class="number">0ll</span>&#125;);</span><br><span class="line">		<span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp; v) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="type">int</span> l = <span class="number">0</span>, r = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> mid, ans = <span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">				mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(v[mid].sc &lt;= x) &#123;</span><br><span class="line">					ans = v[mid].fr;</span><br><span class="line">					l = mid + <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>, dif, val_l, val_r, cost, cost_l, cost_r; len &lt;= n; len ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r = l + len - <span class="number">1</span>; r &lt;= n; l ++, r ++) &#123;</span><br><span class="line">                <span class="comment">// 优化位置</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k ++) &#123;</span><br><span class="line">					val_l = pre[k] - pre[l - <span class="number">1</span>], val_r = pre[r] - pre[k];</span><br><span class="line">					dif = <span class="built_in">abs</span>(val_l - val_r);</span><br><span class="line">					<span class="type">int</span> cost = <span class="built_in">min</span>(val_l, val_r) * <span class="built_in">ceil</span>(<span class="built_in">log2</span>(val_l + val_r));</span><br><span class="line">                    <span class="comment">// 快速搜索</span></span><br><span class="line">					cost_l = <span class="built_in">get</span>(dif, dp[l][k]), cost_r = <span class="built_in">get</span>(dif, dp[k + <span class="number">1</span>][r]);</span><br><span class="line">					<span class="keyword">if</span>(len == n) &#123;</span><br><span class="line">						<span class="keyword">if</span>(cost_l == <span class="number">-1</span> || cost_r == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">						<span class="keyword">else</span> cout &lt;&lt; cost_l + cost + cost_r &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(cost_l == <span class="number">-1</span> || cost_r == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					dp[l][r].<span class="built_in">push_back</span>(&#123;cost_l + cost + cost_r, dif&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 优化策略</span></span><br><span class="line">				<span class="built_in">sort</span>(dp[l][r].<span class="built_in">begin</span>(), dp[l][r].<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp; b)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a.sc == b.sc) <span class="keyword">return</span> a.fr &lt; b.fr;</span><br><span class="line">					<span class="keyword">return</span> a.sc &lt; b.sc;</span><br><span class="line">				&#125;);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp[l][r].<span class="built_in">size</span>(); i ++) dp[l][r][i].fr = <span class="built_in">min</span>(dp[l][r][i].fr, dp[l][r][i - <span class="number">1</span>].fr);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状压DP"><a href="#状压DP" class="headerlink" title="状压DP"></a>状压DP</h4><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><p>当状态数为2的幂，base为$2^{n - 1}$</p>
<p>二状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> set = [](<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> val) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  x &amp; (~(<span class="number">1</span> &lt;&lt; i)) | (val &lt;&lt; i);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> get = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>四状态</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> set = [](<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> val) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (~(<span class="number">3</span> &lt;&lt; (i &lt;&lt; <span class="number">1</span>))) | (val &lt;&lt; (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> get = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="built_in">return</span> (x &gt;&gt; (i &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="三进制"><a href="#三进制" class="headerlink" title="三进制"></a>三进制</h5><p>可扩展至所有进制，状态数为$3^{n}$，转移至下一位时bit要乘上进制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> sta, <span class="type">int</span> bit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sta / bit % <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">set</span><span class="params">(<span class="type">int</span> sta, <span class="type">int</span> bit, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sta - <span class="built_in">get</span>(sta, bit) * bit + val * bit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong></p>
<ul>
<li>状态空间小（n ≤ 20），用位掩码（mask，int类型）表示子集（$2^n$ ≤ 1&lt;&lt;20 ≈ 1e6）。</li>
<li>常见问题：TSP（旅行商）、子集和&#x2F;覆盖、背包变种、图匹配等。</li>
<li>时间复杂度：O($2^n * n^2$) 或 O($3^n$)（子集枚举），空间 O($2^n * n$)。</li>
</ul>
<p><strong>核心思路</strong></p>
<ul>
<li><strong>状态定义</strong>：dp[mask] 或 dp[mask][i]（mask表示已用子集，i表示当前状态如位置）。</li>
<li><strong>初始化</strong>：dp[0] &#x3D; 0;（空集起点），其余INF。</li>
<li><strong>转移</strong>：<ul>
<li>枚举子集：对每个mask，枚举子mask（<code>for(int sub = mask; sub; sub = (sub-1)&amp;mask</code>）。</li>
<li>或DP顺序：从小mask到大mask。</li>
</ul>
</li>
<li><strong>优化</strong>：FWT（快速沃尔什变换）用于卷积；SOS DP用于子集和查询。</li>
</ul>
<p><strong>基础模板：TSP-like（dp[mask][u]）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span>&lt;&lt;N][N];  <span class="comment">// dp[mask][u]: 访问mask子集，结束于u的最优值</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 输入：dist[i][j] 为 i到j的边权（完整图）</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));  <span class="comment">// 全INF</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">1</span>&lt;&lt;i][i] = <span class="number">0</span>;  <span class="comment">// 起点每个点</span></span><br><span class="line">    <span class="comment">// DP</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span>&lt;&lt;n); mask++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[mask][u] &gt;= INF) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;v)) <span class="keyword">continue</span>;  <span class="comment">// 已访问</span></span><br><span class="line">                <span class="type">int</span> nmask = mask | (<span class="number">1</span>&lt;&lt;v);</span><br><span class="line">                dp[nmask][v] = <span class="built_in">min</span>(dp[nmask][v], dp[mask][u] + dist[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 答案：min over u dp[(1&lt;&lt;n)-1][u] + back to start</span></span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; n; u++) ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][u]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>变种</strong>：起点固定dp[1&lt;&lt;0][0] &#x3D; 0;，mask从0开始。</li>
<li><strong>复杂度</strong>：O($2^n * n^2$)。</li>
</ul>
<p><strong>子集枚举模板（SOS DP）</strong></p>
<p>用于计算每个mask的子集和&#x2F;或。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理：子集DP（O(n * 2^n)）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sos_dp</span><span class="params">(<span class="type">int</span> f[<span class="number">1</span>&lt;&lt;N])</span> </span>&#123;  <span class="comment">// f[mask] 更新为 sum over sub of f[sub]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span>&lt;&lt;n); mask++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;i)) f[mask] += f[mask ^ (<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 枚举mask的所有子集（O(3^n)总）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span>&lt;&lt;n); mask++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> sub = mask; sub &gt; <span class="number">0</span>; sub = (sub<span class="number">-1</span>) &amp; mask) &#123;</span><br><span class="line">        <span class="comment">// 用sub作为子集</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sub=0单独处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>逆操作</strong>：减法代替加法。</li>
</ul>
<p><strong>单维dp[mask]模板（子集覆盖&#x2F;和）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dp[<span class="number">1</span>&lt;&lt;N];  <span class="comment">// dp[mask]: mask子集的最优值（如最小成本覆盖）</span></span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span>&lt;&lt;n); mask++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[mask] &gt;= INF) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 枚举未用位k</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mask &amp; (<span class="number">1</span>&lt;&lt;k)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> nmask = mask | (<span class="number">1</span>&lt;&lt;k);  <span class="comment">// 或 | precomp[k]（预计算影响位）</span></span><br><span class="line">        dp[nmask] = <span class="built_in">min</span>(dp[nmask], dp[mask] + cost[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>优化</strong>：如果转移是固定模式，用子集枚举加速。</li>
</ul>
<p><strong>常见技巧</strong></p>
<ul>
<li><strong>位运算</strong>：<ul>
<li>检查位：<code>(mask &amp; (1&lt;&lt;i))</code></li>
<li>计数位：<code>__builtin_popcount(mask)</code></li>
<li>低位&#x2F;高位：<code>mask &amp; -mask</code>（最低位）</li>
</ul>
</li>
<li><strong>初始化</strong>：<code>fill(dp, dp+(1&lt;&lt;n), INF);</code> 或 <code>memset</code>。</li>
<li><strong>多测试</strong>：预计算全局DP（如代码中），每个test O(1)或O(n)。</li>
<li><strong>空间优化</strong>：如果n&#x3D;16，用<code>vector&lt;vector&lt;int&gt;&gt; dp(16, vector&lt;int&gt;(1&lt;&lt;16, INF));</code>（如代码）。</li>
<li><strong>调试</strong>：从小n测试；打印mask二进制<code>for(int i=0;i&lt;n;i++) if(mask&amp;(1&lt;&lt;i)) ...</code>。</li>
</ul>
<p><strong>扩展：代码中变种（dp[i][mask]，i固定起点）</strong></p>
<p>如提供的代码：dp2[x][sta] 表示从x开始覆盖sta的最小成本。</p>
<ul>
<li>初始化单点：<code>dp[x][1&lt;&lt;x] = init_cost;</code></li>
<li>转移：<code>dp[x][sta] = min over y in sta, y!=x: dp[y][sta^(1&lt;&lt;x)] + dp_edge[y][x]</code></li>
<li>顺序：按sta大小递增，或用子集DP。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://codeforces.com/gym/105578/problem/E</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 2^16 = 65536，状态集大小</span></span><br><span class="line"><span class="function">vector <span class="title">dp2</span><span class="params">(<span class="number">16</span>, vector&lt;<span class="type">int</span>&gt;(N, <span class="number">1e18</span>))</span></span>;  <span class="comment">// dp2[x][sta]: 覆盖sta子集（sta表示需要覆盖的差值掩码集合），以x结束的最小成本（x属于sta）</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	cin &gt;&gt; t;  <span class="comment">// 读取测试用例数T</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(<span class="number">4</span>)</span></span>;  <span class="comment">// val[0..3]: 四种操作成本 a0单细胞,a1整行,a2整列,a3全翻</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : val) cin &gt;&gt; x;</span><br><span class="line">	<span class="comment">// 第一部分：构建状态图的APSP，dp[i][j]: 从状态i到j的最小非空序列成本（净XOR为i^j）</span></span><br><span class="line">	<span class="function">vector <span class="title">dp</span><span class="params">(<span class="number">16</span>, vector&lt;<span class="type">int</span>&gt;(<span class="number">16</span>, <span class="number">1e18</span>))</span></span>;  <span class="comment">// dp[16][16]: 状态间最短路径</span></span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">mid1</span>(<span class="number">9</span>);  <span class="comment">// 9种操作：4单细胞+2行+2列+1全</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++) mid1[i] = &#123;<span class="number">1</span> &lt;&lt; i, val[<span class="number">0</span>]&#125;;  <span class="comment">// 单细胞操作掩码</span></span><br><span class="line">	mid1[<span class="number">4</span>] = &#123;<span class="number">3</span>, val[<span class="number">1</span>]&#125;;   <span class="comment">// 上行: 0011b</span></span><br><span class="line">	mid1[<span class="number">5</span>] = &#123;<span class="number">12</span>, val[<span class="number">1</span>]&#125;;  <span class="comment">// 下行: 1100b</span></span><br><span class="line">	mid1[<span class="number">6</span>] = &#123;<span class="number">5</span>, val[<span class="number">2</span>]&#125;;   <span class="comment">// 左列: 0101b</span></span><br><span class="line">	mid1[<span class="number">7</span>] = &#123;<span class="number">10</span>, val[<span class="number">2</span>]&#125;;  <span class="comment">// 右列: 1010b</span></span><br><span class="line">	mid1[<span class="number">8</span>] = &#123;<span class="number">15</span>, val[<span class="number">3</span>]&#125;;  <span class="comment">// 全翻: 1111b</span></span><br><span class="line">	<span class="type">int</span> min1 = <span class="built_in">min</span>(&#123;val[<span class="number">0</span>], val[<span class="number">1</span>], val[<span class="number">2</span>], val[<span class="number">3</span>]&#125;);  <span class="comment">// 最 cheap 操作成本</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) dp[i][i] = <span class="number">2</span> * min1;  <span class="comment">// 对角线：返回原状态的最小非空成本（两次相同最cheap操作）</span></span><br><span class="line">	<span class="comment">// 添加单步边：从i到i^mask，成本c</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j ++) &#123;</span><br><span class="line">			dp[i][i ^ mid1[j].fr] = mid1[j].sc;  <span class="comment">// 注意：可能覆盖已有边，取min</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Floyd-Warshall：计算所有i到j的最小非空路径成本</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid = <span class="number">0</span>; mid &lt; <span class="number">16</span>; mid ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j ++) &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][mid] + dp[mid][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第二部分：TSP-like DP on subsets of required deltas</span></span><br><span class="line">	<span class="comment">// dp2[x][sta]: 从0开始，访问路径覆盖sta中所有点，以x结束的最小成本（仅保证sta点被访问，中间可能多）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; N; sta ++) &#123;  <span class="comment">// 枚举子集sta（按数值递增，确保子问题已解）</span></span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; v1;  <span class="comment">// sta中设置的位（需要覆盖的delta掩码）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>((sta &gt;&gt; i) &amp; <span class="number">1</span>) v1.<span class="built_in">push_back</span>(i); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(v1.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;  <span class="comment">// 基况：单个点k，从0到k的成本</span></span><br><span class="line">			dp2[v1[<span class="number">0</span>]][sta] = <span class="built_in">min</span>(dp2[v1[<span class="number">0</span>]][sta], dp[<span class="number">0</span>][v1[<span class="number">0</span>]]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 转移：最后一个点x，从前一子集sta\x的某个y到x</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; y : v1) &#123;</span><br><span class="line">					<span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="type">int</span> sub_sta = sta ^ (<span class="number">1</span> &lt;&lt; x);  <span class="comment">// 子集去掉x</span></span><br><span class="line">					dp2[x][sta] = <span class="built_in">min</span>(dp2[x][sta], dp2[y][sub_sta] + dp[y][x]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理T个测试用例（预计算全局DP，每个test O(m)）</span></span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n;  <span class="comment">// m: 可能初始网格数</span></span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; v1;  <span class="comment">// 每个网格的需要翻转掩码（0-15）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">			<span class="type">int</span> y = <span class="number">0</span>;  <span class="comment">// 构建4位掩码：需要翻转的位置（off位）</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;  <span class="comment">// 读取4个char：行1 col1, 行1 col2, 行2 col1, 行2 col2</span></span><br><span class="line">				<span class="type">char</span> c;</span><br><span class="line">				cin &gt;&gt; c;</span><br><span class="line">				<span class="type">int</span> x = c - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 0或1</span></span><br><span class="line">				x ^= <span class="number">1</span>;  <span class="comment">// 翻转：off(&#x27;0&#x27;)需翻-&gt;1, on(&#x27;1&#x27;)无需-&gt;0</span></span><br><span class="line">				y = (y &lt;&lt; <span class="number">1</span>) + x;</span><br><span class="line">			&#125;</span><br><span class="line">			v1.<span class="built_in">push_back</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> sta1 = <span class="number">0</span>;  <span class="comment">// sta: 位图，表示哪些delta需要覆盖（bit k设若有初始需XOR k）</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) sta1 ^= (<span class="number">1</span> &lt;&lt; x);  <span class="comment">// XOR确保唯一（distinct grids）</span></span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1e18</span>;  <span class="comment">// 最小总成本</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) ans = <span class="built_in">min</span>(ans, dp2[x][sta1]);  <span class="comment">// min over 可能的结束点x（在v1中）</span></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>竞赛Tips</strong>：先估$2^n * n^2 $≤ 1e8；n&gt;20转其他（如分治）。复制模板改状态&#x2F;转移。</p>
<h4 id="轮廓线DP"><a href="#轮廓线DP" class="headerlink" title="轮廓线DP"></a>轮廓线DP</h4><p>解决不相邻放置问题。</p>
<p>位运算的几个简单操作：</p>
<p>得到状态s第j位的状态 : (s &gt;&gt; j) &amp; 1</p>
<p>把状态s第j位的状态设置成1，其他位置状态不变 : s &#x3D; s | (1 &lt;&lt; j)</p>
<p>把状态s第j位的状态设置成0，其他位置状态不变 : s &#x3D; s &amp; (~(1 &lt;&lt; j))</p>
<blockquote>
<p>状态占两位时：</p>
<p>得到状态s第j位的状态 : (x &gt;&gt; (j &lt;&lt; 1)) &amp; 3;</p>
<p>把状态s第j位的状态设置成val(0&#x2F;1&#x2F;2&#x2F;3)，其他位置状态不变 : s &#x3D; s &amp; (~(3 &lt;&lt; (j &lt;&lt; 1))) | (val &lt;&lt; (j &lt;&lt; 1));</p>
</blockquote>
<p>有递归版和压缩空间递推版，只要计算出空间不超过1e7，优先写递归版。</p>
<p>要根据递归版来初始化pre数组（相当于压缩的上一层状态），有时候会确定初始和结尾状态，要单独处理。</p>
<h5 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h5><p>上下左右状态不能连续，且各自本身要可取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P1879</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">14</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e8</span>;</span><br><span class="line"><span class="function">vector <span class="title">dp</span><span class="params">(N, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">13</span>, vector&lt;<span class="type">int</span>&gt;(<span class="number">13</span>, <span class="number">-1</span>)))</span></span>;</span><br><span class="line"><span class="function">vector <span class="title">dp2</span><span class="params">(N, vector&lt;<span class="type">int</span>&gt;(<span class="number">14</span>))</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function">vector <span class="title">v1</span><span class="params">(n + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">				cin &gt;&gt; v1[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m1;</span><br><span class="line">		<span class="keyword">auto</span> set1 = [](<span class="type">int</span> sta, <span class="type">int</span> in) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> sta | (<span class="number">1</span> &lt;&lt; in);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> set0 = [](<span class="type">int</span> sta, <span class="type">int</span> in) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> sta &amp; (~(<span class="number">1</span> &lt;&lt; in));</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> get = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="built_in">return</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 递归版</span></span><br><span class="line">		<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i1, <span class="type">int</span> sta, <span class="type">int</span> j1) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(j1 &gt; m) j1 = <span class="number">1</span>, i1 ++;</span><br><span class="line">			<span class="keyword">if</span>(i1 &gt; n) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; 	</span><br><span class="line">			<span class="keyword">if</span>(dp[sta][i1][j1] != <span class="number">-1</span>) <span class="keyword">return</span> dp[sta][i1][j1];</span><br><span class="line">			<span class="type">int</span> ans = <span class="built_in">f</span>(f, i1, <span class="built_in">set0</span>(sta, j1), j1 + <span class="number">1</span>);</span><br><span class="line">			<span class="type">bool</span> l = (j1 == <span class="number">1</span> || <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>) == <span class="number">0</span>);	</span><br><span class="line">			<span class="type">bool</span> r = <span class="built_in">get</span>(sta, j1) == <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(l &amp;&amp; r &amp;&amp; v1[i1][j1]) ans = (ans + <span class="built_in">f</span>(f, i1, <span class="built_in">set1</span>(sta, j1), j1 + <span class="number">1</span>)) % mod;</span><br><span class="line">			dp[sta][i1][j1] = ans;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 空间压缩版</span></span><br><span class="line">		<span class="type">int</span> n1 = <span class="number">1</span> &lt;&lt; (m + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">fill</span>(pre.<span class="built_in">begin</span>(), pre.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i1 = n; i1; i1 --) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">				dp2[sta][m + <span class="number">1</span>] = pre[sta];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j1 = m; j1; j1 --) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">					<span class="type">bool</span> l = (j1 == <span class="number">1</span> || <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>) == <span class="number">0</span>);	</span><br><span class="line">					<span class="type">bool</span> r = <span class="built_in">get</span>(sta, j1) == <span class="number">0</span>;</span><br><span class="line">					<span class="type">int</span> ans = dp2[<span class="built_in">set0</span>(sta, j1)][j1 + <span class="number">1</span>];</span><br><span class="line">					<span class="keyword">if</span>(l &amp;&amp; r &amp;&amp; v1[i1][j1]) ans = (ans + dp2[<span class="built_in">set1</span>(sta, j1)][j1 + <span class="number">1</span>]) % mod;</span><br><span class="line">					dp2[sta][j1] = ans;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">				pre[sta] = dp2[sta][<span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; dp2[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h5><p>八个方向不能连续，且总设置点&#x3D;k。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">11</span> | <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>][<span class="number">82</span>];</span><br><span class="line"><span class="type">int</span> dp2[N][<span class="number">11</span>][<span class="number">2</span>][<span class="number">82</span>];</span><br><span class="line"><span class="type">int</span> pre[N][<span class="number">82</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n, k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">auto</span> set0 = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x &amp; (~(<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> set1 = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> get = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="built_in">return</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 递归版</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)); i ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">0</span>; i1 &lt;= n; i1 ++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">0</span>; i2 &lt;= n; i2 ++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> i3 = <span class="number">0</span>; i3 &lt; <span class="number">2</span>; i3 ++) &#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> i4 = <span class="number">0</span>; i4 &lt;= k; i4 ++) &#123;</span><br><span class="line">							dp[i][i1][i2][i3][i4] = <span class="number">-1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i1, <span class="type">int</span> j1, <span class="type">int</span> sta, <span class="type">int</span> last, <span class="type">int</span> cnt1) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(j1 &gt; n) &#123;</span><br><span class="line">				j1 = <span class="number">1</span>;</span><br><span class="line">				i1 ++;</span><br><span class="line">				last = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i1 &gt; n) &#123;</span><br><span class="line">				<span class="keyword">return</span> cnt1 == k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(dp[sta][i1][j1][last][cnt1] != <span class="number">-1</span>) <span class="keyword">return</span> dp[sta][i1][j1][last][cnt1];</span><br><span class="line">			<span class="type">bool</span> l = <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>);</span><br><span class="line">			<span class="type">bool</span> up = <span class="built_in">get</span>(sta, j1);</span><br><span class="line">			<span class="type">bool</span> r = <span class="built_in">get</span>(sta, j1 + <span class="number">1</span>);</span><br><span class="line">			<span class="type">int</span> ans = <span class="built_in">f</span>(f, i1, j1 + <span class="number">1</span>, <span class="built_in">set0</span>(sta, j1), up, cnt1);</span><br><span class="line">			<span class="keyword">if</span>((j1 == <span class="number">1</span> || !l) &amp;&amp; !r &amp;&amp; !up &amp;&amp; !last &amp;&amp; cnt1 &lt; k) ans += <span class="built_in">f</span>(f, i1, j1 + <span class="number">1</span>, <span class="built_in">set1</span>(sta, j1), up, cnt1 + <span class="number">1</span>);</span><br><span class="line">			dp[sta][i1][j1][last][cnt1] = ans;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="comment">// 空间压缩版	</span></span><br><span class="line">		<span class="type">int</span> n1 = <span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>) ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt;= n1; sta ++) pre[sta][k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i1 = n; i1; i1 --) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt;= k; k1 ++) &#123;</span><br><span class="line">					dp2[sta][n + <span class="number">1</span>][<span class="number">0</span>][k1] = dp2[sta][n + <span class="number">1</span>][<span class="number">1</span>][k1] = pre[sta][k1];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j1 = n; j1; j1 --) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> last = <span class="number">0</span>; last &lt; <span class="number">2</span>; last ++) &#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt;= k; k1 ++) &#123;</span><br><span class="line">							<span class="type">bool</span> l = <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>);</span><br><span class="line">							<span class="type">bool</span> up = <span class="built_in">get</span>(sta, j1);</span><br><span class="line">							<span class="type">bool</span> r = <span class="built_in">get</span>(sta, j1 + <span class="number">1</span>);</span><br><span class="line">							<span class="type">int</span> ans = dp2[<span class="built_in">set0</span>(sta, j1)][j1 + <span class="number">1</span>][up][k1];</span><br><span class="line">							<span class="keyword">if</span>((j1 == <span class="number">1</span> || !l) &amp;&amp; !r &amp;&amp; !up &amp;&amp; !last &amp;&amp; k1 &lt; k) ans += dp2[<span class="built_in">set1</span>(sta, j1)][j1 + <span class="number">1</span>][up][k1 + <span class="number">1</span>];</span><br><span class="line">							dp2[sta][j1][last][k1] = ans;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt;= k; k1 ++) &#123;</span><br><span class="line">					pre[sta][k1] = dp2[sta][<span class="number">1</span>][<span class="number">0</span>][k1];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout &lt;&lt; dp2[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始和结尾状态确定，且状态有4种</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2435</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">376544743</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">101</span>][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> dp2[N][<span class="number">9</span>];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n, m, k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(m)</span>, <span class="title">v2</span><span class="params">(m)</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v2) cin &gt;&gt; x;</span><br><span class="line">		<span class="keyword">if</span>(k == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">bool</span> f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(v1[i] != v2[i]) &#123;</span><br><span class="line">						f = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">					<span class="keyword">if</span>(v1[i] == v2[i]) &#123;</span><br><span class="line">						f = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; f &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> set = [](<span class="type">int</span> x, <span class="type">int</span> i, <span class="type">int</span> val) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> x &amp; (~(<span class="number">3</span> &lt;&lt; (i &lt;&lt; <span class="number">1</span>))) | (val &lt;&lt; (i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">auto</span> get = [](<span class="type">int</span> x, <span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="built_in">return</span> (x &gt;&gt; (i &lt;&lt; <span class="number">1</span>)) &amp; <span class="number">3</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">int</span> sta1 = <span class="number">0</span>, sta2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) sta1 = <span class="built_in">set</span>(sta1, i, v1[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) sta2 = <span class="built_in">set</span>(sta2, i, v2[i]);</span><br><span class="line">		<span class="type">int</span> n1 = <span class="number">1</span> &lt;&lt; (m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">auto</span> diff = [&amp;](<span class="type">int</span> sta) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="type">bool</span> f = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">get</span>(sta, i) == <span class="built_in">get</span>(sta2, i)) &#123;</span><br><span class="line">					f = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 递归版</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">0</span>; i1 &lt; n; i1 ++) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j1 = <span class="number">0</span>; j1 &lt; m; j1 ++) &#123;</span><br><span class="line">					dp[sta][i1][j1] = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> &amp;&amp; f, <span class="type">int</span> i1, <span class="type">int</span> j1, <span class="type">int</span> sta) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(i1 == n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">diff</span>(sta);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(j1 == m) <span class="keyword">return</span> <span class="built_in">f</span>(f, i1 + <span class="number">1</span>, <span class="number">0</span>, sta);</span><br><span class="line">			<span class="keyword">if</span>(dp[sta][i1][j1] != <span class="number">-1</span>) <span class="keyword">return</span> dp[sta][i1][j1];</span><br><span class="line">			<span class="type">int</span> l = (j1 == <span class="number">0</span> ? <span class="number">-1</span> : <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>));</span><br><span class="line">			<span class="type">int</span> up = <span class="built_in">get</span>(sta, j1);</span><br><span class="line">			<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; k; k1 ++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(l != k1 &amp;&amp; up != k1) ans = (ans + <span class="built_in">f</span>(f, i1, j1 + <span class="number">1</span>, <span class="built_in">set</span>(sta, j1, k1))) % mod;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[sta][i1][j1] = ans;</span><br><span class="line">			<span class="keyword">return</span> ans;</span><br><span class="line">		&#125;;</span><br><span class="line">		cout &lt;&lt; <span class="built_in">dfs</span>(dfs, <span class="number">1</span>, <span class="number">0</span>, sta1) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		<span class="comment">// 空间压缩版</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) pre[sta] = <span class="built_in">diff</span>(sta);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i1 = n - <span class="number">2</span>; i1 &gt;= <span class="number">0</span>; i1 --) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) dp2[sta][m] = pre[sta];</span><br><span class="line">			<span class="keyword">if</span>(i1 == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j1 = m - <span class="number">1</span>; j1 &gt;= <span class="number">0</span>; j1 --) &#123;</span><br><span class="line">					<span class="type">int</span> l = (j1 == <span class="number">0</span> ? <span class="number">-1</span> : <span class="built_in">get</span>(sta1, j1 - <span class="number">1</span>));</span><br><span class="line">					<span class="type">int</span> up = <span class="built_in">get</span>(sta1, j1);</span><br><span class="line">					<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; k; k1 ++) &#123;</span><br><span class="line">						<span class="keyword">if</span>(l != k1 &amp;&amp; up != k1) ans = (ans + dp2[<span class="built_in">set</span>(sta1, j1, k1)][j1 + <span class="number">1</span>]) % mod;</span><br><span class="line">					&#125;</span><br><span class="line">					dp2[sta1][j1] = ans;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j1 = m - <span class="number">1</span>; j1 &gt;= <span class="number">0</span>; j1 --) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) &#123;</span><br><span class="line">					<span class="type">int</span> l = (j1 == <span class="number">0</span> ? <span class="number">-1</span> : <span class="built_in">get</span>(sta, j1 - <span class="number">1</span>));</span><br><span class="line">					<span class="type">int</span> up = <span class="built_in">get</span>(sta, j1);</span><br><span class="line">					<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; k; k1 ++) &#123;</span><br><span class="line">						<span class="keyword">if</span>(l != k1 &amp;&amp; up != k1) ans = (ans + dp2[<span class="built_in">set</span>(sta, j1, k1)][j1 + <span class="number">1</span>]) % mod;</span><br><span class="line">					&#125;</span><br><span class="line">					dp2[sta][j1] = ans;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> sta = <span class="number">0</span>; sta &lt; n1; sta ++) pre[sta] = dp2[sta][<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; dp2[sta1][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Fliegel–Van-Flandern-算法"><a href="#Fliegel–Van-Flandern-算法" class="headerlink" title="Fliegel–Van Flandern 算法"></a>Fliegel–Van Flandern 算法</h3><p>这个算法可以将从公元前4713年1月1日（即儒略日JD&#x3D;0）起计算的**儒略日数（JD）**转换为公历日期（年、月、日），并自动判断是在儒略历还是格里历中（1582年10月15日为切换点）。</p>
<ul>
<li>JD ≥ 2299161：采用<strong>格里历</strong>（即1582年10月15日之后）</li>
<li>JD &lt; 2299161：采用<strong>儒略历</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fliegel–Van Flandern 算法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">julianDayToDate</span><span class="params">(ll JD, ll &amp;day, ll &amp;month, ll &amp;year, <span class="type">bool</span> &amp;isBC)</span> </span>&#123;</span><br><span class="line">    ll A, B, C, D, E;</span><br><span class="line">    <span class="keyword">if</span> (JD &gt;= <span class="number">2299161</span>) &#123; </span><br><span class="line">        <span class="type">double</span> alpha = <span class="built_in">floor</span>((JD - <span class="number">1867216.25</span>) / <span class="number">36524.25</span>);</span><br><span class="line">        A = JD + <span class="number">1</span> + alpha - <span class="built_in">floor</span>(alpha / <span class="number">4.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        A = JD;</span><br><span class="line">    &#125;</span><br><span class="line">    B = A + <span class="number">1524</span>;</span><br><span class="line">    C = <span class="built_in">floor</span>((<span class="type">double</span>)(B - <span class="number">122.1</span>) / <span class="number">365.25</span>);</span><br><span class="line">    D = <span class="built_in">floor</span>(<span class="number">365.25</span> * (<span class="type">double</span>)C);</span><br><span class="line">    E = <span class="built_in">floor</span>((<span class="type">double</span>)(B - D) / <span class="number">30.6001</span>);</span><br><span class="line">    day = B - D - <span class="built_in">floor</span>(<span class="number">30.6001</span> * E);</span><br><span class="line">    <span class="keyword">if</span> (E &lt; <span class="number">14</span>)</span><br><span class="line">        month = E - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        month = E - <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (month &gt; <span class="number">2</span>)</span><br><span class="line">        year = C - <span class="number">4716</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        year = C - <span class="number">4715</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (year &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        isBC = <span class="literal">true</span>;</span><br><span class="line">        day = day;</span><br><span class="line">        month = month;</span><br><span class="line">        year = -(year) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        isBC = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll Q;</span><br><span class="line">    cin &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">        ll JD;</span><br><span class="line">        cin &gt;&gt; JD;</span><br><span class="line">        ll day, month, year;</span><br><span class="line">        <span class="type">bool</span> isBC = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">julianDayToDate</span>(JD, day, month, year, isBC);</span><br><span class="line">        <span class="keyword">if</span>(isBC)&#123;</span><br><span class="line">            cout &lt;&lt; day &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; year &lt;&lt; <span class="string">&quot; BC\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; day &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; year &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆波兰式"><a href="#逆波兰式" class="headerlink" title="逆波兰式"></a>逆波兰式</h3><p>逆波兰表达式（Reverse Polish Notation，简称 <code>RPN</code>），也称为后缀表达式，是一种将运算符放在操作数之后的数学表达方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod1 1000000007</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">stack1</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> size1;</span><br><span class="line">ll a;</span><br><span class="line">ll b;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    size1 = <span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin,s);</span><br><span class="line">    <span class="function">istringstream <span class="title">ios</span><span class="params">(s)</span></span>;</span><br><span class="line">    string token;</span><br><span class="line">    <span class="keyword">while</span>(ios &gt;&gt; token)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(token[<span class="number">0</span>]))&#123;</span><br><span class="line">            stack1[size1++] = <span class="built_in">stoll</span>(token);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; stoll(token) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            b = stack1[--size1];</span><br><span class="line">            a = stack1[--size1];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="keyword">if</span>(token == <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">                ans = (a + b) % mod1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line">                ans = (a - b) % mod1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line">                ans = (a * b) % mod1;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = (a / b) % mod1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            stack1[size1++] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; stack1[size1 - <span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><p>约瑟夫环问题描述的是一群人围成一圈，每隔固定人数（即第 k 个人）被淘汰，直到最后剩下一个人。最后存活的人的位置可以通过下面的递推式来求解：</p>
<p>假设只有 1 个人时，存活的位置为 0（注意：这里用 0 表示编号，从 0 开始）；当有 i 个人时，可以利用 i-1 个人的结果递推出 i 个人的情况。<br>递推公式为：</p>
<p>f(i) &#x3D; (f(i−1) + k ) mod  i</p>
<p>其中，f(i)表示 i 个人时最后存活者的编号。</p>
<p>i &#x3D; 1 时，f[i]显然等于0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">josephus</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">// 初始只有一个人时，位置是 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result = (result + k) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="离散化-1"><a href="#离散化-1" class="headerlink" title="离散化"></a>离散化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">    	<span class="type">int</span> n;</span><br><span class="line">    	cin &gt;&gt; n;</span><br><span class="line">    	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">ord</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    		cin &gt;&gt; v1[i];</span><br><span class="line">    		ord[i] = v1[i];</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">sort</span>(ord.<span class="built_in">begin</span>() + <span class="number">1</span>, ord.<span class="built_in">end</span>());</span><br><span class="line">    	<span class="type">int</span> m = <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(ord[m] != ord[i])&#123;</span><br><span class="line">    			ord[++ m] = ord[i];</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">auto</span> find = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    		<span class="type">int</span> l = <span class="number">1</span>, r = m;</span><br><span class="line">    		<span class="type">int</span> mid, ans;</span><br><span class="line">    		<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">    			mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    			<span class="keyword">if</span>(x &gt;= ord[mid])&#123;</span><br><span class="line">    				ans = mid;</span><br><span class="line">    				l = mid + <span class="number">1</span>;</span><br><span class="line">    			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    				r = mid - <span class="number">1</span>;</span><br><span class="line">    			&#125;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">return</span> ans;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; <span class="built_in">find</span>(v1[i]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h3><h4 id="位运算版本"><a href="#位运算版本" class="headerlink" title="位运算版本"></a>位运算版本</h4><p>每次将状态进行左移和右移一位模拟对角线移动，而且利用位运算快速得到此行能够放置的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,11&gt;&gt; sols;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> colMask, <span class="type">int</span> d1Mask, <span class="type">int</span> d2Mask, array&lt;<span class="type">int</span>,<span class="number">11</span>&gt;&amp; col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        sols.<span class="built_in">push_back</span>(col);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> avail = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; ~(colMask | d1Mask | d2Mask); </span><br><span class="line">    <span class="keyword">while</span> (avail) &#123;</span><br><span class="line">        <span class="type">int</span> p = avail &amp; -avail; </span><br><span class="line">        <span class="type">int</span> c = __builtin_ctz(p);</span><br><span class="line">        col[row] = c;</span><br><span class="line">        <span class="built_in">dfs</span>(row + <span class="number">1</span>,</span><br><span class="line">            colMask | p,</span><br><span class="line">            (d1Mask | p) &lt;&lt; <span class="number">1</span>,</span><br><span class="line">            (d2Mask | p) &gt;&gt; <span class="number">1</span>,</span><br><span class="line">            col);</span><br><span class="line">        avail ^= p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    array&lt;<span class="type">int</span>,11&gt; col&#123;&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, col);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> S = sols.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; S &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><h4 id="下凸包"><a href="#下凸包" class="headerlink" title="下凸包"></a>下凸包</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108299/H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 使用 long long 防止溢出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="comment">// 最大节点数和最大边数，根据题目限制调整</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">1e5</span>, M = <span class="number">3e5</span>;</span><br><span class="line"><span class="comment">// 邻接表存储</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">next1</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">to</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">weight</span><span class="params">(M + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// 存储从 1 出发的最短距离、到 n 的最短距离</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d1</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">d2</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// 原始边信息</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">u</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">v</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">w</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">t1</span><span class="params">(M + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// Dijkstra 标记用</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">has</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">// 直线结构 y = k*x + b</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span> &#123;</span><br><span class="line">    <span class="type">int</span> k, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用于维护下凸包的直线数组</span></span><br><span class="line"><span class="function">vector&lt;line&gt; <span class="title">l1</span><span class="params">(M + <span class="number">1</span>)</span>, <span class="title">ans1</span><span class="params">(M + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="comment">// 读入所有边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; t1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 邻接表插入函数</span></span><br><span class="line">        <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> uu, <span class="type">int</span> vv, <span class="type">int</span> ww) &#123;</span><br><span class="line">            next1[cnt1] = head[uu];</span><br><span class="line">            to[cnt1] = vv;</span><br><span class="line">            weight[cnt1] = ww;</span><br><span class="line">            head[uu] = cnt1++;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// Dijkstra 模板，in 表示起点</span></span><br><span class="line">        <span class="keyword">auto</span> dj = [&amp;](vector&lt;<span class="type">int</span>&gt; &amp;d, <span class="type">int</span> in) &#123;</span><br><span class="line">            <span class="comment">// 重置图和距离</span></span><br><span class="line">            <span class="built_in">fill</span>(head.<span class="built_in">begin</span>() + <span class="number">1</span>, head.<span class="built_in">begin</span>() + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(has.<span class="built_in">begin</span>() + <span class="number">1</span>, has.<span class="built_in">begin</span>() + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(d.<span class="built_in">begin</span>() + <span class="number">1</span>, d.<span class="built_in">begin</span>() + n + <span class="number">1</span>, (<span class="type">int</span>)<span class="number">1e18</span>);</span><br><span class="line">            cnt1 = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 重新插入边</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="built_in">add</span>(u[i], v[i], w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最小堆</span></span><br><span class="line">            priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">            d[in] = <span class="number">0</span>;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, in&#125;);</span><br><span class="line">            <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [dist, u0] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (has[u0]) <span class="keyword">continue</span>;</span><br><span class="line">                has[u0] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 松弛操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> ei = head[u0]; ei; ei = next1[ei]) &#123;</span><br><span class="line">                    <span class="type">int</span> v0 = to[ei], wt = weight[ei];</span><br><span class="line">                    <span class="keyword">if</span> (d[u0] + wt &lt; d[v0]) &#123;</span><br><span class="line">                        d[v0] = d[u0] + wt;</span><br><span class="line">                        pq.<span class="built_in">push</span>(&#123;d[v0], v0&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 计算从 1 到各点的最短路</span></span><br><span class="line">        <span class="built_in">dj</span>(d1, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 反向图：交换 u 和 v</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">swap</span>(u[i], v[i]);</span><br><span class="line">        <span class="comment">// 计算从 n 到各点的最短路（即原图各点到 n 的最短路）</span></span><br><span class="line">        <span class="built_in">dj</span>(d2, n);</span><br><span class="line">        <span class="comment">// 恢复原向边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">swap</span>(u[i], v[i]);</span><br><span class="line">        <span class="comment">// 构造每条边对应的一条直线 l: y = -t1*x + (d1[u]+d2[v]+w)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            l1[i] = line&#123;-t1[i], d1[u[i]] + d2[v[i]] + w[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按斜率 k 降序排序，若 k 相同，按截距 b 降序</span></span><br><span class="line">        <span class="built_in">sort</span>(l1.<span class="built_in">begin</span>() + <span class="number">1</span>, l1.<span class="built_in">begin</span>() + m + <span class="number">1</span>, [](<span class="keyword">auto</span> &amp;A, <span class="keyword">auto</span> &amp;B) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A.k == B.k) <span class="keyword">return</span> A.b &gt; B.b;</span><br><span class="line">            <span class="keyword">return</span> A.k &gt; B.k;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 计算两条直线相交的 x 坐标（向下取整）</span></span><br><span class="line">        <span class="keyword">auto</span> getX = [&amp;](<span class="type">const</span> line &amp;A, <span class="type">const</span> line &amp;B) &#123;</span><br><span class="line">            <span class="comment">// A.k &gt; B.k 保证分母非负</span></span><br><span class="line">            <span class="built_in">return</span> (B.b - A.b) / (A.k - B.k);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 维护下凸包</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="comment">// 去掉失效的或不必要的直线</span></span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果新线在上一条线之上，则上一条线无效</span></span><br><span class="line">                <span class="keyword">if</span> (l1[i].b &lt;= ans1[len<span class="number">-1</span>].b) len--;</span><br><span class="line">                <span class="comment">// 或者相交点不递增，也要去掉上一条</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">getX</span>(l1[i], ans1[len<span class="number">-1</span>]) &lt;= <span class="built_in">getX</span>(ans1[len<span class="number">-1</span>], ans1[len<span class="number">-2</span>])) len--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans1[len++] = l1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理查询</span></span><br><span class="line">        <span class="type">int</span> q; cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">            <span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">            <span class="comment">// 二分找在凸包上对应 x 的最佳直线</span></span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = len - <span class="number">2</span>, best = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">getX</span>(ans1[mid], ans1[mid+<span class="number">1</span>]) &lt; x) &#123;</span><br><span class="line">                    best = mid + <span class="number">1</span>;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出答案</span></span><br><span class="line">            cout &lt;&lt; ans1[best].k * x + ans1[best].b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>FFT（快速傅里叶变换）的目标是高效计算两个多项式的卷积。<br>设<br>$$<br>C(x) &#x3D; A(x)B(x),\quad A(x)&#x3D;\sum_{i&#x3D;0}^n a_i x^i,\quad B(x)&#x3D;\sum_{j&#x3D;0}^m b_j x^j<br>$$</p>
<p>那么卷积的系数是：</p>
<p>$$<br>c_k &#x3D; \sum_{i+j&#x3D;k} a_i b_j<br>$$</p>
<p>朴素算法是枚举 $i,j$，复杂度 $O(n^2)$。FFT 的作用是利用 <strong>离散傅里叶变换（DFT）</strong> 的性质，把这个卷积问题降到 $O(n\log n)$。</p>
<h4 id="离散傅里叶变换（DFT）与逆变换"><a href="#离散傅里叶变换（DFT）与逆变换" class="headerlink" title="离散傅里叶变换（DFT）与逆变换"></a>离散傅里叶变换（DFT）与逆变换</h4><p>给定序列 $a_0,a_1,\dots,a_{n-1}$，定义 DFT：</p>
<p>$$<br>A_k &#x3D; \sum_{j&#x3D;0}^{n-1} a_j \cdot \omega_n^{jk}, \quad k&#x3D;0,\dots,n-1<br>$$</p>
<p>其中</p>
<p>$$<br>\omega_n &#x3D; e^{2\pi i &#x2F; n}<br>$$</p>
<p>是 $n$ 次单位根。</p>
<p>逆变换公式为：</p>
<p>$$<br>a_j &#x3D; \frac{1}{n} \sum_{k&#x3D;0}^{n-1} A_k \cdot \omega_n^{-jk}<br>$$</p>
<p>性质：</p>
<ul>
<li>在点值表示下，多项式乘法等价于卷积。</li>
<li>即：在频域做乘法，等价于时域做卷积。</li>
</ul>
<h4 id="卷积定理"><a href="#卷积定理" class="headerlink" title="卷积定理"></a>卷积定理</h4><ol>
<li><p>把 $A(x),B(x)$ 变换到频域：<br>得到 ${A(\omega_n^k)}, {B(\omega_n^k)}$</p>
</li>
<li><p>点值相乘：</p>
<p>$$<br>C(\omega_n^k) &#x3D; A(\omega_n^k) \cdot B(\omega_n^k)<br>$$</p>
</li>
<li><p>逆变换：<br>得到 $C(x)$ 的系数。</p>
</li>
</ol>
<p>因此，卷积过程就是：<br>FFT(A) → FFT(B) → 点乘 → IFFT。<br>总复杂度 $O(n\log n)$。</p>
<h4 id="FFT-加速"><a href="#FFT-加速" class="headerlink" title="FFT 加速"></a>FFT 加速</h4><p>如果直接算 DFT，需要 $O(n^2)$。<br>FFT 利用了<strong>分治思想</strong>：<br>$$<br>A(x) &#x3D; A_{even}(x^2) + x A_{odd}(x^2)<br>$$</p>
<p>代入 $\omega_n^k$ 得到：</p>
<p>$$<br>A(\omega_n^k) &#x3D; A_{even}(\omega_{n&#x2F;2}^k) + \omega_n^k A_{odd}(\omega_{n&#x2F;2}^k)<br>$$</p>
<p>这说明一个 $n$ 点 DFT 可以分解为两个 $n&#x2F;2$ 点 DFT，再加上合并时的若干乘法。<br>递归展开，复杂度降为 $O(n\log n)$。</p>
<p>在代码层面，分治被转化为<strong>迭代形式</strong>：</p>
<ol>
<li><strong>位逆序重排</strong>：先将数组下标按二进制反转排序。</li>
<li><strong>逐层蝴蝶操作</strong>：从长度 2 的小段开始，不断倍增，每一层都用旋转因子 $\omega$ 做合并。</li>
</ol>
<p>蝴蝶操作形式为：</p>
<p>$$<br>u &#x3D; a[i],\quad v &#x3D; w \cdot a[i+mid]<br>$$</p>
<p>$$<br>a[i] &#x3D; u+v,\quad a[i+mid] &#x3D; u-v<br>$$</p>
<p>这就是代码中循环的核心。</p>
<h4 id="代码关键点对应数学"><a href="#代码关键点对应数学" class="headerlink" title="代码关键点对应数学"></a>代码关键点对应数学</h4><ul>
<li><code>for (int i = 0; i &lt; tot; i++)</code>：遍历 FFT 长度（tot 为最近的 2 次幂）。</li>
<li>位逆序数组 <code>rev[i]</code>：保证每一层分治合并时顺序正确。</li>
<li>每一层长度 <code>len</code> 翻倍，旋转因子 <code>wn = exp(±2πi/len)</code>。</li>
<li><code>if (op == 1)</code> 正变换（FFT），<code>if (op == -1)</code> 逆变换（IFFT）。</li>
<li>逆变换最后要除以 <code>tot</code>，对应公式里的 $1&#x2F;n$。</li>
<li><code>&lt;tot</code> 而不是 <code>&lt;=tot</code>：因为数组下标从 0 到 tot-1，总共 tot 个点。</li>
</ul>
<h4 id="在题目中的作用"><a href="#在题目中的作用" class="headerlink" title="在题目中的作用"></a>在题目中的作用</h4><p>在这道题里，给定两个多项式（或 01 串映射为系数数组），需要快速计算卷积。<br>FFT 的流程是：</p>
<ol>
<li>读入序列，扩充到 2 次幂长度。</li>
<li>FFT 变换。</li>
<li>点值相乘。</li>
<li>IFFT 还原，得到卷积结果。</li>
<li>再做题目所需的“进制归约”（例如 $\sqrt{-2}$ 进位）。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://ac.nowcoder.com/acm/contest/108305/J</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">3e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">// 简单复数结构，支持 +,-,*</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    Complex <span class="keyword">operator</span> +(<span class="type">const</span> Complex &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + t.x, y + t.y&#125;; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> -(<span class="type">const</span> Complex &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - t.x, y - t.y&#125;; &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span> *(<span class="type">const</span> Complex &amp;t) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x * t.x - y * t.y, x * t.y + y * t.x&#125;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工作数组</span></span><br><span class="line"><span class="function">vector&lt;Complex&gt; <span class="title">a</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rev</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">res</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> bit, tot; <span class="comment">// FFT 长度信息</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="comment">// FFT：inv=1 正变换, inv=-1 逆变换</span></span><br><span class="line">    <span class="keyword">auto</span> FFT = [&amp;](vector&lt;Complex&gt; &amp; v, <span class="type">int</span> inv) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i ++) <span class="keyword">if</span>(i &lt; rev[i]) <span class="built_in">swap</span>(v[i], v[rev[i]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mid = <span class="number">1</span>; mid &lt; tot; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Complex w1 = &#123;<span class="built_in">cos</span>(PI / mid), inv * <span class="built_in">sin</span>(PI / mid)&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                Complex wk = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; mid; j ++, wk = wk * w1) &#123;</span><br><span class="line">                    Complex x = v[i + j], y = wk * v[i + j + mid];</span><br><span class="line">                    v[i + j] = x + y;</span><br><span class="line">                    v[i + j + mid] = x - y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(t --) &#123; </span><br><span class="line">        string s1, s2;</span><br><span class="line">        cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="type">int</span> n1 = s1.<span class="built_in">size</span>(), n2 = s2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 低位在前存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i ++) a[i] = &#123;<span class="built_in">double</span>(s1[n1 - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>), <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i ++) b[i] = &#123;<span class="built_in">double</span>(s2[n2 - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>), <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 取最近 2 次幂长度</span></span><br><span class="line">        bit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((<span class="number">1</span> &lt;&lt; bit) &lt; n1 + n2 - <span class="number">1</span>) bit ++;</span><br><span class="line">        tot = <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">        <span class="comment">// 补 0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n1; i &lt; tot; i ++) a[i] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n2; i &lt; tot; i ++) b[i] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// 位逆序表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i ++)</span><br><span class="line">            rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (bit - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// FFT → 逐点相乘 → IFFT</span></span><br><span class="line">        <span class="built_in">FFT</span>(a, <span class="number">1</span>), <span class="built_in">FFT</span>(b, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tot; i ++) a[i] = a[i] * b[i];</span><br><span class="line">        <span class="built_in">FFT</span>(a, <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 卷积结果（未进位）</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1 + n2 - <span class="number">1</span>; ++i)</span><br><span class="line">            res[i] = (<span class="type">int</span>)(a[i].x / tot + <span class="number">0.5</span>);</span><br><span class="line">        <span class="comment">// √-2 进制进位归约</span></span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; n1 + n2 - <span class="number">1</span> || res[len + <span class="number">1</span>] || res[len]; len ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[len] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[len] = -res[len];</span><br><span class="line">                res[len + <span class="number">2</span>] += res[len];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[len] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[len + <span class="number">2</span>] -= res[len] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                res[len] %= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉前导 0</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">1</span> &amp;&amp; !res[len - <span class="number">1</span>]) len --;</span><br><span class="line">        <span class="comment">// 输出（高位在前）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) cout &lt;&lt; <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + res[i]);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 清理</span></span><br><span class="line">        <span class="built_in">fill</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">begin</span>() + len + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><p>对于依次压栈随意出栈，规范括号（（）（））…，斜方矩阵从左上角到右下角方案数，其答案数均为卡特兰数：<br>$$<br>f(n) &#x3D; \frac{(2n)!}{n!(n +1)!}<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.nowcoder.com/practice/44a2fc12a92a4eccb13a78eabfb67063?channelPut=w251acm</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">2e5</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fac</span><span class="params">(N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>)</span>, <span class="title">inv</span><span class="params">(N + <span class="number">1</span>)</span>, <span class="title">ans1</span><span class="params">(N + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="type">int</span> in1 = <span class="number">1</span>;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (N &lt;&lt; <span class="number">1</span>); i ++) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	<span class="keyword">auto</span> power = [&amp;](<span class="type">int</span> x, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">			x = x * x % mod;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;;</span><br><span class="line">	inv[N] = <span class="built_in">power</span>(fac[N], mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --) inv[i] = inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">		ans1[i] = fac[i &lt;&lt; <span class="number">1</span>] * inv[i] % mod * inv[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(t --) &#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; in1 &lt;&lt; <span class="string">&quot;: 0\n&quot;</span>;</span><br><span class="line">			in1 ++;</span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; in1 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ((ans1[n] - ans1[n - <span class="number">1</span>]) % mod + mod) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		in1 ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tarjan（强连通-割点-双连通分量）"><a href="#Tarjan（强连通-割点-双连通分量）" class="headerlink" title="Tarjan（强连通&#x2F;割点&#x2F;双连通分量）"></a>Tarjan（强连通&#x2F;割点&#x2F;双连通分量）</h3><p> <strong>适用场景</strong></p>
<ul>
<li>求解有向图强连通分量 (SCC)、无向图割点&#x2F;桥、双连通分量 (BCC)。</li>
<li>图规模：n ≤ 5e5, m ≤ 2e6（需优化如链式前向星）。</li>
<li>常见问题：拓扑排序前处理、缩点DAG、连通性检查、关键点&#x2F;边检测。</li>
<li>时间复杂度：O(n + m)，单次DFS遍历。</li>
<li>注意：有向图用SCC，无向图用割点&#x2F;BCC；带权需额外处理。</li>
</ul>
<p><strong>核心思路</strong></p>
<ul>
<li><strong>DFS时序</strong>：dfn[u] &#x3D; 访问时间，low[u] &#x3D; u子树最小dfn（回溯时更新）。</li>
<li><strong>栈机制</strong>（SCC&#x2F;BCC）：入栈记录路径，出栈pop分量。</li>
<li><strong>分量判断</strong>：<ul>
<li>SCC：dfn[u] &#x3D;&#x3D; low[u] 时pop栈至u为一SCC。</li>
<li>割点：子树low[v] &gt;&#x3D; dfn[u]（非根）或根子树&gt;&#x3D;2。</li>
<li>BCC：low[v] &gt;&#x3D; dfn[u] 时pop栈至v为一BCC。</li>
</ul>
</li>
<li><strong>缩点</strong>：原点bel[u] &#x3D; 分量ID；建DAG处理后续（如拓扑&#x2F;最长路）。</li>
<li><strong>优化</strong>：链式前向星存边；多组件从1..n DFS。</li>
</ul>
<p><strong>基础模板：强连通分量 (SCC) + 缩点DAG</strong></p>
<p>适用于P2341&#x2F;P3387-like（计数&#x2F;最长路）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(N)</span></span>;  <span class="comment">// 点权（可选）</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>;  <span class="comment">// 边索引</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(N)</span>, <span class="title">nxt</span><span class="params">(M)</span>, <span class="title">to</span><span class="params">(M)</span></span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>, Stop = <span class="number">0</span>, bcnt = <span class="number">0</span>;  <span class="comment">// tot: dfn时钟, Stop: 栈顶, bcnt: SCC数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfn</span><span class="params">(N)</span>, <span class="title">low</span><span class="params">(N)</span>, <span class="title">Sta</span><span class="params">(N)</span>, <span class="title">bel</span><span class="params">(N)</span>, <span class="title">bsum</span><span class="params">(N)</span></span>;  <span class="comment">// bel: 所属SCC, bsum: SCC大小/权和</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inSta</span><span class="params">(N)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">badj</span>(N);  <span class="comment">// SCC间DAG</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(N, <span class="number">-1</span>)</span></span>;  <span class="comment">// DAG DP（如最长路）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;  <span class="comment">// 链式前向星</span></span><br><span class="line">    nxt[cnt] = head[u]; to[cnt] = v; head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    inSta[u] = <span class="literal">true</span>;</span><br><span class="line">    Sta[Stop++] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = nxt[ei]) &#123;</span><br><span class="line">        v = to[ei];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inSta[v]) &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;  <span class="comment">// u为SCC根</span></span><br><span class="line">        bcnt++;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            q = Sta[--Stop];</span><br><span class="line">            inSta[q] = <span class="literal">false</span>;</span><br><span class="line">            bel[q] = bcnt;</span><br><span class="line">            bsum[bcnt] += val[q];  <span class="comment">// 或 ++bsum[bcnt]（计数）</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (q != u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_dp</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;  <span class="comment">// DAG最长路（P3387变种）</span></span><br><span class="line">    <span class="keyword">if</span> (dp[u] != <span class="number">-1</span>) <span class="keyword">return</span> dp[u];</span><br><span class="line">    dp[u] = bsum[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : badj[u]) &#123;</span><br><span class="line">        dp[u] = <span class="built_in">max</span>(dp[u], bsum[u] + <span class="built_in">dfs_dp</span>(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; val[i];  <span class="comment">// 点权（可选）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        <span class="built_in">add</span>(u, v);  <span class="comment">// 有向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);  <span class="comment">// 多组件</span></span><br><span class="line">    <span class="comment">// 建DAG（去重边可选，用set）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">        <span class="type">int</span> bu = bel[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = nxt[ei]) &#123;</span><br><span class="line">            v = to[ei]; <span class="type">int</span> bv = bel[v];</span><br><span class="line">            <span class="keyword">if</span> (bu != bv) badj[bu].<span class="built_in">push_back</span>(bv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 示例输出：SCC大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++) cout &lt;&lt; bsum[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 示例：最长路（P3387）</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++) ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs_dp</span>(i));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 示例：入度0 SCC的sum，若多则0（P2341汇聚所有点的连通分量的点）</span></span><br><span class="line">    <span class="comment">// vector&lt;int&gt; du(bcnt + 1);</span></span><br><span class="line">    <span class="comment">// for (int u = 1; u &lt;= bcnt; u++) for (int v : badj[u]) du[v]++;</span></span><br><span class="line">    <span class="comment">// int res = 0, cnt0 = 0;</span></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= bcnt; i++) if (!du[i]) &#123; res = bsum[i]; cnt0++; if (cnt0 &gt; 1) res = 0; &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>变种</strong>：起点固定Tarjan(1)；无权用bsum[bcnt]++。</li>
<li><strong>复杂度</strong>：O(n + m)。</li>
</ul>
<p><strong>变种模板1：割点 (Articulation Points)</strong></p>
<p>适用于P3388（无向图关键点）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 基础头（无向：add(u,v); add(v,u);）</span></span><br><span class="line"><span class="type">int</span> root; <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">iscut</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tot = <span class="number">0</span>;  <span class="comment">// 全局</span></span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>;  <span class="comment">// 子树数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = nxt[ei]) &#123;</span><br><span class="line">        v = to[ei];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v, u);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u] &amp;&amp; fa != u) iscut[u] = <span class="number">1</span>;  <span class="comment">// 非根：子树无法回溯</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == root &amp;&amp; child &gt;= <span class="number">2</span>) iscut[u] = <span class="number">1</span>;  <span class="comment">// 根：&gt;=2子树</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 输入双向边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">        root = i; <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (iscut[i]) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="keyword">for</span> (<span class="type">int</span> x : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>桥变种</strong>：记录low[v] &gt;&#x3D; dfn[u]的边(u,v)为桥。</li>
</ul>
<p> <strong>变种模板2：双连通分量 (BCC)</strong></p>
<p>是极大联通子图且无割点</p>
<p>适用于P8435（无向图块+大小）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 基础头（无向双边）</span></span><br><span class="line"><span class="type">int</span> bcnt = <span class="number">0</span>; vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">badj</span>(N);  <span class="comment">// badj[i]: 第i块的点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    dfn[u] = low[u] = ++tot;</span><br><span class="line">    Sta[Stop++] = u;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ei = head[u], v; ei; ei = nxt[ei]) &#123;</span><br><span class="line">        v = to[ei];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">Tarjan</span>(v, u);</span><br><span class="line">            low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u]) &#123;  <span class="comment">// BCC结束</span></span><br><span class="line">                bcnt++;</span><br><span class="line">                <span class="type">int</span> q;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    q = Sta[--Stop];</span><br><span class="line">                    badj[bcnt].<span class="built_in">push_back</span>(q);</span><br><span class="line">                &#125; <span class="keyword">while</span> (q != v);</span><br><span class="line">                <span class="keyword">if</span> (badj[bcnt].<span class="built_in">size</span>() == <span class="number">1</span> || dfn[u] == low[v]) badj[bcnt].<span class="built_in">push_back</span>(u);  <span class="comment">// 孤点或加u</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fa == <span class="number">0</span> &amp;&amp; Stop) &#123;  <span class="comment">// 根孤点</span></span><br><span class="line">        bcnt++; badj[bcnt] = &#123;u&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    cout &lt;&lt; bcnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++) &#123;</span><br><span class="line">        cout &lt;&lt; badj[i].<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : badj[i]) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>变种</strong>：边双连通用边栈；输出块ID而非点。</li>
</ul>
<p><strong>变种模板3：SCC + 内部检查 + 传播 (复杂变种)</strong></p>
<p>适用于Tarjan.cpp（SCC内一致性检查 + 影响传播）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://codeforces.com/gym/105578/problem/M</span></span><br><span class="line"><span class="comment">// ... SCC基础 + 额外</span></span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">g</span>(N);  <span class="comment">// &#123;v, w&#125; 带权边</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dep</span><span class="params">(N)</span></span>; <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(N)</span>, <span class="title">bad</span><span class="params">(N)</span></span>;  <span class="comment">// bad: 坏SCC</span></span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_scc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> bid)</span> </span>&#123;  <span class="comment">// DFS检查SCC内边一致（距离）</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bel[v] != bid) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[v] != dep[u] + w) ok = <span class="literal">false</span>;  <span class="comment">// 不一致</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dep[v] = dep[u] + w;</span><br><span class="line">            <span class="built_in">check_scc</span>(v, bid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... SCC后</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 假设0..n-1</span></span><br><span class="line">        <span class="keyword">if</span> (vis[bel[i]]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[bel[i]] = <span class="literal">true</span>; ok = <span class="literal">true</span>;</span><br><span class="line">        dep[i] = <span class="number">0</span>; <span class="built_in">check_scc</span>(i, bel[i]);</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123; q.<span class="built_in">push</span>(bel[i]); bad[bel[i]] = <span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建反向DAG v2[bel[v]].push_back(bel[u]) 若影响边u-&gt;v</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> b = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pre : v2[b]) &#123;  <span class="comment">// 反向传播</span></span><br><span class="line">            <span class="keyword">if</span> (!bad[pre]) &#123; q.<span class="built_in">push</span>(pre); bad[pre] = <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询：bad[bel[x]] ? &quot;Yes&quot; : &quot;No&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>技巧</strong>：带权需mod或检查一致；传播用BFS。</li>
</ul>
<p> <strong>常见技巧</strong></p>
<ul>
<li><strong>初始化</strong>：memset(dfn, 0, sizeof(dfn)); 或vector全0。</li>
<li><strong>多测</strong>：清空head&#x2F;nxt&#x2F;dfn&#x2F;low等；t循环内重置。</li>
<li><strong>无向图</strong>：双加边；fa防回父。</li>
<li><strong>栈溢出</strong>：n大用iter栈或调栈大小。</li>
<li><strong>去重DAG</strong>：用set插入badj[u]。</li>
<li><strong>调试</strong>：打印dfn&#x2F;low&#x2F;bel；从小图测。</li>
<li><strong>扩展</strong>：Kosaraju备选（两次DFS）；桥用low[v] &gt; dfn[u]。</li>
</ul>
<p><strong>竞赛Tips</strong>：先判有向&#x2F;无向；SCC后必缩点；O(n+m)稳，优先Tarjan。复制模板改Tarjan&#x2F;if条件&#x2F;后续DP。</p>
<h3 id="高斯消元（Gauss）"><a href="#高斯消元（Gauss）" class="headerlink" title="高斯消元（Gauss）"></a>高斯消元（Gauss）</h3><h4 id="加法方程组"><a href="#加法方程组" class="headerlink" title="加法方程组"></a>加法方程组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P2455</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function">vector <span class="title">v1</span><span class="params">(N, vector&lt;<span class="type">double</span>&gt;(N))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> Gauss_add = [&amp;]() -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> max1 = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; i &amp;&amp; <span class="built_in">abs</span>(v1[j][j]) &gt;= <span class="number">1e-7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(v1[j][i]) &gt; <span class="built_in">abs</span>(v1[max1][i])) max1 = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(v1[i], v1[max1]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(v1[i][i]) &gt;= <span class="number">1e-7</span>) &#123;</span><br><span class="line">            <span class="type">double</span> temp = v1[i][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j ++) v1[i][j] /= temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">double</span> rate = v1[j][i] / v1[i][i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; k ++) v1[j][k] -= rate * v1[i][k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="异或方程组"><a href="#异或方程组" class="headerlink" title="异或方程组"></a>异或方程组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long lon</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">3</span>;</span><br><span class="line"><span class="function">vector <span class="title">v1</span><span class="params">(N, vector&lt;<span class="type">int</span>&gt;(N))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> Gauss_xor = [&amp;]() -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; i &amp;&amp; v1[j][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1[j][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(i, j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v1[i][i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j || v1[j][i] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; k++) v1[j][k] ^= v1[i][k];	</span><br><span class="line">        &#125;		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="同余方程组"><a href="#同余方程组" class="headerlink" title="同余方程组"></a>同余方程组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">// 题目会保证取模的数字为质数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> v1[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> invTbl[MOD];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildInv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invTbl[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; MOD; i++) &#123;</span><br><span class="line">        invTbl[i] = (MOD - invTbl[MOD % i] * (MOD / i) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高斯消元解决同余方程组模版，保证初始系数没有负数</span></span><br><span class="line"><span class="comment">// ((系数 % MOD) + MOD) % MOD</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; i &amp;&amp; v1[j][j] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (v1[j][i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(v1[i], v1[j]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v1[i][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(i == j || !v1[j][i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> g = <span class="built_in">gcd</span>(v1[j][i], v1[i][i]);</span><br><span class="line">                <span class="type">int</span> a = v1[i][i] / g;</span><br><span class="line">                <span class="type">int</span> b = v1[j][i] / g;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; i &amp;&amp; v1[j][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果j行有主元，那么从j列到i-1列的所有系数 * a</span></span><br><span class="line">                    <span class="comment">// 正确更新主元和自由元之间的关系</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; i; k++) v1[j][k] = v1[j][k] * a % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 正常消元</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> val = (v1[j][k] * a - v1[i][k] * b) % MOD;</span><br><span class="line">                    v1[j][k] = (val + MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i][i] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查当前主元是否被若干自由元影响</span></span><br><span class="line">            <span class="comment">// 如果当前主元不受自由元影响，那么可以确定当前主元的值</span></span><br><span class="line">            <span class="comment">// 否则保留这种影响，正确显示主元和自由元的关系</span></span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// 本来应该是，v1[i][n + 1] = v1[i][n + 1] / v1[i][i]</span></span><br><span class="line">                <span class="comment">// 但是在模意义下应该求逆元，(a / b) % MOD = (a * b的逆元) % MOD</span></span><br><span class="line">                v1[i][n + <span class="number">1</span>] = (v1[i][n + <span class="number">1</span>] * invTbl[v1[i][i]] % MOD);</span><br><span class="line">                v1[i][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><p>线性基（Linear Basis，又称异或基、XOR Basis）是一个<strong>用于处理集合中数的异或性质</strong>的高效数学结构。它的核心思想是用一组“线性无关”的数，表示原集合中所有可能的异或结果。</p>
<p>核心思想：</p>
<p>在二进制意义下，异或运算相当于<strong>模 2 加法</strong>。<br> 因此，一个数集 <code>&#123;a₁, a₂, …, aₙ&#125;</code> 可以看作是由若干个二进制向量组成的向量空间。<br> 线性基就是<strong>该空间的一组最小生成向量（basis）</strong>，即满足：</p>
<ul>
<li>任意集合中的数都能由这些基向量异或得到；</li>
<li>基向量之间两两线性无关（无法由其他异或得到）。</li>
</ul>
<p>基本性质：</p>
<p>设线性基为 <code>&#123;b₁, b₂, …, bₖ&#125;</code>，则：</p>
<ol>
<li><strong>可表示性</strong>：<br>  原集合中任意数都可由基向量异或得到。<br>  比如：<code>x = b₂ ^ b₅ ^ b₇</code>。</li>
<li><strong>唯一性</strong>：<br>  每个数对应的基向量组合是唯一的。</li>
<li><strong>基的秩（rank）</strong>：<br>  <code>k</code> 是线性基的大小，说明集合能生成 <code>2^k</code> 个不同的异或结果。</li>
<li><strong>最大异或值</strong>：<br>  从高位到低位依次尝试用基向量“抬高”结果即可贪心得到最大值。</li>
</ol>
<p>场景：</p>
<p><strong>最大异或子集和</strong>（Luogu P3812、洛谷模板题）<br> 在集合中选若干个数，使异或和最大。</p>
<p><strong>判断异或可达性</strong><br> 给定多个数与目标值 <code>x</code>，判断是否能异或出 <code>x</code>。</p>
<p><strong>第 k 小异或值</strong><br> 求集合中所有可能异或结果的第 <code>k</code> 小值。</p>
<p><strong>合并多个集合的异或性质</strong><br> 在图论、树上问题中用于处理路径异或值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P3812</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">50</span> + <span class="number">3</span>, BIT = <span class="number">50</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(N)</span>, <span class="title">basis</span><span class="params">(N)</span></span>; <span class="comment">// v1: 输入数组, basis: 线性基</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; v1[i];</span><br><span class="line">		<span class="comment">// 插入函数：尝试将 x 插入线性基</span></span><br><span class="line">		<span class="keyword">auto</span> insert = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = BIT; i &gt;= <span class="number">0</span>; i--) &#123;     <span class="comment">// 从高位到低位枚举</span></span><br><span class="line">				<span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;              <span class="comment">// 若第 i 位为 1</span></span><br><span class="line">					<span class="keyword">if</span> (!basis[i]) &#123;             <span class="comment">// 若该位尚无基底</span></span><br><span class="line">						basis[i] = x;            <span class="comment">// 记录为新的基底</span></span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					x ^= basis[i];               <span class="comment">// 否则消去该位</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若最后为 0，说明线性相关</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// Gauss version</span></span><br><span class="line">		<span class="keyword">auto</span> compute2 = [&amp;]() -&gt; <span class="type">void</span> &#123;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; <span class="built_in">basis2</span>(N);</span><br><span class="line">			<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">			<span class="type">bool</span> zero2;</span><br><span class="line">			len = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = BIT; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = len; j &lt;= n; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((basis2[j] &amp; (<span class="number">1LL</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">swap</span>(j, len);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ((basis2[len] &amp; (<span class="number">1LL</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (j != len &amp;&amp; (basis2[j] &amp; (<span class="number">1LL</span> &lt;&lt; i)) != <span class="number">0</span>)</span><br><span class="line">							basis2[j] ^= basis2[len];</span><br><span class="line">					&#125;</span><br><span class="line">					len++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			len--;</span><br><span class="line">			zero2 = len != n;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">// 构建线性基</span></span><br><span class="line">		<span class="type">bool</span> zero1 = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">insert</span>(v1[i])) zero1 = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 求最大异或和</span></span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = BIT; i &gt;= <span class="number">0</span>; i--) ans = <span class="built_in">max</span>(ans, ans ^ basis[i]);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h3><p>差分约束系统是一组关于变量的线性不等式，<strong>每个不等式都形如：</strong>$ x_i - x_j \leq c_k$,其中：</p>
<ul>
<li>( $x_1, x_2, \dots, x_n$ ) 是未知变量；</li>
<li>( $c_k$ ) 是常数；</li>
<li>每条约束 ( $x_i - x_j \leq c_k$ ) 限制了两个变量之间的“相对大小”。</li>
</ul>
<p>系统目标：判断这些不等式是否<strong>有解</strong>，若有则求出<strong>一组可行解</strong>。</p>
<p>图论建模:</p>
<p>将每个变量 ( $x_i$ ) 看作图的一个顶点。每条约束 ( $x_i - x_j \leq c_k$ ) 转换为一条<strong>有向边</strong>：$ j \rightarrow i,\quad 权值 &#x3D; c_k$</p>
<p>解释：</p>
<ul>
<li>若存在路径 ($ j \to i$ ) 权值和为 ( w )， 则意味着 ( $x_i - x_j \leq w$ ).</li>
<li>所以要让所有不等式成立，必须存在一组 ( x )，使得对每条边 ( (u,v,w) )： $x_v \leq x_u + w$</li>
</ul>
<p>这其实是<strong>单源最短路约束</strong>的形式。</p>
<p>差分约束的解可通过最短路模型求出：</p>
<ol>
<li>新增一个<strong>超级源点 0</strong>；</li>
<li>从 0 向每个点 ( i ) 连一条边 ( (0,i,0) )，确保图连通；</li>
<li>使用 <strong>Bellman-Ford</strong> 或 <strong>SPFA</strong> 算法求最短路；</li>
<li>若图中存在<strong>负权环</strong>，则系统<strong>无解</strong>；</li>
<li>若无负环，<code>dist[i]</code> 即为一组满足所有不等式的可行解。</li>
</ol>
<blockquote>
<p>直观理解：负环意味着存在一系列不等式相互矛盾，导致 “越走越小”，即无解。</p>
</blockquote>
<p>可行解的含义:</p>
<p>得到的 <code>dist[i]</code> 并不是唯一解，它只是某个满足条件的相对值方案。<br> 事实上，若系统有解，则所有解集合构成一个凸多面体：$ { x \mid x_i - x_j \leq c_k }$</p>
<p>判无解条件（负环）:</p>
<p>假设存在一个环 ( $x_1 - x_2 \leq c_1, x_2 - x_3 \leq c_2, \dots, x_k - x_1 \leq c_k )$</p>
<p>把它们加起来得：$ 0 \leq c_1 + c_2 + \dots + c_k$</p>
<p>如果存在一个环使得 ( $c_1 + c_2 + \dots + c_k &lt; 0$ )，说明该系统无解 —— 因为沿环不断松弛会让值无限减小。</p>
<p>算法复杂度:</p>
<ul>
<li><strong>Bellman-Ford</strong>：( O(nm) )</li>
<li><strong>SPFA（队列优化）</strong>：均摊快很多，竞赛常用。</li>
<li>( $n, m \le 5 \times 10^3$ ) 时可轻松通过。</li>
</ul>
<p>两种常见写法对比:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>判断条件</th>
<th>松弛方式</th>
<th>表示含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>最短路型</strong></td>
<td><code>dist[v] &gt; dist[u] + w</code></td>
<td>取更小值</td>
<td>判<strong>负环</strong></td>
</tr>
<tr>
<td><strong>最长路型</strong></td>
<td><code>dist[v] &lt; dist[u] + w</code></td>
<td>取更大值</td>
<td>判<strong>正环</strong>（无限增大）</td>
</tr>
</tbody></table>
<p>两者等价，只是方向相反。<br> 竞赛中推荐<strong>统一使用最短路型（负环）版</strong>，更常见、稳定。</p>
<h4 id="形式1：直接建边-X-i-X-j-≤-C-⇒-j-→-i-权C-（最短路-判负环）"><a href="#形式1：直接建边-X-i-X-j-≤-C-⇒-j-→-i-权C-（最短路-判负环）" class="headerlink" title="形式1：直接建边 X_i - X_j ≤ C  ⇒  j → i (权C)（最短路&#x2F;判负环）"></a>形式1：直接建边 <code>X_i - X_j ≤ C  ⇒  j → i (权C)</code>（最短路&#x2F;判负环）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P5960 / 差分约束 形式1：Xi - Xj &lt;= C  =&gt; edge j-&gt;i (C)</span></span><br><span class="line"><span class="comment">// 有解则输出一组满足解；无解输出 NO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> INF = (<span class="number">1LL</span>&lt;&lt;<span class="number">60</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m; </span><br><span class="line">    <span class="keyword">if</span> (!(cin &gt;&gt; n &gt;&gt; m)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总边数 = 约束m + 超级源0到每个点n</span></span><br><span class="line">    <span class="type">int</span> E = m + n + <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span>, <span class="title">nxt</span><span class="params">(E)</span>, <span class="title">to</span><span class="params">(E)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cntIn</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;          <span class="comment">// 入队松弛计数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">w</span><span class="params">(E)</span>, <span class="title">dist</span><span class="params">(n+<span class="number">1</span>, INF)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">inq</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> ec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">long</span> <span class="type">long</span> ww)&#123;</span><br><span class="line">        to[ec] = v; w[ec] = ww; nxt[ec] = head[u]; head[u] = ec++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 超级源0 -&gt; i (0)，保证可达</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读入 Xi - Xj &lt;= C   =&gt;   j -&gt; i (C)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c; </span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(y, x, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SPFA 判负环（最短路）</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>; inq[<span class="number">0</span>] = <span class="number">1</span>; q.<span class="built_in">push</span>(<span class="number">0</span>); cntIn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> hasNegCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; !hasNegCycle) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = head[u]; e != <span class="number">-1</span>; e = nxt[e]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[e];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> nv = dist[u] + w[e];</span><br><span class="line">            <span class="keyword">if</span> (dist[u] != INF &amp;&amp; dist[v] &gt; nv) &#123;</span><br><span class="line">                dist[v] = nv;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    <span class="keyword">if</span> (++cntIn[v] &gt; n) &#123; <span class="comment">// 注意是&gt;n（含超级源0）</span></span><br><span class="line">                        hasNegCycle = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasNegCycle) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; (dist[i]==INF? <span class="number">0</span> : dist[i]) &lt;&lt; (i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：<code>dist[i]==INF</code> 的点在本题模型下不会出现（因有超级源连到所有点），但稳妥起见做了保护，置 0 输出。</p>
</blockquote>
<h4 id="形式2：改写为-X-j-X-i-≥-C（最长路-判“无限增大环”）"><a href="#形式2：改写为-X-j-X-i-≥-C（最长路-判“无限增大环”）" class="headerlink" title="形式2：改写为 X_j - X_i ≥ -C（最长路&#x2F;判“无限增大环”）"></a>形式2：改写为 <code>X_j - X_i ≥ -C</code>（最长路&#x2F;判“无限增大环”）</h4><p>将约束 <code>X_i - X_j ≤ C</code> 改写为 <code>X_j ≥ X_i - C</code>，再写成<strong>最长路</strong>风格 <code>dist[v] &lt; dist[u] + w</code> 的松弛式，可取 <code>u=i, v=j, w=-C</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P5960 / 差分约束 形式2：Xi - Xj &lt;= C  =&gt;  edge i-&gt;j (-C)</span></span><br><span class="line"><span class="comment">// 有解则输出一组满足解；无解输出 NO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> NINF = -(<span class="number">1LL</span>&lt;&lt;<span class="number">60</span>);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n, m; </span><br><span class="line">    <span class="keyword">if</span> (!(cin &gt;&gt; n &gt;&gt; m)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> E = m + n + <span class="number">5</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">head</span><span class="params">(n+<span class="number">1</span>, <span class="number">-1</span>)</span>, <span class="title">nxt</span><span class="params">(E)</span>, <span class="title">to</span><span class="params">(E)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cntIn</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">w</span><span class="params">(E)</span>, <span class="title">dist</span><span class="params">(n+<span class="number">1</span>, NINF)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">inq</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> ec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> add = [&amp;](<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">long</span> <span class="type">long</span> ww)&#123;</span><br><span class="line">        to[ec] = v; w[ec] = ww; nxt[ec] = head[u]; head[u] = ec++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 超级源0 -&gt; i (0)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读入 Xi - Xj &lt;= C   =&gt;   i -&gt; j (-C)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c; </span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(x, y, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SPFA 判“可无限增大”的正环（对应原模型无解）</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>; inq[<span class="number">0</span>] = <span class="number">1</span>; q.<span class="built_in">push</span>(<span class="number">0</span>); cntIn[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> hasPosCycle = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; !hasPosCycle) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = head[u]; e != <span class="number">-1</span>; e = nxt[e]) &#123;</span><br><span class="line">            <span class="type">int</span> v = to[e];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> nv = dist[u] + w[e];</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &lt; nv) &#123;</span><br><span class="line">                dist[v] = nv;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v]) &#123;</span><br><span class="line">                    inq[v] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    <span class="keyword">if</span> (++cntIn[v] &gt; n) &#123; <span class="comment">// 注意是&gt;n（含超级源0）</span></span><br><span class="line">                        hasPosCycle = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasPosCycle) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            cout &lt;&lt; (dist[i]==NINF? <span class="number">0</span> : dist[i]) &lt;&lt; (i==n?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>如何随意获取某一个排列的字典序名次和给定字典序名次构造排列。</p>
<p>本质为从前往后遍历，如果某一位不是当前剩余数字的最小值，则其贡献为:$d * n^{‘}!$，其中，d为当前数字与最小值的名次差，$n_{‘}$为n与当前位置的差值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">20</span> + <span class="number">2</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">base</span><span class="params">(N)</span>, <span class="title">bit</span><span class="params">(N)</span>, <span class="title">tar</span><span class="params">(N)</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// cin &gt;&gt; t;</span></span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="type">int</span> n, q;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">		bit[n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, b = <span class="number">1</span>; i; i --) &#123;</span><br><span class="line">			bit[i] = b;</span><br><span class="line">			b *= n - i + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> op;</span><br><span class="line">		<span class="type">int</span> x, r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i ++) &#123;</span><br><span class="line">			cin &gt;&gt; op;</span><br><span class="line">			r = n;</span><br><span class="line">			<span class="built_in">iota</span>(base.<span class="built_in">begin</span>() + <span class="number">1</span>, base.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 维护剩余数字关系</span></span><br><span class="line">			<span class="keyword">auto</span> rem = [&amp;](<span class="type">int</span> l) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt; r; i ++) <span class="built_in">swap</span>(base[i], base[i + <span class="number">1</span>]);</span><br><span class="line">				r --;</span><br><span class="line">			&#125;;</span><br><span class="line">            <span class="comment">// 构造排列</span></span><br><span class="line">			<span class="keyword">if</span>(op == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				<span class="keyword">auto</span> make = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">						<span class="type">int</span> need = x / bit[i];</span><br><span class="line">						tar[i] = base[need + <span class="number">1</span>];</span><br><span class="line">						<span class="built_in">rem</span>(need + <span class="number">1</span>);</span><br><span class="line">						x -= need * bit[i];</span><br><span class="line">					&#125;</span><br><span class="line">					tar[n] = base[<span class="number">1</span>];</span><br><span class="line">				&#125;;</span><br><span class="line">				<span class="built_in">make</span>(x - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cout &lt;&lt; tar[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算排列名次    </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; tar[i];</span><br><span class="line">				<span class="keyword">auto</span> get = [&amp;]() -&gt; <span class="type">int</span> &#123;</span><br><span class="line">					<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= r; j ++) &#123;</span><br><span class="line">							<span class="keyword">if</span>(base[j] == tar[i]) &#123;</span><br><span class="line">								ans += (j - <span class="number">1</span>) * bit[i];</span><br><span class="line">								<span class="built_in">rem</span>(j);</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> ans;</span><br><span class="line">				&#125;;</span><br><span class="line">				cout &lt;&lt; <span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>基于红黑树实现的自动排序、无重复元素的关联容器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;                  <span class="comment">// 升序，默认 less&lt;int&gt;</span></span><br><span class="line">set&lt;string&gt; names;</span><br><span class="line">set&lt;<span class="type">int</span>, greater&lt;<span class="type">int</span>&gt;&gt; s2;   <span class="comment">// 降序排列</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">5</span>);    <span class="comment">// 插入 5，若已存在则无效</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">5</span>);       <span class="comment">// 删除值为5的元素</span></span><br><span class="line">s.<span class="built_in">erase</span>(it);      <span class="comment">// 通过迭代器删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 清空</span></span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">5</span>);     <span class="comment">// 找到返回迭代器，否则为 s.end()</span></span><br><span class="line"><span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; found\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">5</span>)) cout &lt;&lt; <span class="string">&quot;存在&quot;</span>;</span><br><span class="line">s.<span class="built_in">size</span>();</span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x : s)</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> it1 = s.<span class="built_in">lower_bound</span>(<span class="number">5</span>); <span class="comment">// 返回 ≥ 5 的第一个元素迭代器</span></span><br><span class="line"><span class="keyword">auto</span> it2 = s.<span class="built_in">upper_bound</span>(<span class="number">5</span>); <span class="comment">// 返回 &gt; 5 的第一个元素迭代器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;  <span class="comment">// 可定义复合排序规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, cmp&gt; s;</span><br></pre></td></tr></table></figure>

<p>插入&#x2F;删除&#x2F;查找都是O(log n)</p>
<h3 id="ordered-set"><a href="#ordered-set" class="headerlink" title="ordered_set"></a>ordered_set</h3><p>解释各个部分的作用</p>
<table>
<thead>
<tr>
<th>代码部分</th>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.insert(5)</code></td>
<td>插入元素</td>
<td><code>ordered_set</code> 自动去重</td>
</tr>
<tr>
<td><code>s.erase(7)</code></td>
<td>删除元素</td>
<td>需先检查元素是否存在</td>
</tr>
<tr>
<td><code>find_by_order(k)</code></td>
<td>获取第 k 小元素</td>
<td><code>0-based</code>，需先检查是否为空</td>
</tr>
<tr>
<td><code>order_of_key(10)</code></td>
<td>获取小于某个值的元素数量</td>
<td><code>O(log n)</code> 复杂度</td>
</tr>
<tr>
<td><code>find(5)</code></td>
<td>查找元素</td>
<td>直接返回迭代器</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>获取集合大小</td>
<td><code>O(1)</code> 复杂度</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>清空集合</td>
<td>直接清空</td>
</tr>
</tbody></table>
<p>时间复杂度</p>
<ul>
<li>插入：<code>O(log n)</code></li>
<li>删除：<code>O(log n)</code></li>
<li>查找：<code>O(log n)</code></li>
<li>获取第 k 小元素：<code>O(log n)</code></li>
<li>获取小于 x 的元素数量：<code>O(log n)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> tree&lt;</span><br><span class="line">    <span class="type">int</span>, </span><br><span class="line">    null_type, </span><br><span class="line">    less&lt;<span class="type">int</span>&gt;, </span><br><span class="line">    rb_tree_tag, </span><br><span class="line">    tree_order_statistics_node_update</span><br><span class="line">&gt; ordered_set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ordered_set s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">7</span>) != s.<span class="built_in">end</span>()) s.<span class="built_in">erase</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The 2nd smallest element is: &quot;</span> &lt;&lt; *s.<span class="built_in">find_by_order</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(<span class="number">5</span>) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;5 exists in the set\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Minimum element: &quot;</span> &lt;&lt; *s.<span class="built_in">find_by_order</span>(<span class="number">0</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Maximum element: &quot;</span> &lt;&lt; *s.<span class="built_in">find_by_order</span>(s.<span class="built_in">size</span>() - <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="数值与字符串转化"><a href="#数值与字符串转化" class="headerlink" title="数值与字符串转化"></a>数值与字符串转化</h4><table>
<thead>
<tr>
<th>函数签名</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>to_string(val)</code></td>
<td>把 <code>val</code> 转换成 <code>string</code></td>
</tr>
<tr>
<td><code>stoi(s, p, b)</code></td>
<td>把字符串 <code>s</code> 从下标 <code>p</code> 开始转换成 <code>b</code> 进制的 <code>int</code></td>
</tr>
<tr>
<td><code>stol(s, p, b)</code></td>
<td>转换成 <code>long</code></td>
</tr>
<tr>
<td><code>stoul(s, p, b)</code></td>
<td>转换成 <code>unsigned long</code></td>
</tr>
<tr>
<td><code>stoll(s, p, b)</code></td>
<td>转换成 <code>long long</code></td>
</tr>
<tr>
<td><code>stoull(s, p, b)</code></td>
<td>转换成 <code>unsigned long long</code></td>
</tr>
<tr>
<td><code>stof(s, p, b)</code></td>
<td>转换成 <code>float</code></td>
</tr>
<tr>
<td><code>stod(s, p, b)</code></td>
<td>转换成 <code>double</code></td>
</tr>
<tr>
<td><code>stold(s, p, b)</code></td>
<td>转换成 <code>long double</code></td>
</tr>
</tbody></table>
<p><code>p</code> 和 <code>b</code>可省，默认为十进制</p>
<h4 id="字符串输入与分割"><a href="#字符串输入与分割" class="headerlink" title="字符串输入与分割"></a>字符串输入与分割</h4><p><code>getline(cin, s)</code></p>
<p><code>stringstream s(ss)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;</span><br><span class="line"><span class="built_in">getline</span>(cin, s1);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s1)</span></span>;</span><br><span class="line">string temp;</span><br><span class="line"><span class="comment">// while(ss &gt;&gt; temp) 按空格读取</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ss, temp, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        temp = temp.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        v1.<span class="built_in">push_back</span>(-<span class="built_in">stoi</span>(temp));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>(起点, 终点, 输出位置, 处理函数)</span><br><span class="line"><span class="comment">// 变小写</span></span><br><span class="line"><span class="built_in">transform</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), s1.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="comment">// 变大写</span></span><br><span class="line"><span class="built_in">transform</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), s1.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line"><span class="comment">// 转换到另一个字符串</span></span><br><span class="line">string src = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string dest;</span><br><span class="line">dest.<span class="built_in">resize</span>(src.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="comment">// dest 现在是 &quot;hello&quot;，原始 src 不变</span></span><br></pre></td></tr></table></figure>

<h4 id="子串substr"><a href="#子串substr" class="headerlink" title="子串substr"></a>子串<code>substr</code></h4><p><code>substr(st, len)</code></p>
<p><code>len</code>省略时表示到en</p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><h5 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;There are two needles in this haystack with needles.&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">str2</span> <span class="params">(<span class="string">&quot;needle&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//在str当中查找第一个出现的needle，找到则返回出现的位置，否则返回结尾</span></span><br><span class="line">    std::<span class="type">size_t</span> found = str.<span class="built_in">find</span>(str2);</span><br><span class="line">    <span class="keyword">if</span> (found!=std::string::npos) <span class="comment">// 结尾</span></span><br><span class="line">    <span class="comment">//在str当中，从第found+1的位置开始查找参数字符串的前6个字符</span></span><br><span class="line">    found = str.<span class="built_in">find</span>(<span class="string">&quot;needles are small&quot;</span>,found+<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="rfind"><a href="#rfind" class="headerlink" title="rfind"></a><code>rfind</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rfind是找最后一个出现的匹配字符串</span></span><br><span class="line">std::<span class="type">size_t</span> found = str.<span class="built_in">rfind</span>(str2);</span><br></pre></td></tr></table></figure>

<h5 id="find-of"><a href="#find-of" class="headerlink" title="find_...of"></a><code>find_...of</code></h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find_first_of</span>(args) <span class="comment">// **查找args中任何一个字符第一次出现的位置**</span></span><br><span class="line"><span class="built_in">find_last_of</span>(args) <span class="comment">// **最后一个出现的位置**</span></span><br><span class="line"><span class="built_in">find_fist_not_of</span>(args) <span class="comment">// **查找第一个不在args中的字符**</span></span><br><span class="line">find_last_not_of <span class="comment">// **查找最后一个不在args中出现的字符**</span></span><br></pre></td></tr></table></figure>

<h4 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert"></a>插入insert</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string str=<span class="string">&quot;to be question&quot;</span>;</span><br><span class="line">    string str2=<span class="string">&quot;the &quot;</span>;</span><br><span class="line">    string str3=<span class="string">&quot;or not to be&quot;</span>;</span><br><span class="line">    string::iterator it;</span><br><span class="line">    <span class="comment">//s.insert(pos,str)//在s的pos位置插入str</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">6</span>,str2); </span><br><span class="line">    <span class="comment">//s.insert(pos,str,a,n)在s的pos位置插入str中插入位置a到后面的n个字符</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">6</span>,str3,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//s.insert(pos,cstr,n)//在pos位置插入cstr字符串从开始到后面的n个字符</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">10</span>,<span class="string">&quot;that is cool&quot;</span>,<span class="number">8</span>); </span><br><span class="line">    <span class="comment">//s.insert(pos,n,ch)在s.pos位置上面插入n个ch</span></span><br><span class="line">    str.<span class="built_in">insert</span>(<span class="number">15</span>,<span class="number">1</span>,<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="comment">//s.insert(s.it,ch)在s的it指向位置前面插入一个字符ch，返回新插入的位置的迭代器</span></span><br><span class="line">    it = str.<span class="built_in">insert</span>(str.<span class="built_in">begin</span>()+<span class="number">5</span>,<span class="string">&#x27;,&#x27;</span>); <span class="comment">// to be, not to be: that is the question</span></span><br><span class="line">    <span class="comment">//s.insert(s.it,n,ch)//在s的it所指向位置的前面插入n个ch</span></span><br><span class="line">    str.<span class="built_in">insert</span> (str.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="comment">//s.insert(it,str.ita,str.itb)在it所指向的位置的前面插入[ita,itb)的字符串</span></span><br><span class="line">    str.<span class="built_in">insert</span> (it+<span class="number">2</span>,str3.<span class="built_in">begin</span>(),str3.<span class="built_in">begin</span>()+<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map  &amp; unordered_map"></a>map  &amp; unordered_map</h3><p>map基于红黑树（或其他平衡二叉树）实现，所有元素按照key的大小有序存储。</p>
<p>unordered_map基于哈希表实现，元素按照哈希桶无序存储。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>map</th>
<th>unordered_map</th>
</tr>
</thead>
<tbody><tr>
<td>查找&#x2F;插入&#x2F;删除</td>
<td>O(logN)（严格）</td>
<td>平均O(1),最坏O(N)（哈希冲突）</td>
</tr>
</tbody></table>
<blockquote>
<p>如果对 key 的顺序有需求，或数据量不极端、性能要求严格稳定，就用 <code>map</code>。</p>
</blockquote>
<blockquote>
<p>如果数据随机分布、对遍历顺序无要求，希望获得极快的平均查找速度，可用 <code>unordered_map</code>，但要注意：</p>
<ol>
<li><strong>适当 <code>reserve</code></strong>：提前 <code>reserve(bucket_count)</code> 或 <code>max_load_factor</code> 来减少扩容；</li>
<li><strong>自定义哈希</strong>：在 CF 等平台上可用 <code>splitmix64</code> 等更安全的哈希函数，防止碰撞攻击。</li>
</ol>
</blockquote>
<h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">255</span>;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 布尔输出</span></span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;bool: &quot;</span> &lt;&lt; flag &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 进制</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dec: &quot;</span> &lt;&lt; dec &lt;&lt; num </span><br><span class="line">         &lt;&lt; <span class="string">&quot; hex: &quot;</span> &lt;&lt; hex &lt;&lt; num </span><br><span class="line">         &lt;&lt; <span class="string">&quot; oct: &quot;</span> &lt;&lt; oct &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dec; <span class="comment">// 恢复十进制</span></span><br><span class="line">    <span class="comment">// 浮点数格式</span></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;fixed: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; scientific &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; <span class="string">&quot;sci: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios::floatfield);</span><br><span class="line">    <span class="comment">// 宽度、对齐、填充</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;-&#x27;</span>) &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Left&quot;</span> &lt;&lt; right &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Right&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;_&#x27;</span>) &lt;&lt; right &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;hello\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 显示正号</span></span><br><span class="line">    cout &lt;&lt; showpos &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">-123</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h3 id="重载运算符号（比较）"><a href="#重载运算符号（比较）" class="headerlink" title="重载运算符号（比较）"></a>重载运算符号（比较）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, index;</span><br><span class="line">    <span class="built_in">my</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)&#123;</span><br><span class="line">        l = a, r = b, index = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> my x) <span class="type">const</span> &#123;  </span><br><span class="line">            <span class="comment">// 优先队列中比较关系反着来</span></span><br><span class="line">            <span class="keyword">return</span> l &gt; x.l;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda（示例为小根堆）</span></span><br><span class="line"><span class="keyword">auto</span> cmp = [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">q</span>(cmp); </span><br></pre></td></tr></table></figure>

<h3 id="求最大的最小或者最小的最大问题"><a href="#求最大的最小或者最小的最大问题" class="headerlink" title="求最大的最小或者最小的最大问题"></a>求最大的最小或者最小的最大问题</h3><p>大概率是用二分来查询最合适的答案，具体算法看题</p>
<h3 id="圆周率-960"><a href="#圆周率-960" class="headerlink" title="圆周率&#960;"></a>圆周率&#960;</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi  =  <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="求容器最大值"><a href="#求容器最大值" class="headerlink" title="求容器最大值"></a>求容器最大值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*<span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="全排列-1"><a href="#全排列-1" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;aba&quot;</span>; </span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;<span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">cout &lt;&lt; (<span class="built_in">rand</span>()) % <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>一个数为完全平方数当且仅当该分解后该数所有质因数个数均为偶数</p>
<h3 id="随机哈希编码"><a href="#随机哈希编码" class="headerlink" title="随机哈希编码"></a>随机哈希编码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="type">int</span> a_hash = <span class="built_in">rng</span>();</span><br></pre></td></tr></table></figure>

<h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 连续填充</span></span><br><span class="line"><span class="built_in">iota</span>(a, a + <span class="number">5</span>, <span class="number">1</span>);  <span class="comment">// a = &#123;1, 2, 3, 4, 5&#125;</span></span><br><span class="line"><span class="comment">// 适合设置为0、-1、255（即所有字节一致的值）</span></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));  <span class="comment">// 将数组 a 中的所有字节设为 0</span></span><br><span class="line"><span class="comment">// 支持所有基础类型和STL容器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="built_in">fill</span>(a, a + <span class="number">5</span>, <span class="number">42</span>);  <span class="comment">// a = &#123;42, 42, 42, 42, 42&#125;</span></span><br><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound &amp; upper_bound"></a>lower_bound &amp; upper_bound</h3><p>ower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。</p>
<p>在从小到大的排序数组中，</p>
<ul>
<li><p><code>lower_bound(begin, end, value)</code></p>
<p>  返回<strong>第一个 ≥ value 的位置</strong></p>
</li>
<li><p><code>upper_bound(begin, end, value)</code><br>  返回<strong>第一个 &gt; value 的位置</strong></p>
</li>
</ul>
<p>在从小到大的排序数组中，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), <span class="number">7</span>) - v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> pos2 = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), <span class="number">7</span>) - v.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; pos1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[pos1] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pos2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[pos2] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="type">int</span> pos3 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), <span class="number">7</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> pos4 = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), <span class="number">7</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) - v.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; pos3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[pos3] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pos4 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[pos4] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折尺定理"><a href="#折尺定理" class="headerlink" title="折尺定理"></a>折尺定理</h3><p>一堆有各自长度($a_{1},a_{2},a_{3} \dots$)木棍能否连接在两个点上，取决于是否$L_{\min}\le D\le L_{\max}$,其中，$L_{\max} &#x3D; \sum_{i &#x3D; 1}^{n}a_{i} $ ,$L_{\min} &#x3D; max(0, 2 * a_{\max} - L_{\max})$，D为两点间距离</p>
<h3 id="两两绝对值求和"><a href="#两两绝对值求和" class="headerlink" title="两两绝对值求和"></a>两两绝对值求和</h3><p>当你把一组数排序后，对所有「两两差的绝对值之和」$\sum_{0\le p&lt;q\le n} |a_q - a_p|$ 有一个经典结论：</p>
<p>$\sum_{0 \le p &lt; q \le n} (a_q - a_p)&#x3D; \sum_{k&#x3D;0}^n a_k (k - (n-k))$</p>
<p>这是因为：</p>
<ul>
<li><p>对于固定的$a_k$，它作为“右端” $q_{q}$ 的时候，会和前面所有 k 个更小的数 $a_0,\dots,a_{k-1}$ 相减，累计贡献</p>
<p>  $\displaystyle +,a_k\times k$。</p>
</li>
<li><p>同时它也会作为“左端” $a_p$ 被后面所有 (n−k) 个更大的数 $a_{k+1},\dots,a_n$相减，贡献</p>
<p>  $-,a_k\times (n - k)$。</p>
</li>
<li><p>合并起来，就是</p>
<p>  $a_k(k−(n−k))&#x3D;a_k(2k−n).$</p>
</li>
</ul>
<p>注意这里不需要再写绝对值了，因为排序保证了“后者减前者”总是非负的。</p>
<h3 id="ASCII-Table"><a href="#ASCII-Table" class="headerlink" title="ASCII Table"></a>ASCII Table</h3><p><img src="/algorithm/ASCII_Table.png" alt="ASCII_Table"></p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="/algorithm/priority.jpg" alt="priority"></p>
<h3 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h3><p><img src="/algorithm/%E8%A7%84%E6%A8%A1.png" alt="guimo"></p>
<h3 id="曼哈顿距离转换（菱形转矩形）"><a href="#曼哈顿距离转换（菱形转矩形）" class="headerlink" title="曼哈顿距离转换（菱形转矩形）"></a>曼哈顿距离转换（菱形转矩形）</h3><p>原菱形覆盖（曼哈顿距离$\le$）在（i,j）平面上难以直接判断，另u &#x3D; i + j, v &#x3D; i - j, 则菱形在(u, v)空间投影为轴对齐矩形</p>
<h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>一个排列中，交换任意两个数，会导致整个排列的逆序对个数奇偶性改变</p>
<blockquote>
<p>证明: 交换任意两个数L和R（L &lt; R，当L比R大时证明思路一致）,，L左边的和R右边的数对[L,R]内的数的贡献、(L,R)内的数相互之间的贡献不发生改变，再看(L,R)内，对于其中任意一个数，如果这个数在L和R中间，交换之前的该数与L和R的贡献值之和为0,那么L和R交换后，其贡献值还是2，若比L和R都小或者都大，交换前后的贡献值都是1，故不管三个数之间的关系是什么，改变都是偶数，都不改变总体奇偶性，而L和R的交换本身会带来绝对值为1的改变，故总体奇偶性最后改变</p>
</blockquote>
<p>一个排列中，对任意区间进行循环单向移动时，当移动区间的长度为奇数时，每次移动的改变都是偶数，不改变奇偶，长度偶数时，每次移动的改变都是奇数，故每次移动都会改变奇偶，</p>
<blockquote>
<p>证明：对于任何一个数，在长度为d的区间中，有a个数比他大，有b个数比他小，a + b &#x3D; d - 1，两个数的和为偶数，那么两个数的差也为偶数，而将一侧的数循环移动到另一侧时，在循环左移时，其贡献就是b - a，因此，其奇偶性确定</p>
</blockquote>
<h3 id="分层补齐高度问题"><a href="#分层补齐高度问题" class="headerlink" title="分层补齐高度问题"></a>分层补齐高度问题</h3><p>要把一个区间通过子区间加一的操作将区间统一高度，可以通过以下方法</p>
<ul>
<li>若i为第一个数，其代价为max - val[i]</li>
<li>否则，当i要被填补的高度大于i - 1时，才进行高度差距的补充，类似与只有上楼梯才有消耗，下楼梯没有消耗，代价为(max - val[i]) - (max - val[i - 1])</li>
</ul>
<p>而区间可容纳两种最终高度时，可dp每个点变为最终两个值中的某一个的代价，假设最终高度为x,y,可参考以下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N = <span class="number">400</span>;</span><br><span class="line"><span class="comment">// dp[i][0/1]：处理到下标 i（0-based），并且把 v1[i] 提升到“高位 x(=0)”或“低位 y(=1)”时，</span></span><br><span class="line"><span class="comment">//             使得前缀 0..i 达到目标高度序列所需的最小“操作代价”</span></span><br><span class="line"><span class="function">vector <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, vector&lt;<span class="type">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">   	<span class="keyword">while</span>(t --)&#123;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(n)</span></span>;</span><br><span class="line">		<span class="type">int</span> max1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp; x : v1) cin &gt;&gt; x, max1 = <span class="built_in">max</span>(max1, x);</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(m == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 只允许选择 1 个“目标高度”时，最优即取 H = max(v1)</span></span><br><span class="line">			<span class="comment">// 下面这段等价于：把所有位置都“补到” H 的最少“前缀加一”操作次数。</span></span><br><span class="line">			<span class="comment">// 令 delta[i] = H - v1[i]，则</span></span><br><span class="line">			<span class="comment">// 代价 = delta[0] + Σ_&#123;i=1..n-1&#125; max(0, delta[i] - delta[i-1])</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i == <span class="number">0</span>) ans += max1 - v1[i];</span><br><span class="line">				<span class="keyword">else</span> ans += <span class="built_in">max</span>(<span class="number">0ll</span>, (max1 - v1[i]) - (max1 - v1[i - <span class="number">1</span>]));</span><br><span class="line">				<span class="comment">//               ↑↑↑           即 delta[i] - delta[i-1]</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 允许选择 2 个“目标高度”：高位 x 与低位 y（并约束 y &lt;= x）</span></span><br><span class="line">		    <span class="comment">// 我们要在每个位置自由选择 x 或 y，使得 h[i] &gt;= v1[i] 且总代价最小。</span></span><br><span class="line">		    <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">		    	<span class="comment">// 初始化 DP 为 +∞</span></span><br><span class="line">		    	<span class="built_in">fill</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">begin</span>() + <span class="number">1</span> + n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">1e18</span>));</span><br><span class="line">		    	<span class="comment">// i = 0 的转移：若 v1[0] 不超过目标位，则代价为补到该位的“新开层数”</span></span><br><span class="line">		    	<span class="keyword">if</span>(v1[<span class="number">0</span>] &lt;= x) dp[<span class="number">0</span>][<span class="number">0</span>] = x - v1[<span class="number">0</span>];  <span class="comment">// delta[0] = x - v1[0]</span></span><br><span class="line">		    	<span class="keyword">if</span>(v1[<span class="number">0</span>] &lt;= y) dp[<span class="number">0</span>][<span class="number">1</span>] = y - v1[<span class="number">0</span>];  <span class="comment">// delta[0] = y - v1[0]</span></span><br><span class="line">		    	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">		    		<span class="comment">// 若当前位置选择“高位 x”</span></span><br><span class="line">		    		<span class="keyword">if</span>(v1[i] &lt;= x) &#123;</span><br><span class="line">		    			<span class="comment">// 从上一位也是 x 转来：</span></span><br><span class="line">		    			<span class="comment">//  需要额外付出 max(0, (x - v[i]) - (x - v[i-1])) = max(0, delta[i]-delta[i-1])</span></span><br><span class="line">		    			dp[i][<span class="number">0</span>] = <span class="built_in">min</span>(&#123;</span><br><span class="line">		    				dp[i][<span class="number">0</span>],</span><br><span class="line">		    				dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="built_in">max</span>(<span class="number">0ll</span>, (x - v1[i]) - (x - v1[i - <span class="number">1</span>])),</span><br><span class="line">		    				<span class="comment">// 从上一位是 y 转来：</span></span><br><span class="line">		    				<span class="comment">//  比较 delta[i]=x-v[i] 与 前一位的 delta[i-1]=y-v[i-1]</span></span><br><span class="line">		    				dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="built_in">max</span>(<span class="number">0ll</span>, (x - v1[i]) - (y - v1[i - <span class="number">1</span>]))</span><br><span class="line">		    			&#125;);</span><br><span class="line">		    		&#125;</span><br><span class="line">		    		<span class="comment">// 若当前位置选择“低位 y”</span></span><br><span class="line">		    		<span class="keyword">if</span>(v1[i] &lt;= y) &#123;</span><br><span class="line">		    			dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(&#123;</span><br><span class="line">		    				dp[i][<span class="number">1</span>],</span><br><span class="line">		    				dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="built_in">max</span>(<span class="number">0ll</span>, (y - v1[i]) - (x - v1[i - <span class="number">1</span>])),</span><br><span class="line">		    				dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="built_in">max</span>(<span class="number">0ll</span>, (y - v1[i]) - (y - v1[i - <span class="number">1</span>]))</span><br><span class="line">		    			&#125;);</span><br><span class="line">		    		&#125;</span><br><span class="line">		    	&#125;</span><br><span class="line">		    	<span class="keyword">return</span> <span class="built_in">min</span>(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		    &#125;;</span><br><span class="line">		    <span class="comment">// 穷举所有 (x, y)（0..200 且 y&lt;=x）取最小值</span></span><br><span class="line">		    <span class="comment">// 注：范围 200 来自题面（或数据范围）假设</span></span><br><span class="line">		    ans = <span class="number">1e18</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i ++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">					ans = <span class="built_in">min</span>(ans, <span class="built_in">get</span>(i, j));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行列取模构造"><a href="#行列取模构造" class="headerlink" title="行列取模构造"></a>行列取模构造</h3><p>对于给定的行n和列m,如果需要给定n个值a和m个值b，那么所构成的n*m矩阵M中,$M_{ij}&#x3D;a_{i}b_{j} \mod nm, 1 &lt;&#x3D; i &lt;&#x3D; n,1 &lt;&#x3D; j &lt;&#x3D; m$，每个数都不一样，且所有的a和b都处于[0, n * m - 1]中，应该如何给定每一个a和b的值。</p>
<p>答案为：构造 <strong>$a_i &#x3D; (i \ast m + 1) \mod n \ast m ,(1 ≤ i ≤ n) 和 b_j &#x3D; (j \ast m + 1) \mod n \ ast m ,(1 ≤ j ≤ m)$。</strong></p>
<p>证明：对于 $i&#x3D;1$ 到 $n$，$a_i &#x3D; (i \ast m + 1) \mod n \ast m$；对于 $j&#x3D;1$ 到 $m$，$b_j &#x3D; (j \ast n + 1) \mod n \ast m$。这样产生的 $n \times m$ 个值 $c_{i,j} &#x3D; a_i \ast b_j \mod (n \ast m)$。为简便起见，令 $N &#x3D; n \ast m$。</p>
<p>题解中的证明显示，如果 $a_i b_j \equiv a_{i’} b_{j’} \pmod{N}$，则 $m(i - i’) \equiv n(j’ - j) \pmod{N}$。重新整理后，可得 $m(i - i’ - k n) &#x3D; n(j’ - j)$ 对于某个整数 $k$。由于 $\gcd(m, n) &#x3D; 1$，由此可知 $m$ 整除 $(j’ - j)$。但 $|j’ - j| &lt; m$，因此唯一可能的是 $j’ &#x3D; j$，进而 $i’ &#x3D; i$。从而，所有 $c_{i,j}$ 在模 $N$ 下两两不同。</p>
<p>共有恰好 $N$ 个这样的 $c_{i,j}$ 值（对应 $n \times m &#x3D; N$ 个 $(i, j)$ 对），且它们均为 ${0, 1, \dots, N-1}$ 中的不同整数。因此，集合 ${c_{i,j}}$ 必须恰好是 ${0, 1, \dots, N-1}$，因为这是一个从大小为 $N$ 的集合到大小为 $N$ 的集合的单射映射（模 $N$ 下）。</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>这个部分涉及数学中几何，微积分等的一般知识</p>
<h3 id="常见期望计算"><a href="#常见期望计算" class="headerlink" title="常见期望计算"></a>常见期望计算</h3><p>下面是 <strong>期望计算中最常见</strong> 的几类级数及其 <strong>封闭形式结果</strong>（闭合表达式）,所有级数都假设 ( |r| &lt; 1 )，否则发散。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>级数形式</th>
<th>封闭形式（求和结果）</th>
<th>常见应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>$(\sum_{k&#x3D;0}^{\infty} r^k )$</td>
<td>$(\dfrac{1}{1-r})$</td>
<td>普通几何级数，概率归一化</td>
</tr>
<tr>
<td>2</td>
<td>$(\sum_{k&#x3D;1}^{\infty} r^k )$</td>
<td>$(\dfrac{r}{1-r})$</td>
<td>从第 1 项开始的几何级数</td>
</tr>
<tr>
<td>3</td>
<td>$(\sum_{k&#x3D;0}^{\infty} k r^{k} )$</td>
<td>$(\dfrac{r}{(1-r)^2})$</td>
<td>常用于“失败 k 次”的贡献</td>
</tr>
<tr>
<td>4</td>
<td>$(\sum_{k&#x3D;1}^{\infty} k r^{k-1} )$</td>
<td>$(\dfrac{1}{(1-r)^2})$</td>
<td><strong>几何分布期望的核心</strong></td>
</tr>
<tr>
<td>5</td>
<td>$(\sum_{k&#x3D;1}^{\infty} k r^{k} )$</td>
<td>$(\dfrac{r}{(1-r)^2})$</td>
<td>同上，指数少 1</td>
</tr>
<tr>
<td>6</td>
<td>$(\sum_{k&#x3D;1}^{\infty} k(k-1) r^{k} )$</td>
<td>$(\dfrac{2r^2}{(1-r)^3})$</td>
<td>二阶矩、方差计算时出现</td>
</tr>
<tr>
<td>7</td>
<td>$(\sum_{k&#x3D;2}^{\infty} k(k-1) r^{k-2} )$</td>
<td>$(\dfrac{2}{(1-r)^3})$</td>
<td>提取二阶导数时用</td>
</tr>
<tr>
<td>8</td>
<td>$(\sum_{k&#x3D;0}^{\infty} \binom{k+n-1}{n-1} r^k )$</td>
<td>$(\dfrac{1}{(1-r)^n})$</td>
<td>负二项分布归一化（n 重几何）</td>
</tr>
<tr>
<td>9</td>
<td>$(\sum_{k&#x3D;1}^{\infty} k \binom{k+n-2}{n-1} r^k )$</td>
<td>$(\dfrac{n r}{(1-r)^{n+1}})$</td>
<td>负二项期望（等待 n 次成功）</td>
</tr>
</tbody></table>
<p>最常用的 3 个“背口诀”版本（直接套）</p>
<ol>
<li><p><strong>普通几何分布（第一次成功需要的试验次数）</strong><br>$E[X] &#x3D; \sum_{i&#x3D;1}^{\infty} i q^{i-1} p &#x3D; \frac{1}{p}$</p>
</li>
<li><p><strong>从 0 开始计数失败次数</strong>（失败了 k 次再成功）<br>$E[\text{失败次数}] &#x3D; \sum_{k&#x3D;0}^{\infty} k q^k p &#x3D; \frac{q}{p}$</p>
</li>
<li><p><strong>负二项（等到第 r 次成功需要的总试验次数）</strong><br>$E[X] &#x3D; \frac{r}{p}$</p>
</li>
</ol>
<p>常用变形速算表（直接代入）</p>
<table>
<thead>
<tr>
<th>题目给的 p</th>
<th>对应的期望</th>
</tr>
</thead>
<tbody><tr>
<td>$(p &#x3D; \dfrac{1}{n})$</td>
<td>$(E &#x3D; n)$</td>
</tr>
<tr>
<td>$(p &#x3D; \dfrac{a}{b})$</td>
<td>$(E &#x3D; \dfrac{b}{a})$</td>
</tr>
<tr>
<td>$(p &#x3D; 0.01)$</td>
<td>$(E &#x3D; 100)$</td>
</tr>
<tr>
<td>$(p &#x3D; \dfrac{1}{100})$</td>
<td>$(E &#x3D; 100)$</td>
</tr>
<tr>
<td>$(p &#x3D; \dfrac{m}{n})$</td>
<td>$(E &#x3D; \dfrac{n}{m})$</td>
</tr>
</tbody></table>
<p>方差快速计算</p>
<p>几何分布方差：<br>$\text{Var}(X) &#x3D; \frac{q}{p^2} &#x3D; \frac{1-p}{p^2}$</p>
<h3 id="组合数求和"><a href="#组合数求和" class="headerlink" title="组合数求和"></a>组合数求和</h3><p>$\sum_{i &#x3D; 1}^{n} \frac{i * (i + 1)}{2}$的值为(n * (n + 1) * (n + 2)) &#x2F; 6.</p>
<h3 id="数位和之和"><a href="#数位和之和" class="headerlink" title="数位和之和"></a>数位和之和</h3><p>数位和的意思是对于f(100), 其值为每一位上的数之和，值为1+0+0&#x3D;1,而对于f(123),其值同理为1+2+3&#x3D;6.</p>
<p>若要求$zh$，方法如下，将视角转移至数位上，把所有数的数位以补零的方式与n的数位对齐，然后分三部分进行值的计算：</p>
<p>计算之前要指出，对于$10^{l}$次方以前的数，每一个$10^{l}$都对应着$l * 10^{l - 1}$个45，可自行枚举再稍加思考发现规律</p>
<ol>
<li>当前数字以前的所有数字所对应的45的组数</li>
<li>当前位的当前数字以前的值之和</li>
<li>当前位的当前数字的和</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://codeforces.com/contest/2132/problem/D</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;   <span class="comment">// 输入测试用例数量</span></span><br><span class="line">    <span class="keyword">while</span>(t --)&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;   <span class="comment">// 输入 k（保留的总位数）</span></span><br><span class="line">        <span class="comment">// get(x): 计算从 1 拼到 x 一共用了多少位数字</span></span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="type">int</span> len1 = <span class="number">0</span>;   <span class="comment">// 记录总长度</span></span><br><span class="line">            <span class="type">int</span> p = <span class="number">1</span>;      <span class="comment">// 当前区间的起始数：1, 10, 100, ...</span></span><br><span class="line">            <span class="type">int</span> d = <span class="number">1</span>;      <span class="comment">// 当前区间的位数（1 位数，2 位数，...）</span></span><br><span class="line">            <span class="comment">// 先处理完整区间（例如 1~9, 10~99, ...）</span></span><br><span class="line">            <span class="keyword">while</span>(p * <span class="number">10</span> &lt;= x) &#123;</span><br><span class="line">                len1 += <span class="number">9</span> * p * d;  <span class="comment">// 该区间一共的位数 = 数字个数 * 位数</span></span><br><span class="line">                d ++;</span><br><span class="line">                p *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后剩余区间（p..x）</span></span><br><span class="line">            len1 += (x - p + <span class="number">1</span>) * d;</span><br><span class="line">            <span class="keyword">return</span> len1;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 二分查找：找到最小的 ans 使得写到 ans 的位数 ≥ n</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1e15</span>, mid, ans;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">get</span>(mid) &gt;= n) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>; <span class="comment">// 结果：数位和</span></span><br><span class="line">        <span class="comment">// 如果 get(ans) &gt; n，说明 ans 的最后一个数可能多取了几位，需要回退</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(ans) &gt; n) &#123;</span><br><span class="line">            <span class="type">int</span> x = ans;</span><br><span class="line">            <span class="type">int</span> len2 = <span class="built_in">get</span>(ans --); <span class="comment">// 先退到 ans-1</span></span><br><span class="line">            <span class="comment">// 继续退掉多余的位</span></span><br><span class="line">            <span class="keyword">while</span>(len2 &gt; n) len2 --, x /= <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 把保留下来的 x 的每一位加到答案</span></span><br><span class="line">            <span class="keyword">while</span>(x) val += x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理完整的部分（1 到 ans）</span></span><br><span class="line">        <span class="keyword">if</span>(ans) &#123;</span><br><span class="line">            string s = <span class="built_in">to_string</span>(ans); <span class="comment">// 把 ans 转成字符串</span></span><br><span class="line">            <span class="type">int</span> l = <span class="number">1</span>;    <span class="comment">// 当前处理的位数</span></span><br><span class="line">            <span class="type">int</span> base = <span class="number">1</span>; <span class="comment">// 位权</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;  <span class="comment">// 前缀和（用来算贡献）   </span></span><br><span class="line">            <span class="comment">// 从低位到高位枚举 ans 的每一位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i = s.<span class="built_in">rbegin</span>(); i &lt; s.<span class="built_in">rend</span>(); i ++, base *= <span class="number">10</span>, l ++) &#123;</span><br><span class="line">                <span class="type">int</span> x = *i - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 当前位的数值</span></span><br><span class="line">                sum += x * base;</span><br><span class="line">                <span class="comment">// 复杂的公式：计算该位对数位和的贡献</span></span><br><span class="line">                val += x * (x - <span class="number">1</span>) / <span class="number">2</span> * base              <span class="comment">// 当前位取 0..(x-1) 的贡献</span></span><br><span class="line">                    + <span class="number">45</span> * base / <span class="number">10</span> * (l - <span class="number">1</span>) * x         <span class="comment">// 低位的循环贡献</span></span><br><span class="line">                    + x * (sum - x * base + <span class="number">1</span>);            <span class="comment">// 高位固定时的贡献</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隔板法（Stars-and-Bars）"><a href="#隔板法（Stars-and-Bars）" class="headerlink" title="隔板法（Stars and Bars）"></a>隔板法（Stars and Bars）</h3><p><strong>无界非负整数组合</strong></p>
<ul>
<li>题型：求非负整数解   $x_1+\cdots+x_k&#x3D;N$ 的方案数</li>
<li>答案：$\binom{N+k-1}{k-1}$</li>
<li>含义：把 N 个「星星」放入 kk个「盒子」，盒子间用 k−1道隔板分隔。</li>
</ul>
<p><strong>单调序列差分</strong></p>
<p>非增&#x2F;非减序列（$a_1 \ge a_2 \ge \dots \ge a_k \ge 0$）可转为差分$d_i &#x3D; a_i - a_{i - 1}$,再用隔板法算$\sum di &#x3D; a_k - a_1$</p>
<h3 id="普通生成函数（OGF）"><a href="#普通生成函数（OGF）" class="headerlink" title="普通生成函数（OGF）"></a>普通生成函数（OGF）</h3><p>定义</p>
<ul>
<li>给定序列 ${a_n}$，其 OGF 为<br>  $$<br>  A(t)&#x3D;\sum_{n\ge0}a_n,t^n.<br>  $$</li>
</ul>
<p>乘法对应「独立事件的卷积」</p>
<ul>
<li>若要把两类结构独立拼接，总方案数的序列是两生成函数相乘：<br>  $$<br>  A(t)\times B(t);\Longrightarrow;  [t^n]\bigl(A(t)B(t)\bigr);&#x3D;;\sum_{i+j&#x3D;n}a_i,b_j.<br>  $$</li>
</ul>
<p>幂运算</p>
<ul>
<li>$A(t)^k$ 表示独立选取 k 份相同结构并联。</li>
</ul>
<h3 id="广义二项式与系数提取"><a href="#广义二项式与系数提取" class="headerlink" title="广义二项式与系数提取"></a>广义二项式与系数提取</h3><p><strong>广义二项式定理</strong><br>$$<br>(1 - t)^{-\alpha}  &#x3D; \sum_{n&#x3D;0}^\infty      \binom{\alpha+n-1}{n},t^n, \quad \binom{\alpha+n-1}{n} &#x3D; \frac{\alpha(\alpha+1)\cdots(\alpha+n-1)}{n!}.<br>$$<br><strong>系数提取</strong></p>
<ul>
<li><p>对于已知闭式 G(t)，常用：</p>
<p>  $[t^n],G(t) \quad\text{或}\quad  \text{前缀和 }\sum_{i&#x3D;0}^n [t^i]G(t).$</p>
</li>
</ul>
<p><strong>累加恒等式</strong><br>$$<br>\sum_{i&#x3D;0}^m \binom{i+r}{r}  &#x3D; \binom{m+r+1}{r+1},  \quad  \sum_{i&#x3D;0}^m \binom{r}{i}  &#x3D; \binom{r}{0}+\cdots+\binom{r}{m}.<br>$$</p>
<h3 id="求二维平面上的三角形面积"><a href="#求二维平面上的三角形面积" class="headerlink" title="求二维平面上的三角形面积"></a>求二维平面上的三角形面积</h3><h4 id="给定三个顶点"><a href="#给定三个顶点" class="headerlink" title="给定三个顶点"></a>给定三个顶点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S = <span class="built_in">abs</span>(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">S = <span class="built_in">abs</span>((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 两个参数相较于三个参数，有如下优势，可以取一个坐标为基准（2坐标与1坐标，3坐标与1坐标，每个参数都进行了一次碰面），进行点与点之间的逻辑处理，如判断处坐标异或值</span></span><br></pre></td></tr></table></figure>

<h4 id="给定三条边"><a href="#给定三条边" class="headerlink" title="给定三条边"></a>给定三条边</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">S = <span class="built_in">sqrt</span>(p * (p -a ) * (p - b) * (p - c));</span><br></pre></td></tr></table></figure>

<h3 id="求三维空间中两条直线最短距离"><a href="#求三维空间中两条直线最短距离" class="headerlink" title="求三维空间中两条直线最短距离"></a>求三维空间中两条直线最短距离</h3><p><code>L1</code>经过<code>A(x1,  y1,  z1)</code>, <code>B(x2,  y2,  z2)</code></p>
<p><code>L2</code>经过<code> C(x3,  y3,  z3)</code>, <code>D(x4,  y4,  z4)</code></p>
<p><code>L1</code>的方向向量<code>d1 = B - A</code>, <code>L2</code>的方向向量<code>d2 = D - C</code></p>
<p><code>n = d1 * d2</code></p>
<p>如果n为0,则两直线平行</p>
<p>任选<code>L1</code>上的点A和<code>L2</code>上的点C，计算<code>AC = C - A</code></p>
<p>不平行时，两直线最短距离<code>d = |AC  .*  n| / |n|</code></p>
<p>平行时，<code>d = |AC * d1| / |d1|</code></p>
<hr>
<p>不平行情况<br>$$<br>若 \vec{d_1} \times \vec{d_2} \neq 0，则最短距离公式为<br>$$</p>
<p>$$<br>d &#x3D; \frac{\left| (C - A) \cdot \bigl(\vec{d_1} \times \vec{d_2}\bigr) \right|}{|\vec{d_1} \times \vec{d_2}|}.<br>$$</p>
<p>其中：<br>$$<br>(C - A) 表示向量，<br>\cdot 为点乘，<br>\times 为叉乘。<br>$$</p>
<p>$$<br>该公式的几何意义是：\vec{d_1} \times \vec{d_2} 垂直于两条直线，(C - A) 在此垂直方向上的投影长度即为两条直线的最短距离。<br>$$</p>
<p>平行情况<br>$$<br>若 \vec{d_1} \times \vec{d_2} &#x3D; 0，则说明两条直线平行或重合。此时最短距离可以由下式给出：<br>$$</p>
<p>$$<br>d &#x3D; \frac{|(C - A) \times \vec{d_1}|}{|\vec{d_1}|}.<br>$$</p>
<p>如果出现退化情况（例如 A&#x3D;B 或 C&#x3D;D），需要进一步做特殊处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sc second</span></span><br><span class="line"><span class="comment">// baidu 14 2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="type">double</span> x, y, z;</span><br><span class="line">	<span class="built_in">point</span>(<span class="type">double</span> x1 = <span class="number">0</span>, <span class="type">double</span> y1 = <span class="number">0</span>, <span class="type">double</span> z1 = <span class="number">0</span>): <span class="built_in">x</span>(x1), <span class="built_in">y</span>(y1), <span class="built_in">z</span>(z1) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>) -&gt; ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)&#123;</span><br><span class="line">    	<span class="type">double</span> x1, x2, x3, x4, y1, y2, y3, y4, z1, z2, z3, z4;</span><br><span class="line">    	cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2 &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; z3 &gt;&gt; x4 &gt;&gt; y4 &gt;&gt; z4;</span><br><span class="line">    	point a = point&#123;x1, y1, z1&#125;, b = &#123;x2, y2, z2&#125;, c = &#123;x3, y3, z3&#125;, d = &#123;x4, y4, z4&#125;;</span><br><span class="line">    	<span class="comment">// 向量减法：返回 b - a</span></span><br><span class="line">    	<span class="keyword">auto</span> vecSub = [](<span class="type">const</span> point &amp; a, <span class="type">const</span> point &amp; b) -&gt; point &#123;</span><br><span class="line">    		point temp = <span class="built_in">point</span>(b.x - a.x, b.y - a.y, b.z - a.z);</span><br><span class="line">    		<span class="keyword">return</span> temp;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	<span class="comment">// 向量叉乘 (仅适用于 3D)</span></span><br><span class="line">    	<span class="keyword">auto</span> crossProduct = [](<span class="type">const</span> point &amp; a, <span class="type">const</span> point &amp; b) -&gt; point&#123;</span><br><span class="line">    		point temp = <span class="built_in">point</span>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);</span><br><span class="line">    		<span class="keyword">return</span> temp;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	<span class="comment">// 向量点乘</span></span><br><span class="line">    	<span class="keyword">auto</span> dotProduct = [](<span class="type">const</span> point &amp; a, <span class="type">const</span> point &amp; b) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> a.x * b.x + a.y * b.y + a.z * b.z;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	<span class="comment">// 向量的模长</span></span><br><span class="line">    	<span class="keyword">auto</span> norm = [](<span class="type">const</span> point &amp; a) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y + a.z * a.z);</span><br><span class="line">    	&#125;;</span><br><span class="line">    	point d1 = <span class="built_in">vecSub</span>(a, b), d2 = <span class="built_in">vecSub</span>(c, d); </span><br><span class="line">    	point n = <span class="built_in">crossProduct</span>(d1, d2);</span><br><span class="line">    	<span class="type">double</span> norm_n = <span class="built_in">norm</span>(n);</span><br><span class="line">    	point AC = <span class="built_in">vecSub</span>(c, a);</span><br><span class="line">    	<span class="type">double</span> distance = <span class="number">0.0</span>;</span><br><span class="line">    	<span class="comment">// 如果 n != 0，说明两条直线不平行</span></span><br><span class="line">    	<span class="keyword">if</span>(<span class="built_in">fabs</span>(norm_n) &gt; <span class="number">1e-12</span>)&#123;</span><br><span class="line">    		<span class="comment">// 最短距离公式: |(C - A) · (d1 x d2)| / ||d1 x d2||</span></span><br><span class="line">    		distance = <span class="built_in">fabs</span>(<span class="built_in">dotProduct</span>(AC, n)) / norm_n;</span><br><span class="line">    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    		<span class="comment">// n = 0，说明两条直线平行或共线</span></span><br><span class="line">		    <span class="comment">// 使用平行直线距离公式: ||(C - A) x d1|| / ||d1||</span></span><br><span class="line">		    point temp1 = <span class="built_in">crossProduct</span>(AC, d1);</span><br><span class="line">		    <span class="type">double</span> norm_temp1 = <span class="built_in">norm</span>(temp1), norm_d1 = <span class="built_in">norm</span>(d1);</span><br><span class="line">		    <span class="keyword">if</span>(<span class="built_in">fabs</span>(norm_d1) &lt; <span class="number">1e-12</span>)&#123;</span><br><span class="line">		    	<span class="comment">// 若 d1Norm=0，说明 A、B 是同一点；若 d2Norm=0，C、D 同理。此时需特殊处理</span></span><br><span class="line">		    	<span class="type">double</span> norm_d2 = <span class="built_in">norm</span>(d2);</span><br><span class="line">		    	<span class="keyword">if</span>(<span class="built_in">fabs</span>(norm_d2) &lt; <span class="number">1e-12</span>)&#123;</span><br><span class="line">		    		<span class="comment">// 两条“直线”都是点，计算 A 到 C 的距离</span></span><br><span class="line">		    		distance = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - c.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - c.y, <span class="number">2</span>) + <span class="built_in">pow</span>(a.z - c.z, <span class="number">2</span>));</span><br><span class="line">;		    	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		    		<span class="comment">// 只需计算点 A 到直线 CD 的距离</span></span><br><span class="line">	                <span class="comment">// 距离 = ||(C - A) x d2|| / ||d2||</span></span><br><span class="line">	                point temp2 = <span class="built_in">crossProduct</span>(AC, d2);</span><br><span class="line">	                distance = <span class="built_in">norm</span>(temp2) / <span class="built_in">norm</span>(d2);</span><br><span class="line">		    	&#125;</span><br><span class="line">		    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		    	distance = <span class="built_in">norm</span>(temp1) / <span class="built_in">norm</span>(d1);</span><br><span class="line">		    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, distance);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点到直线的距离公式-关系（三点之间）"><a href="#点到直线的距离公式-关系（三点之间）" class="headerlink" title="点到直线的距离公式 &amp; 关系（三点之间）"></a>点到直线的距离公式 &amp; 关系（三点之间）</h3><p>设$P(x_0,,y_0)$为平面上一点，  直线 L 的方程为<br>$$<br>A x + B y + C &#x3D; 0.<br>$$<br>则P到直线L的距离d为<br>$$<br>d &#x3D; \frac{|,A x_0 + B y_0 + C,|}{\sqrt{A^2 + B^2}}.<br>$$</p>
<p>平面上三个点A()x1, y1), B(x2, y2), C(x3, y3), 判断点C与$\overrightarrow{AB}$的位置关系</p>
<p>S(A, B, C) &#x3D; $\frac{(x1-x3)(y2-y3)-(y1-y3)(x2-x3)}{2}$</p>
<p>若S大于0，则C在矢量AB的左侧</p>
<p>若S小于0，则C在矢量AB的右侧</p>
<p>若S等于0，则C在直线AB上。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/tengfei461807914/article/details/52203202">字符串 CSDN</a></p>
<p><a href="https://github.com/algorithmzuo/algorithm-journey">左程云</a></p>
<p><a href="https://blog.csdn.net/duiwangxiaomi/article/details/104288351">三角形面积</a></p>
<p><a href="https://blog.csdn.net/qq_40160605/article/details/80150252">lower_bound &amp; upper_bound</a></p>
<p><a href="https://c-cpp.com/cpp">C++ 参考手册</a></p>
<p><a href="https://en.wikipedia.org/wiki/ASCII">ASCII WIKI</a></p>
<p><a href="https://blog.csdn.net/weixin_43983431/article/details/107432456">判断点与直线的位置关系</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%AF%8D%E5%87%BD%E6%95%B0">母函数</a></p>
<p><a href="https://oi-wiki.org/math/poly/fft/">傅里叶变换</a></p>
<p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91">AVL树</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/101321696">Morris遍历文案</a>.</p>
<p><a href="https://blog.csdn.net/qq_40279192/article/details/107292156?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522df834af3111baf8fa93481f376c5de7d%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=df834af3111baf8fa93481f376c5de7d&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-107292156-null-null.nonecase&utm_term=DES&spm=1018.2226.3001.4450">CSDN_DES</a></p>
<p><a href="https://blog.csdn.net/qq_40279192/article/details/107420773?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522c9530f4b9b0bee46780fc323086fca0e%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=c9530f4b9b0bee46780fc323086fca0e&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-107420773-null-null.nonecase&utm_term=IDEA&spm=1018.2226.3001.4450">CSDN_IDEA</a></p>
]]></content>
      <categories>
        <category>Learn</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Data_Structure</tag>
      </tags>
  </entry>
</search>
